{"meta":{"title":"Jianxiong","subtitle":null,"description":null,"author":"Jianxiong","url":"https://github.com/jianxiongc","root":"/blog/"},"pages":[{"title":"categories","date":"2019-07-14T03:54:33.000Z","updated":"2019-07-15T04:00:36.142Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/jianxiongc/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-07-14T03:52:39.000Z","updated":"2019-07-15T03:59:56.745Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/jianxiongc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Swift学习","slug":"Swift - 变量与常量","date":"2019-07-20T15:20:04.000Z","updated":"2019-07-20T15:48:11.011Z","comments":true,"path":"2019/07/20/Swift - 变量与常量/","link":"","permalink":"https://github.com/jianxiongc/2019/07/20/Swift - 变量与常量/","excerpt":"","text":"Swift - 变量与常量变量和常量变量变量是编程语言中最常用的语法元素，它们用于在程序中把一个名字（例如：swiftString）和某种特定类型的值（例如：”Swift is fun.”）关联起来。 在Swift中，我们使用关键字 var 来定义各种不同的类型 1var hello = &quot;你好&quot; 例如，定义一些熟悉的基本类型变量 12345678910111213//: #### Fundamental types//: Integervar hours = 24//: Doublevar PI = 3.14//: Boolvar swiftIsFun = true//: Stringvar hello = &quot;你好&quot; 除了基本类型变量之外，Swift 还有 Tuple ,多类型数据混合到一个数组 123456789101112//: Tuple - Pack many types of values togetherimport UIKitvar me = (&quot;name&quot;,&quot;jianxiong&quot;,[&quot;like&quot; : [&quot;code&quot;,&quot;code2&quot;,&quot;code3&quot;]],18)me.0 //&quot;name&quot;me.1 //&quot;jianxiong&quot;me.2 //[&quot;like&quot; : [&quot;code&quot;,&quot;code2&quot;,&quot;code3&quot;]]me.3 //18 定义好一个Tuple之后，就可以使用代码 me.0 me.1 me.2 这样的方式来访问Tuple中的变量了，同时也可以直接修改变量的值 12345// update Tuple valueme.3 = 22var hour = 24 hour = 12 常量如果我们定义的值不希望被修改定义常量的方法和变量类似，我们把关键字var，变成关键字let就可以了。例如： 12let minutes = 30let fireIsHot = true 一旦我们定义常量之后，就不能再修改常量的值了，否则，编译器会告诉我们发生了错误。例如，我们修改常量fireIsHot： 1fireIsHot = false 这时，我们就可以在Playground中直接看到一个编译错误。 1Cannot assign to value: &apos;firelsHot&apos; is a &apos;let&apos; constant 只要程序中的变量值不会被修改，就总应该使用let来定义它。这不仅可以防止变量被意外修改，编译器还可以针对常量做更多优化。 Type inference / annotation在前面的例子里，我们可以发现，无论是整数、浮点数、字符串还有Tuple，我们都没有明确的指定变量的类型， Swift编译器会根据我们为变量的赋值自动推导变量的类型，这个特性，在Swift里叫做Type Inference。 但有时，我们定义变量的时候，并不能确定变量的初始值，这个时候，我们就必须像下面这样明确告诉编译器我们需要的变量类型：var Name:Type。这种通过:Type指定变量类型的形式，在Swift中叫做Type annotation。例如： 12var x: Intvar s: String","categories":[],"tags":[]},{"title":"协程 阿里开源库 coobjc 初步分析","slug":"协程-阿里开源库-coobjc-初步分析","date":"2019-07-16T02:09:24.000Z","updated":"2019-07-16T02:26:48.297Z","comments":true,"path":"2019/07/16/协程-阿里开源库-coobjc-初步分析/","link":"","permalink":"https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/","excerpt":"","text":"简介协程是计算机程序的一类组件，推广了非抢先多任务的子程序，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程源自 Simula 和 Modula-2 语言，但也有其他语言支持。协程更适合于用来实现彼此熟悉的程序组件，如合作式多任务、异常处理、事件循环、迭代器、无限列表和管道。根据高德纳的说法, 马尔文·康威于1958年发明了术语 coroutine 并用于构建汇编程序。—— Wikipedia coobjc 解决的问题iOS 异步编程问题官网描述: 基于 Block 的异步编程回调是目前 iOS 使用最广泛的异步编程方式，iOS 系统提供的 GCD 库让异步开发变得很简单方便，但是基于这种编程方式的缺点也有很多，主要有以下几点： 容易进入”嵌套地狱”错误处理复杂和冗长容易忘记调用 completion handler条件执行变得很困难从互相独立的调用中组合返回结果变得极其困难在错误的线程中继续执行难以定位原因的多线程崩溃锁和信号量滥用带来的卡顿、卡死上述问题反应到线上应用本身就会出现大量的多线程崩溃 协程的优势官网描述: 简明概念少：只有很少的几个操作符，相比响应式几十个操作符，简直不能再简单了原理简单: 协程的实现原理很简单，整个协程库只有几千行代码易用使用简单：它的使用方式比 GCD 还要简单，接口很少改造方便：现有代码只需要进行很少的改动就可以协程化，同时我们针对系统库提供了大量协程化接口清晰同步写异步逻辑：同步顺序方式写代码是人类最容易接受的方式，这可以极大的减少出错的概率可读性高: 使用协程方式编写的代码比 block 嵌套写出来的代码可读性要高很多性能调度性能更快：协程本身不需要进行内核级线程的切换，调度性能快，即使创建上万个协程也毫无压力减少卡顿卡死: 协程的使用以帮助开发减少锁、信号量的滥用，通过封装会引起阻塞的 IO 等协程接口，可以从根源上减少卡顿、卡死，提升应用整体的性能 核心能力提供了类似C#和Javascript语言中的Async/Await编程方式支持，在协程中通过调用await方法即可同步得到异步方法的执行结果，非常适合IO、网络等异步耗时调用的同步顺序执行改造。提供了类似Kotlin中的Generator功能，用于懒计算生成序列化数据，非常适合多线程可中断的序列化数据生成和访问。提供了Actor Model的实现，基于Actor Model，开发者可以开发出更加线程安全的模块，避免由于直接函数调用引发的各种多线程崩溃问题。提供了元组的支持，通过元组Objective-C开发者可以享受到类似Python语言中多值返回的好处。 内置系统扩展库 提供了对NSArray、NSDictionary等容器库的协程化扩展，用于解决序列化和反序列化过程中的异步调用问题。 提供了对NSData、NSString、UIImage等数据对象的协程化扩展，用于解决读写IO过程中的异步调用问题。 提供了对NSURLConnection和NSURLSession的协程化扩展，用于解决网络异步请求过程中的异步调用问题。 提供了对NSKeyedArchieve、NSJSONSerialization等解析库的扩展，用于解决解析过程中的异步调用问题。 coobjc 设计 图片 最底层是协程内核，包含了栈切换的管理、协程调度器的实现、协程间通信channel的实现等。中间层是基于协程的操作符的包装，目前支持async/await、Generator、Actor等编程模型。最上层是对系统库的协程化扩展，目前基本上覆盖了Foundation和UIKit的所有IO和耗时方法。 核心实现原理协程的核心思想是控制调用栈的主动让出和恢复。一般的协程实现都会提供两个重要的操作： Yield：是让出cpu的意思，它会中断当前的执行，回到上一次Resume的地方。Resume：继续协程的运行。执行Resume后，回到上一次协程Yield的地方。 我们基于线程的代码执行时候，是没法做出暂停操作的，我们现在要做的事情就是要代码执行能够暂停，还能够再恢复。 基本上代码执行都是一种基于调用栈的模型，所以如果我们能把当前调用栈上的状态都保存下来，然后再能从缓存中恢复，那我们就能够实现yield和 resume。实现这样操作有几种方法呢？ 第一种：利用glibc 的 ucontext组件(云风的库)。第二种：使用汇编代码来切换上下文(实现c协程)，原理同ucontext。第三种：利用C语言语法switch-case的奇淫技巧来实现（Protothreads)。第四种：利用了 C 语言的 setjmp 和 longjmp。第五种：利用编译器支持语法糖。 上述第三种和第四种只是能过做到跳转，但是没法保存调用栈上的状态，看起来基本上不能算是实现了协程，只能算做做demo，第五种除非官方支持，否则自行改写编译器通用性很差。而第一种方案的 ucontext 在iOS上是废弃了的，不能使用。那么我们使用的是第二种方案，自己用汇编模拟一下 ucontext。模拟ucontext的核心是通过getContext和setContext实现保存和恢复调用栈。需要熟悉不同CPU架构下的调用约定(Calling Convention). 汇编实现就是要针对不同cpu实现一套，我们目前实现了 armv7、arm64、i386、x86_64，支持iPhone真机和模拟器。 官方例子整体结构如下 图片 cokit cokit库为Foundation和UIKit系统库提供了一个协程封装，它依赖于coobjc库，为IO，网络等耗时的方法提供协同处理的封装。 coobjc coobjc的Objective-C版实现的源代码 *coswift * coswift的Swift版源代码 Examples coobjcBaseExample是OC版本的Demo coSwiftExample是OC版本的Demo 项目运行直接看看coobjcBaseExample的效果 图片 这个界面可以看到一个简单的列表页。对应到代码中的KMDiscoverListViewControllerViewDidLoad中有如下代码 1234567- (void)viewDidLoad&#123; [super viewDidLoad]; [self setupTableView]; [self requestMovies];&#125; 从方法名可以得知，requestMovies实现了网络拉取电影列表的功能。看 requestMovies 中的实现 12345678910111213141516- (void)requestMovies&#123; co_launch(^&#123; NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;]; [self.refreshControl endRefreshing]; if (dataArray != nil) &#123; [self processData:dataArray]; &#125; else &#123; [self.networkLoadingViewController showErrorView]; &#125; &#125;);&#125; 先抛开co_launch不管，可以发现 1NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;]; 实现了网络请求，获取数据，getDiscoverList实现代码如下 1234567- (NSArray*)getDiscoverList:(NSString *)pageLimit;&#123; NSString *url = [NSString stringWithFormat:@&quot;%@&amp;page=%@&quot;, [self prepareUrl], pageLimit]; id json = [[DataService sharedInstance] requestJSONWithURL:url]; NSDictionary* infosDictionary = [self dictionaryFromResponseObject:json jsonPatternFile:@&quot;KMDiscoverSourceJsonPattern.json&quot;]; return [self processResponseObject:infosDictionary];&#125; 根据代码可以发现 1id json = [[DataService sharedInstance] requestJSONWithURL:url]; 这一段实现了网络请求，然后继续去进入requestJSONWithURL去看 1234- (id)requestJSONWithURL:(NSString*)url CO_ASYNC&#123; SURE_ASYNC return await([self.jsonActor sendMessage:url]);&#125; 这个时候发现 SURE_ASYNC 和 awiat 类似于ES7中的async 和 await，ES7中async-await是promise和generator的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性，看起来这块起到了类似的作用。再来仔细了解下协程。 协程入门上面的核心实现原理中有提到，实现核心的yield和resume有五种方法，其中说到第三、四种只能做到过跳转，没办法保存调用栈,无法真正的实现协程。第五种除非官方支持。第一种ucontext在iOS是废弃了的。那么第二种方案，自己用汇编模拟ucontext。 首先，ucontext 是啥？ ucontext 机制是GUN C库提供的一组用于创建、保存、切换用户态执行context的API。主要包括以下四个函数 1234void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);int swapcontext(ucontext_t *oucp, ucontext_t *ucp);int getcontext(ucontext_t *ucp);int setcontext(const ucontext_t *ucp); 详细参见[我所理解的ucontext族函数]https://www.jianshu.com/p/dfd7ac1402f0[构建C协程之ucontext篇]https://blog.csdn.net/gettogetto/article/details/53306897 来看一段简单的代码 123456789101112131415161718192021#include &lt;stdio.h&gt;//由于在Mac OS X 10.6.6 ucontext被弃用的关系 ，需要使用sys/ucontext.h#include &lt;sys/ucontext.h&gt;#include &lt;unistd.h&gt;int main(int argc, char const *argv[])&#123; // ----&gt; ucontext ucontext_t context; getcontext(&amp;context); puts(&quot;Hello world&quot;); sleep(1); setcontext(&amp;context);// ----&gt; goto // loop: puts(&quot;%s\\n&quot;,&quot;Hello world&quot;);// sleep(1);// goto loop; return 0;&#125; 保存上述代码到 example.c，执行编译命令： 1gcc example.c -o example 图片 可以看到这里会不断执行，通过setcontext和getcontext实现切换。更详细参见我所理解的ucontext族函数构建C协程之ucontext篇上面核心实现原理中讲到了第二种：使用汇编代码来切换上下文(实现c协程)，原理同ucontext。我们在coobjc中的库中发现了唯一一个汇编文件coroutine_context.s 图片 在汇编文件中发现主要提供了三个方法 _coroutine_getcontext _coroutine_begin _coroutine_setcontext 同样在 coroutine_context.h中暴露了 123456extern int coroutine_getcontext (coroutine_ucontext_t *__ucp);extern int coroutine_setcontext (coroutine_ucontext_t *__ucp);extern int coroutine_begin (coroutine_ucontext_t *__ucp);extern void coroutine_makecontext (coroutine_ucontext_t *__ucp, IMP func, void *arg, void *stackTop); 其中coroutine_makecontext在coroutine_context.m中实现回到例子中co_launch 来自 coobjc.h ,来关注一下coobjc.h 里的内联函数 co_launch 创建一个协程，然后在当前线程中异步恢复它 co_launch_now 创建一个协程，然后在当前线程立即恢复它 co_launch_withStackSize 创建一个协程，然后在当前线程中异步恢复它，与co_launch不同 ，他可以设定堆栈大小 默认为65536 最大限制为1M co_launch_onqueue 创建一个协程，并在给定的线程中异步恢复它 co_sequence 创建一个生成器 co_sequence_onqueue 在指定的线程中创建一个生成器 co_actor 创建一个容器 co_actor_onqueue 在指定线程中创建一个容器 await 用await得到异步执行的结果，等待异步方法的执行 batch_await 批量的await 目前没找到哪里用 co_delay 使当前协程sleep 多少秒 co_isActive 判断一个协程是否有效 co_isCancelled 检查当前协程是否取消 其他的一些宏定义 CO_ASYNC 给方法一个标记，表示方法是可被暂停的，类似于JS中 async SURE_ASYNC 断言 yield 暂停 在看看用到的co_launch 文档描述在当前线程中创建协程 123456789101112- (void)requestMovies&#123; //创建协程 co_launch(^&#123; //进行网络加载，但并没有在这里进行await NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;]; [self.refreshControl endRefreshing]; if (dataArray != nil) &#123; [self processData:dataArray]; &#125; else12345 &#123; [self.networkLoadingViewController showErrorView]; &#125; &#125;);&#125; 接着往下看 12345//在这里写了CO_ASYNC 表示该方法是可以被暂停的 同时在方法内await等待异步的结果- (id)requestJSONWithURL:(NSString*)url CO_ASYNC&#123; SURE_ASYNC return await([self.jsonActor sendMessage:url]);&#125; 下面看看 self.jsonActor 及 sendMessage 12345/*jsonActor 是一个COActor 的对象，文档中描述_ Actor 的概念来自于 Erlang ，在 AKKA 中，可以认为一个 Actor 就是一个容器，用以存储状态、行为、Mailbox 以及子 Actor 与 Supervisor 策略。Actor 之间并不直接通信，而是通过 Mail 来互通有无。_*/@property (nonatomic, strong) COActor *jsonActor; 此时看到 DataService.m中有init 注册了接受消息的实现 123456789101112131415161718192021_jsonActor = co_actor_onqueue(_jsonQueue, ^(COActorChan *channel) &#123; NSData *data = nil; id json = nil; COActorCompletable *completable = nil; for (COActorMessage *message in channel) &#123; NSString *url = [message stringType]; json = nil; if (url.length &gt; 0) &#123; //这里接受到消息之后将消息发送到 networkActor completable = [self.networkActor sendMessage:url]; data = await(completable); if (data) &#123; json = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil]; &#125; message.complete(json); &#125; else&#123; message.complete(nil); &#125; &#125;&#125;); 收到消息后将json的消息回复到上层。展示数据 参考阅读[阿里云栖社区对coobjc介绍]https://www.jianshu.com/p/cd7f6ef5a8fd[我所理解的ucontext族函数]https://www.jianshu.com/p/dfd7ac1402f0[构建C协程之ucontext篇]https://blog.csdn.net/gettogetto/article/details/53306897[理解 JavaScript 的 async/await]https://segmentfault.com/a/1190000007535316?utm_source=tag-newest[GC 7.1 Mac OS X 10.6.6: ucontext routines are deprecated]https://www.hpl.hp.com/hosted/linux/mail-archives/gc/2011-February/004354.html[PSA: avoiding the “ucontext routines are deprecated” error on Mac OS X Snow Leopard]http://duriansoftware.com/joe/PSA%3a-avoiding-the-%22ucontext-routines-are-deprecated%22-error-on-Mac-OS-X-Snow-Leopard.html","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/jianxiongc/tags/iOS/"}]}]}