<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jianxiong</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://github.com/jianxiongc/"/>
  <updated>2019-11-12T15:01:40.740Z</updated>
  <id>https://github.com/jianxiongc/</id>
  
  <author>
    <name>Jianxiong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>应用层协议 - 网络应用与应用系统设计方法</title>
    <link href="https://github.com/jianxiongc/2019/11/11/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE%20-%20%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E4%B8%8E%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/jianxiongc/2019/11/11/应用层协议 - 网络应用与应用系统设计方法/</id>
    <published>2019-11-11T14:14:19.000Z</published>
    <updated>2019-11-12T15:01:40.740Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-S工作模式的特点"><a href="#C-S工作模式的特点" class="headerlink" title="C/S工作模式的特点"></a>C/S工作模式的特点</h3><p>服务器程序在固定的IP地址和熟知的端口号上一直处于打开状态，随时准备接收客户端的服务请求；</p><p>客户端程序可以根据用户需要，在访问服务器时打开；</p><p>客户端之间不能够直接通信；</p><p>当同时向服务器发出服务请求的客户数量比较多时，一台服务器不能满足多个客户请求的需要。人们经常使用由多台服务器组成的服务器集群（server farm）构成一个虚拟服务器；</p><p>如果在客户数量比较少，或者客户服务请求不频繁时，也可以将多种服务器应用程序安装在一台计算机中。一台服务器就可以提供多种网络服务功能。</p><h3 id="P2P工作模式的特点"><a href="#P2P工作模式的特点" class="headerlink" title="P2P工作模式的特点"></a>P2P工作模式的特点</h3><p>P2P应用程序体系结构分为：</p><ul><li><p>纯P2P模式</p></li><li><p>P2P与C/S混合模式</p></li></ul><p><strong>纯P2P模式的应用程序体系结构特点</strong></p><p>所有的结点地位是平等的，都可以以对等的方式直接通信；</p><p>纯P2P应用程序体系结构的典型例子如Gnutella。Gnutella是一个P2P文件共享应用程序；</p><p>P2P工作模式的最大优点是它的信息共享的灵活性与系统的可扩展性。在一个P2P文件共享应用程序中，可以有数以百万计的对等结点加入，每个结点即可以作为一个客户端，也可以起到服务器的作用。</p><p><strong>P2P与C/S的混合模式</strong></p><p>随着P2P规模的扩大，很多P2P应用实际上采用P2P与C/S的混合模式；</p><p>典型的软件是Napster；</p><p>在Napster系统中，共享的MP3文件是直接在两个对等结点之间直接传输，但是提出共享请求的结点需要通过一个查询服务器找到当前打开的对等结点的地址；</p><p>目前大量使用的P2P即时通信程序也采用P2P与C/S的混合模式。</p><h3 id="网络应用与应用层协议"><a href="#网络应用与应用层协议" class="headerlink" title="网络应用与应用层协议"></a>网络应用与应用层协议</h3><p>—应用层协议规定应用程序进程之间通信所遵循的通信规则。</p><p>应用层协议的基本内容：</p><p>交换报文的类型，如请求报文与应答报文；</p><p>各种报文格式与包含的字段类型；</p><p>对每个字段意义的描述；</p><p>进程在什么时间、如何发送报文，以及如何响应。</p><p><strong>应用层协议的类型</strong></p><p>标准的网络应用层协议</p><p>E-mail、FTP、TELNET、Web等</p><p>协议以RFC文档的方式公布</p><p>遵守RFC文档所制定的应用层协议开发的应用系统之间可以实现互联和互操作；</p><p>专用的应用层协议</p><p>目前P2P文件共享的应用层协议一般都属于专用协议。</p><h3 id="网络应用对低层提供服务的要求"><a href="#网络应用对低层提供服务的要求" class="headerlink" title="网络应用对低层提供服务的要求"></a>网络应用对低层提供服务的要求</h3><p>应用程序的开发者将根据网络应用的实际需求来决定传输层是选择TCP协议还是UDP协议，以及主要的技术参数；</p><p>传输层协议是在主机的操作系统控制下，为应用程序提供确定的服务。</p><p>传输层QoS表现在：可靠性、带宽与延时等方面。</p><p>E-mail、FTP、TELNET、Web、IM、IPTV、VoIP，以及金融应用系统、电子政务、电子商务、远程医疗、远程数据存储等应用对数据传输的可靠性、带宽和延时要求不同；</p><p>金融应用系统、电子政务、电子商务、远程医疗、远程数据存储等应用对数据传输的可靠性要求高；</p><p>IPTV、VoIP等对带宽和延时要求比较高，而对数据传输的可靠性要求不是很严格，一个分组的丢失一般不会影响语音与图像的收听或观看的效果。</p><h3 id="网络应用系统对传输层协议的选择"><a href="#网络应用系统对传输层协议的选择" class="headerlink" title="网络应用系统对传输层协议的选择"></a>网络应用系统对传输层协议的选择</h3><p><strong>TCP协议可以提供的服务：</strong></p><p>支持可靠的面向连接服务</p><p>支持字节流传输服务</p><p>支持全双工服务</p><p><strong>选择TCP协议时需要注意的问题</strong></p><p>TCP协议的拥塞控制机制是通过限制每个TCP连接来达到公平使用网络带宽的方法；</p><p>对于有最低带宽限制的实时视频应用来说，抑制传输速率会造成严重的影响；</p><p>实时视频应用应该选择UDP协议，而不是TCP协议。</p><p><strong>UDP协议能够提供的服务</strong></p><p>UDP是一种无连接、不可靠的传输层协议；</p><p>UDP协议没有提供拥塞控制机制；</p><p>UDP协议不提供最小延时保证。</p><p><strong>应用层协议与传输层协议的关系</strong></p><table><thead><tr><th>网络应用类型</th><th>应用层协议</th><th>传输层协议</th></tr></thead><tbody><tr><td>E-mail</td><td>STMP</td><td>TCP</td></tr><tr><td>TELNET</td><td>TELNET</td><td>TCP</td></tr><tr><td>Web</td><td>HTTP</td><td>TCP</td></tr><tr><td>FTP</td><td>FTP</td><td>TCP</td></tr><tr><td>DNS</td><td>DNS</td><td>UDP 或 TCP</td></tr><tr><td>流媒体</td><td>Real Network</td><td>UDP 或 TCP</td></tr><tr><td>VoIP</td><td>Net2phone</td><td>UDP</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;C-S工作模式的特点&quot;&gt;&lt;a href=&quot;#C-S工作模式的特点&quot; class=&quot;headerlink&quot; title=&quot;C/S工作模式的特点&quot;&gt;&lt;/a&gt;C/S工作模式的特点&lt;/h3&gt;&lt;p&gt;服务器程序在固定的IP地址和熟知的端口号上一直处于打开状态，随时准备接收客户
      
    
    </summary>
    
      <category term="计算机科学与技术" scheme="https://github.com/jianxiongc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="应用层协议" scheme="https://github.com/jianxiongc/tags/%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>互联网应用技术 - 互联网应用发展与应用层协议</title>
    <link href="https://github.com/jianxiongc/2019/11/11/%E4%BA%92%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF%20-%20%E4%BA%92%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E5%8F%91%E5%B1%95%E4%B8%8E%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
    <id>https://github.com/jianxiongc/2019/11/11/互联网应用技术 - 互联网应用发展与应用层协议/</id>
    <published>2019-11-11T14:14:19.000Z</published>
    <updated>2019-11-11T15:14:41.258Z</updated>
    
    <content type="html"><![CDATA[<h3 id="互联网应用技术发展的3个阶段"><a href="#互联网应用技术发展的3个阶段" class="headerlink" title="互联网应用技术发展的3个阶段"></a>互联网应用技术发展的3个阶段</h3><p><strong>基本的网络服务</strong></p><ul><li>TELNET</li><li>E-Mail</li><li>FTP</li><li>BBS</li><li>Usernet</li></ul><p><strong>基于Web的网络服务</strong></p><ul><li>Web</li><li>电子商务</li><li>电子政务</li><li>远程教育</li><li>远程医疗</li></ul><p><strong>新的网络服务</strong></p><ul><li>搜索引擎</li><li>网络电视</li><li>网络电话</li><li>网络视频</li><li>博客</li><li>播客</li><li>即时通讯</li><li>网络游戏</li><li>网络出版</li><li>网络广告</li><li>网络存储</li><li>网络计算</li></ul><h3 id="互联网技术的两种工作模式"><a href="#互联网技术的两种工作模式" class="headerlink" title="互联网技术的两种工作模式"></a>互联网技术的两种工作模式</h3><p>C/S 模式 和 P2P 模式</p><p><strong>C/S 的的特点</strong></p><p>在客户/服务器模式中, 客户端与服务器在网络服务中的地位不平等， 服务器在网络服务中处于中心地位。<br>采用 C/S模式的主要原因是网络资源分布的不均匀性<br>网络中计算机系统的类型、硬件结构、功能都存在着很大的差异。<br>很多大型应用软件都是安装在一台专用的服务器中，用户需要通过互联网去访问服务器，成为合法用户之后才能使用网络的软件资源。<br>从信息资源的角度来看，某一类型的数据、文本、图像、视频或音乐资源存放在一台或者几台大型服务器中，合法用户可以通过互联网来访问这些资源。</p><p><strong>P2P - 对等网络的基本概念</strong></p><p>P2P通信模式是指P2P网络中对等节点之间的通信能力。<br>P2P网络是指在互联网中对等节点组成的一种动态的逻辑网络。<br>P2P实现技术是指为实现对等节点之间直接通信的功能和特定的应用所需设计的协议、软件等</p><p><strong>C/S 与 P2P 模式比较</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15730415771891/15731363484652.jpg" alt="-w483" title>                </div>                <div class="image-caption">-w483</div>            </figure><h3 id="互联网基本网络应用与应用层协议"><a href="#互联网基本网络应用与应用层协议" class="headerlink" title="互联网基本网络应用与应用层协议"></a>互联网基本网络应用与应用层协议</h3><p><strong>远程登录服务与 TELNET 协议</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15730415771891/15731364503686.jpg" alt="-w661" title>                </div>                <div class="image-caption">-w661</div>            </figure><p><strong>电子邮件服务与 SMTP 协议</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15730415771891/15731364869394.jpg" alt="-w652" title>                </div>                <div class="image-caption">-w652</div>            </figure><p><strong>文件传输服务与 FTP、TFTP 协议</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15730415771891/15731365189098.jpg" alt="-w577" title>                </div>                <div class="image-caption">-w577</div>            </figure><p><strong>网络新闻与 NNTP 协议</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15730415771891/15731365421097.jpg" alt="-w624" title>                </div>                <div class="image-caption">-w624</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;互联网应用技术发展的3个阶段&quot;&gt;&lt;a href=&quot;#互联网应用技术发展的3个阶段&quot; class=&quot;headerlink&quot; title=&quot;互联网应用技术发展的3个阶段&quot;&gt;&lt;/a&gt;互联网应用技术发展的3个阶段&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;基本的网络服务&lt;/stron
      
    
    </summary>
    
      <category term="计算机科学与技术" scheme="https://github.com/jianxiongc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="互联网应用技术" scheme="https://github.com/jianxiongc/tags/%E4%BA%92%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>网络技术发展 - 接入网技术</title>
    <link href="https://github.com/jianxiongc/2019/11/07/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%20-%20%E6%8E%A5%E5%85%A5%E7%BD%91%E6%8A%80%E6%9C%AF/"/>
    <id>https://github.com/jianxiongc/2019/11/07/网络技术发展 - 接入网技术/</id>
    <published>2019-11-07T14:04:19.000Z</published>
    <updated>2019-11-07T14:04:54.262Z</updated>
    
    <content type="html"><![CDATA[<h3 id="接入技术发展的背景"><a href="#接入技术发展的背景" class="headerlink" title="接入技术发展的背景"></a>接入技术发展的背景</h3><p>接入技术解决的是最终用户接入宽带城域网的问题</p><p>由于互联网的应用越来越广泛，社会对接入技术的需求越来越强烈，对于信息产业来说，接入技术有广阔的市场前景，因此它已成为当前网络技术研究、应用与产业发展的热点问题</p><h4 id="接入服务的界定"><a href="#接入服务的界定" class="headerlink" title="接入服务的界定"></a>接入服务的界定</h4><p>互联网接入服务是指利用接入服务器和相应的软硬件资源建立业务结点，并利用公用电信基础设施将业务结点与互联网骨干网相连接，以便为各类用户提供接入互联网的服务</p><p>用户可以利用公用电话网或其它接入手段连接到业务结点，并通过该结点接入互联网</p><p>接入技术的发展促进了计算机网络与电信通信网、广播电视网的三网融合</p><p>为了支持各种类型信息的传输，满足电子政务、电子商务、远程教育、远程医疗、分布式计算、数字图书馆、网上电话、视频会议与视频点播等不同应用QoS的需求，人们将发展的基点放在宽带骨干网与宽带接入的建设上</p><h4 id="接入技术的基本类型"><a href="#接入技术的基本类型" class="headerlink" title="接入技术的基本类型"></a>接入技术的基本类型</h4><p><strong>接入方式分为:</strong></p><ul><li><p>家庭接入</p></li><li><p>校园接入</p></li><li><p>机关</p></li><li><p>企业接入</p></li></ul><p><strong>接入技术分为:</strong></p><ul><li><p>有线接入</p></li><li><p>无线接入</p></li></ul><p><strong>从实现技术的角度宽带接入技术主要分为</strong></p><ul><li><p>数字用户线xDSL技术</p></li><li><p>光纤同轴电缆混合网HFC技术 （广播电视）</p></li><li><p>光纤接入技术</p></li><li><p>无线接入技术</p></li><li><p>局域网接入技术</p></li></ul><h4 id="数字用户线xDSL接入技术"><a href="#数字用户线xDSL接入技术" class="headerlink" title="数字用户线xDSL接入技术"></a>数字用户线xDSL接入技术</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15729581985812/15729586574322.jpg" alt="-w589" title>                </div>                <div class="image-caption">-w589</div>            </figure><p><strong>ADSL的主要特点</strong></p><p>可以在现有的用户电话线上以重叠和不干扰传统模拟电话业务，同时提供互联网在线访问、远程办公、视频点播等高速数字业务；</p><p>用户不需要专门为获得ADSL服务而重新铺设电缆；</p><p>提供的非对称带宽特性，在5公里的范围内，上行速率为16～640kbps，下行速率为1.5～9.0Mbps。用户可以根据需要选择上行和下行速率；</p><p>ADSL调制解调器不但具有调制解调的作用，同时兼有网桥和路由器的功能；</p><p>推广ADSL技术时用户端的投资小，推广容易。</p><p><strong>光纤同轴电缆混合HFC网</strong></p><p>HFC是一个双向传输系统；</p><p>HFC用户可以按照传统方式接收电视节目，也可以实现视频点播、IP电话、发送E-Mail、浏览Web的双向服务功能；</p><p>HFC采用非对称的传输速率，上行速率为10Mbps，下行速率为10～40Mbps；</p><p>我国的有线电视网的覆盖面很广，因此HFC已成为一种极具竞争力的宽带接入技术。</p><p><strong>光纤接入技术</strong></p><p>光纤到路边（FTTC）</p><p>光纤到小区（FTTZ）</p><p>光纤到大楼（FTTB）</p><p>光纤到办公室（FTTO）</p><p>光纤到户（FTTH）</p><p><strong>宽带无线接入技术与802.16标准</strong></p><p>IEEE802.16标准全称是“固定带宽无线访问系统空间接口”，也称为无线城域网（WMAN）或无线本地环路（wireless local loop）标准；</p><p>IEEE802.16标准体系的主要目标是制定2～66MHz频段的无线接入系统的物理层与介质访问控制子层规范；</p><p>致力于IEEE802.16标准WMAN推广应用的论坛组织是WiMAX。</p><p><strong>总结</strong></p><p>从网络技术发展的过程看，最先出现的是广域网，然后是局域网。城域网研究最初是融于局域网研究范围中。在互联网大规模接入需求的推动下，接入技术的发展导致宽带城域网的概念、技术、结构的演变与发展。</p><p>广域网、城域网与局域网区别在于：设计目标不同，覆盖地理范围不同，核心技术与标准不同，组建与管理方式不同。</p><p>如果说广域网的作用是扩大信息资源共享的范围，局域网的作用是增加信息资源共享的深度，则城域网的作用是方便大量用户计算机接入互联网。</p><p>互联网的应用促进计算机网络、电信网络与广播电视网络在技术上的融合；</p><p>光以太网技术的发展将导致广域网、城域网与局域网在技术上的融合。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;接入技术发展的背景&quot;&gt;&lt;a href=&quot;#接入技术发展的背景&quot; class=&quot;headerlink&quot; title=&quot;接入技术发展的背景&quot;&gt;&lt;/a&gt;接入技术发展的背景&lt;/h3&gt;&lt;p&gt;接入技术解决的是最终用户接入宽带城域网的问题&lt;/p&gt;
&lt;p&gt;由于互联网的应用越来越广
      
    
    </summary>
    
      <category term="计算机科学与技术" scheme="https://github.com/jianxiongc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="网络技术发展" scheme="https://github.com/jianxiongc/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>网络技术发展 - 局域网和城域网技术特征</title>
    <link href="https://github.com/jianxiongc/2019/11/04/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%20-%20%E5%B1%80%E5%9F%9F%E7%BD%91%E5%92%8C%E5%9F%8E%E5%9F%9F%E7%BD%91%E6%8A%80%E6%9C%AF%E7%89%B9%E5%BE%81/"/>
    <id>https://github.com/jianxiongc/2019/11/04/网络技术发展 - 局域网和城域网技术特征/</id>
    <published>2019-11-04T14:10:10.000Z</published>
    <updated>2019-11-04T14:10:58.529Z</updated>
    
    <content type="html"><![CDATA[<h2 id="局域网技术演变与发展"><a href="#局域网技术演变与发展" class="headerlink" title="局域网技术演变与发展"></a>局域网技术演变与发展</h2><p>局域网技术跟广域网的差别在于，局域网是一个小范围的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15728754261057/15728755468098.jpg" alt="-w666" title>                </div>                <div class="image-caption">-w666</div>            </figure><p>不同的局域网按照时间排列的顺序</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15728754261057/15728756390985.jpg" alt="-w626" title>                </div>                <div class="image-caption">-w626</div>            </figure><h3 id="高速以太网技术的研究与发展"><a href="#高速以太网技术的研究与发展" class="headerlink" title="高速以太网技术的研究与发展"></a>高速以太网技术的研究与发展</h3><p>局域网发展的基本思路</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15728754261057/15728756587969.jpg" alt="-w515" title>                </div>                <div class="image-caption">-w515</div>            </figure><h3 id="无线局域网技术研究与发展"><a href="#无线局域网技术研究与发展" class="headerlink" title="无线局域网技术研究与发展"></a>无线局域网技术研究与发展</h3><p><strong>无线局域网的应用领域</strong></p><ul><li><p>作为传统局域网的扩充</p></li><li><p>用于建筑物之间的互连</p></li><li><p>用于移动结点的漫游访问</p></li><li><p>用于构建特殊的移动网络</p></li></ul><p><strong>无线局域网的分类</strong></p><ul><li>红外局域网</li><li>扩频局域网</li><li>窄带微博局域网</li></ul><p><strong>红外无线局域网分为</strong></p><ul><li>定向光束红外传输</li><li>全方位红外传输</li><li>漫反射红外传输</li></ul><p><strong>扩频局域网</strong></p><p>调频扩频 (FHSS)<br>直接序列扩频 (DSSS)</p><h3 id="蓝牙技术的研究与发展"><a href="#蓝牙技术的研究与发展" class="headerlink" title="蓝牙技术的研究与发展"></a>蓝牙技术的研究与发展</h3><p><strong>蓝牙技术研究的背景</strong></p><p>1994年，Ericsson公司与IBM、Intel、Nokia和Toshiba等4家公司发起，开发一个用于将计算机与通信设备、附加部件和外部设备，通过短距离的、低功耗的、低成本的无线信道连接的无线标准。这项技术被命名为蓝牙（Bluetooth）技术；</p><p>特别兴趣组SIG由Ericsson、Intel、IBM、Nokia和Toshiba等公司成立；</p><p>SIG的主要任务是致力于发展蓝牙规范；</p><p>1999年7月，SIG发布蓝牙规范1.0版，除了详细规定通信信道与通信过程，还规定13种网络应用所需的专门协议集。</p><p>无线个人区域网与IEEE802.15.4标准</p><p>IEEE802.15.4标准，主要考虑低速无线个人区域网络（LR-WPAN）应用问题；</p><p>2003年，IEEE批准低速无线个人区域网LR-WPAN标准—IEEE802.15.4，为近距离范围内不同设备之间低速互连提供统一标准。</p><p>IEEE802.15.4标准的主要特点</p><p>在不同的载波频率下实现20kbps、40kbps和250kbps三种不同的传输速率；</p><p>支持星形、点-点等2种网络拓扑结构；</p><p>使用16位和64位的2种地址格式，其中64位地址是全球惟一的扩展地址；</p><p>支持冲突避免（CA）的载波侦听多路访问技术；</p><p>支持确认机制，保证传输可靠性。</p><h3 id="ZigBee无线网络技术及应用"><a href="#ZigBee无线网络技术及应用" class="headerlink" title="ZigBee无线网络技术及应用"></a>ZigBee无线网络技术及应用</h3><p>ZigBee的基础是IEEE802.15.4标准，早期的名字是HomeRF或FireFly；</p><p>ZigBee联盟于2001年8月成立；2002年摩托罗拉公司、飞利浦公司、三菱公司与Invensys公司宣布加ZigBee联盟，研究下一代无线网络通信标准；</p><p>ZigBee适应于数据采集与控制的点多、数据传输量不大、覆盖面广、造价低的应用领域；</p><p>基于ZigBee的无线传感器网络已在家庭网络、安全监控、汽车自动化、消费电器、儿童玩具、医用设备控制、工业控制、无线定位等领域广泛应用。</p><h2 id="宽带城域网技术演变与发展"><a href="#宽带城域网技术演变与发展" class="headerlink" title="宽带城域网技术演变与发展"></a>宽带城域网技术演变与发展</h2><p><strong>城域网概念的发展与演变</strong></p><p>IEEE802最初的表述：城域网是以光纤为传输介质，能够提供45Mbps到150Mbps高传输速率，支持数据、语音与视频综合业务的数据传输，可以覆盖跨度在50公里到100公里的城市范围，实现高速宽带传输的数据通信网络</p><p>典型的产品是FDDI</p><p><strong>宽带城域网的定义</strong></p><ul><li><p>宽带城域网是以宽带光传输网为开放平台，以TCP/IP协议为基础，通过各种网络互联设备，实现语音、数据、图像、多媒体视频、IP电话、IP电视、IP接入和各种增值业务；</p></li><li><p>与广域计算机网络、广播电视网、电话交换网互联互通的本地综合业务网络，以满足语音、数据、图像、多媒体应用的需求</p></li><li><p>能够提供高传输速率和保证QoS的网络系统</p></li><li><p>人们将传统意义上的城域网扩展为宽带城域网</p></li></ul><p><strong>宽带城域网的应用和业务</strong></p><ul><li><p>大规模互联网接入的需求与交互式应用</p></li><li><p>远程办公、视频会议、网上教育等新的办公与生活方式</p></li><li><p>网络电视、视频点播、网络电话，以及由此引起的新的服务</p></li><li><p>家庭网络的应用</p></li></ul><p><strong>宽带城域网技术的主要特征</strong></p><ul><li><p>宽带城域网是基于计算机网络技术与IP协议，以电信网的可扩展性、可管理性为基础，在城市范围内汇聚宽带和窄带用户的接入，以满足政府、企业、学校等集团用户和个人用户对互联网和宽带多媒体服务需求为目标，而组建的综合宽带网络</p></li><li><p>从传输技术角度来看，宽带城域网应在计算机网络、公共电话交换网、移动通信网和有线电视网的基础上，为语音、数字、视频提供一个互连互通的通信平台</p></li><li><p>城域网与广域网在设计上的出发点不同。广域网要求重点保证高数据传输容量，而城域网则要求重点保证高数据交换容量</p></li><li><p>宽带城域网是传统的计算机网络、电信网络与有线电视网技术的融合，也是传统的电信服务、有线电视服务与现代的互联网服务的融合</p></li></ul><p><strong>总结：以光传输网络为基础，以IP协议为核心，融合各种网络，支持多种业务。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;局域网技术演变与发展&quot;&gt;&lt;a href=&quot;#局域网技术演变与发展&quot; class=&quot;headerlink&quot; title=&quot;局域网技术演变与发展&quot;&gt;&lt;/a&gt;局域网技术演变与发展&lt;/h2&gt;&lt;p&gt;局域网技术跟广域网的差别在于，局域网是一个小范围的。&lt;/p&gt;
&lt;figure
      
    
    </summary>
    
      <category term="计算机科学与技术" scheme="https://github.com/jianxiongc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="网络技术发展" scheme="https://github.com/jianxiongc/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>网络技术发展 - 宽带城域网结构</title>
    <link href="https://github.com/jianxiongc/2019/11/04/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%20-%20%E5%AE%BD%E5%B8%A6%E5%9F%8E%E5%9F%9F%E7%BD%91%E7%BB%93%E6%9E%84/"/>
    <id>https://github.com/jianxiongc/2019/11/04/网络技术发展 - 宽带城域网结构/</id>
    <published>2019-11-04T13:51:10.000Z</published>
    <updated>2019-11-05T14:03:22.700Z</updated>
    
    <content type="html"><![CDATA[<h3 id="宽带城域网的结构与层次划分"><a href="#宽带城域网的结构与层次划分" class="headerlink" title="宽带城域网的结构与层次划分"></a>宽带城域网的结构与层次划分</h3><p>分为三层</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/blog/img/15729574429052/15729575757490.jpg" alt="-w663" title>                </div>                <div class="image-caption">-w663</div>            </figure><p>典型的宽带城域网的网络结构</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/blog/img/15729574429052/15729575953071.jpg" alt="-w653" title>                </div>                <div class="image-caption">-w653</div>            </figure><p><strong>核心交换层的基本功能</strong></p><ul><li><p>将多个汇聚层连接起来，为汇聚层提供高速分组转发，为整个城域网提供一个高速、安全与具有服务质量保障能力的数据传输环境。</p></li><li><p>实现与地区或国家主干网络的互联，提供城市的宽带IP数据出口。</p></li><li><p>提供宽带城域网用户访问互联网所需要的路由服务。</p></li><li><p>核心交换层结构设计重点考虑的是它的可靠性、可扩展性与开放性。</p></li></ul><p><strong>汇聚层的基本功能</strong></p><ul><li><p>汇聚接入层的用户流量，实现IP分组的汇聚、转发与交换</p></li><li><p>根据接入层的用户流量，进行本地路由、过滤、流量均衡、服务质量优先级管理，以及安全控制、IP地址转换、流量整形等处理</p></li></ul><p><strong>接入层的基本功能</strong></p><p>接入层解决的是“最后一公里”问题</p><p>它通过各种接入技术，连接最终用户，为它所覆盖范围内<br>的用户提供访问互联网，以及其他的信息服务</p><p><strong>在设计宽带城域网技术时需要注意以下几个问题</strong></p><p>宽带城域网的核心层、汇聚层与接入层的三个层次是一个全集</p><p>在实际的应用中，可以根据某个城市的覆盖范围、网络规模、用户数量与承载的业务来确定是否使用它的子集</p><p>城域网设计的一个重要出发点是：在降低网络造价的前提下，能够满足当前的数据交换量、接入的用户数与业务类型的要求，并具有可扩展的能力。</p><p><strong>组建的宽带城域网一定是可运营的</strong></p><p>宽带城域网是一个出售新的电信服务的系统，它必须能够保证系统提供7×24的服务，并且要保证服务质量</p><p>宽带城域网的核心链路与关键设备一定是电信级的</p><p><strong>组建的宽带城域网一定是可管理的</strong></p><p>作为一个实际运营的宽带城域网，它不同于服务于一个实验室、办公室的局域网，宽带城域网需要有很强的网络管理能力</p><p>这种能力表现在：电信级的接入管理、业务管理、网络安全、计费能力、IP地址分配、服务质量保证等方面</p><p><strong>组建的宽带城域网一定是可盈利的</strong></p><p>组建宽带城域网必须定位在可以开展的业务上</p><p>不同城市需要根据自身优势确定重点发展的主业务，同时兼顾其他业务</p><p>建设可盈利的宽带城域网要求能正确定位客户群，发现盈利点，培育和构建产业和服务链</p><p><strong>宽带城域网一定是可开展的</strong></p><p>宽带网络技术的发展具有很大的不确定性，难以准确预测网络服务产品的更新发展，尤其是难于预测一种新的应用的出现</p><p>在方案与设备的选择时必须十分慎重，以降低运营商的投资风险</p><p>对于新的运营商来说，组建可扩展的宽带城域网必须制定统一规划，分阶段、分步骤的逐步实施，减少一次性投资的风险。根据业务的开展，逐步调整建设步骤和规模</p><p><strong>管理和运营宽带城域网的关键技术</strong></p><ul><li><p>带宽管理</p></li><li><p>服务质量</p></li><li><p>网络管理</p></li><li><p>用户管理</p></li><li><p>多业务接入</p></li><li><p>统计与计费</p></li><li><p>IP地址的分配与地址转换</p></li><li><p>网络安全</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;宽带城域网的结构与层次划分&quot;&gt;&lt;a href=&quot;#宽带城域网的结构与层次划分&quot; class=&quot;headerlink&quot; title=&quot;宽带城域网的结构与层次划分&quot;&gt;&lt;/a&gt;宽带城域网的结构与层次划分&lt;/h3&gt;&lt;p&gt;分为三层&lt;/p&gt;
&lt;figure class=&quot;im
      
    
    </summary>
    
      <category term="计算机科学与技术" scheme="https://github.com/jianxiongc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="网络技术发展" scheme="https://github.com/jianxiongc/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>网络技术发展 - 广域网技术特征</title>
    <link href="https://github.com/jianxiongc/2019/11/01/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%20-%20%E5%B9%BF%E5%9F%9F%E7%BD%91%E6%8A%80%E6%9C%AF%E7%89%B9%E5%BE%81/"/>
    <id>https://github.com/jianxiongc/2019/11/01/网络技术发展 - 广域网技术特征/</id>
    <published>2019-11-01T14:56:10.000Z</published>
    <updated>2019-11-01T14:57:30.865Z</updated>
    
    <content type="html"><![CDATA[<h3 id="广域网的主要技术特征"><a href="#广域网的主要技术特征" class="headerlink" title="广域网的主要技术特征"></a>广域网的主要技术特征</h3><ul><li><p>广域网常由电信运营商组建、运营和维护</p></li><li><p>网络运营商运营的广域网为用户提供高质量的数据传输服务，属于公共数据网络（PDN）的性质</p></li><li><p>用户使用广域网服务需要向广域网的运营商租用通信线路或其他资源</p></li><li><p>广域网研究的重点是宽带核心交换技术</p></li><li><p>早期的广域网主要用于大型计算机系统的互联</p></li><li><p>互联网中广域网更多地是作为覆盖地区、国家、洲际地理区域的核心交换平台</p></li></ul><h3 id="广域网技术的发展趋势"><a href="#广域网技术的发展趋势" class="headerlink" title="广域网技术的发展趋势"></a>广域网技术的发展趋势</h3><p><strong>用于构成广域网的主要通信技术与网络类型</strong></p><ul><li><p>公共电话交换网（PSTN）</p></li><li><p>综合业务数字网（ISDN）</p></li><li><p>数字数据网（DDN）</p></li><li><p>X.25分组交换网</p></li><li><p>帧中继（FR）网</p></li><li><p>异步传输模式（ATM）网</p></li><li><p>吉比特以太网 （GE）与十吉比特以太网（10GE）</p></li></ul><p><strong>帧中继技术发展的背景</strong></p><ul><li><p>传输介质由原来的电缆逐步发展到光纤，光纤的误码率很低，数据传输速率高</p></li><li><p>局域网的数据传输速率提高得很快，大量局域网之间高速互连的需求越来越强烈</p></li><li><p>用户计算机性能提高，可以承担一部分原来是由通信子网承担的通信处理功能</p></li></ul><p><strong>帧中继网的特点</strong></p><ul><li><p>高网络吞吐量、低传输延时</p></li><li><p>帧中继是一种采用虚电路的广域网技术，其协议简单、高效，网络吞吐量高、传输延时短</p></li><li><p>帧中继网工作在物理层与数据链路层，流量控制与纠错功能由高层协议完成</p></li><li><p>帧中继网处理一个帧的转发延时要比X.25网减小一个数量级；帧中继网的吞吐量要比X.25网提高一个数量级以上</p></li><li><p>帧中继也称为X.25的流水线方式</p></li><li><p>提供虚拟专网（VPN）服务</p></li><li><p>帧中继网的设计目标主要是局域网之间的互连</p></li><li><p>帧中继网的虚拟专网服务能提供较高的安全性和服务质量</p></li><li><p>帧中继采用面向连接的方式，为用户提供虚拟专用网络服务</p></li><li><p>帧中继网在数据链路层VPN技术中占主导地位</p></li></ul><p><strong>基于帧中继的VPN结构</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15725734668131/15725975307582.jpg" alt="-w610" title>                </div>                <div class="image-caption">-w610</div>            </figure><p><strong>从B-ISDN到ATM</strong></p><p>ISDN致力于实现的目标：</p><p>提供一个在世界范围内协调一致的数字通信网络，支持各种通信服务，并在不同的国家采用相同的标准；</p><p>为在通信网络之间进行数字传输提供完整的标准；</p><p>提供一个标准的用户接口，使通信网络内部的变化对终端用户透明。</p><p>宽带综合业务数据网（B-ISDN）的基本概念</p><p>B-ISDN的设计目标是将语音、数据、静态与动态图像的传输，以及传统的服务综合在一个通信网中，覆盖从低传输速率到高传输速率的各种非实时、实时与突发性的传输要求；</p><p>ATM技术符合B-ISDN的需求，B-ISDN的底层传输网选择了ATM技术。</p><p>ATM技术的主要特点：</p><p>ATM采用的是一种面向连接的技术。</p><p>ATM采用的信元（cell）长度为53B，其中信元头部长度为5B，数据长度为48B；</p><p>ATM以统计时分多路复用方式来动态分配带宽，网络传输延时小，能够适应实时通信的要求；</p><p>ATM的数据传输速率为155Mbps～2.4Gbps。</p><p><strong>光网络研究</strong></p><p>第一代：铜缆与无线射频；</p><p>第二代：光纤；</p><p>第三代：在传输网络中引入光交换机、光路由器，直接在光层配置光通道的传输网络</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15725734668131/15725978012539.jpg" alt="-w622" title>                </div>                <div class="image-caption">-w622</div>            </figure><p><strong>光以太网技术</strong></p><p><strong>光以太网技术研究的背景</strong></p><ul><li><p>利用光纤的巨大带宽资源，以及成熟和广泛应用的Ethernet网技术，为运营商建造新一代的网络提供技术支持；</p></li><li><p>基于这样一个设计思想，一种可运营的光以太网的概念应运而生，从根本上改变电信运营商规划、建设、管理思想。</p></li></ul><p><strong>光以太网的主要特征</strong></p><p>根据终端用户的实际应用需求分配带宽，保证带宽资源充分、合理应用；</p><p>用户访问网络资源必须经过认证和授权，确保用户对网络资源安全的使用；</p><p>及时获得用户的上网时间记录和流量记录，实行计费功能；</p><p>支持VPN和防火墙，有效地保证网络安全</p><p>提供分级的QoS服务；</p><p>方便、快速、灵活地适应用户和业务的扩展。</p><p>光以太网的技术优势：</p><p>组建同样规模的广域网或城域网，光以太网的造价是SONET的1/5，是ATM的1/10。</p><p>IEEE已完成速率从10Mbps、100Mbps、1Gbps到10Gbps的Ethernet技术标准制定，正在研发的速率为100Gbps的Ethernet产品；</p><p>能够覆盖从广域网、城域网到局域网的整个范围。</p><h3 id="广域网技术发展与TCP-IP协议的关系"><a href="#广域网技术发展与TCP-IP协议的关系" class="headerlink" title="广域网技术发展与TCP/IP协议的关系"></a>广域网技术发展与TCP/IP协议的关系</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15725734668131/15725979022077.jpg" alt="-w653" title>                </div>                <div class="image-caption">-w653</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;广域网的主要技术特征&quot;&gt;&lt;a href=&quot;#广域网的主要技术特征&quot; class=&quot;headerlink&quot; title=&quot;广域网的主要技术特征&quot;&gt;&lt;/a&gt;广域网的主要技术特征&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;广域网常由电信运营商组建、运营和维护&lt;/p&gt;
&lt;/li&gt;

      
    
    </summary>
    
      <category term="计算机科学与技术" scheme="https://github.com/jianxiongc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="网络技术发展" scheme="https://github.com/jianxiongc/tags/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概论 - TCP/IP 模型与互联网</title>
    <link href="https://github.com/jianxiongc/2019/10/31/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA-TCP:IP%20%E6%A8%A1%E5%9E%8B%E4%B8%8E%E4%BA%92%E8%81%94%E7%BD%91/"/>
    <id>https://github.com/jianxiongc/2019/10/31/计算机网络概论-TCP:IP 模型与互联网/</id>
    <published>2019-10-31T14:43:10.000Z</published>
    <updated>2019-10-31T14:46:47.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP-IP协议的主要特点"><a href="#TCP-IP协议的主要特点" class="headerlink" title="TCP/IP协议的主要特点"></a>TCP/IP协议的主要特点</h3><ul><li><p>开放的协议标准</p></li><li><p>独立于特定的计算机硬件与操作系统</p></li><li><p>独立于特定的网络硬件，可以运行在局域网、城域网与广域网，适用于网络互联</p></li><li><p>统一的网络地址分配方案，所有运行TCP/IP协议的设备都具有唯一的网络地址</p></li><li><p>标准化的应用层协议，可以提供多种可靠的网络服务</p></li></ul><h3 id="TCP-IP参考模型的层次结构"><a href="#TCP-IP参考模型的层次结构" class="headerlink" title="TCP/IP参考模型的层次结构"></a>TCP/IP参考模型的层次结构</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15723532945682/15724278731438.jpg" alt="-w417" title>                </div>                <div class="image-caption">-w417</div>            </figure><h3 id="TCP-IP参考模型与OSI参考模型的层次对应关系"><a href="#TCP-IP参考模型与OSI参考模型的层次对应关系" class="headerlink" title="TCP/IP参考模型与OSI参考模型的层次对应关系"></a>TCP/IP参考模型与OSI参考模型的层次对应关系</h3><ul><li><p>应用层（application layer）：应用层与OSI参考模型的应用层、表示层与会话层对应</p></li><li><p>传输层（transport layer）：传输层与OSI参考模型的传输层对应</p></li><li><p>互联网络层（internet layer）：互联网络层与OSI参考模型的网络层对应</p></li><li><p>主机-网络层（host-to-network layer）：主机-网络层与OSI参考模型的数据链路层、物理层对应</p></li></ul><h3 id="TCP-IP参考模型各层的主要功能"><a href="#TCP-IP参考模型各层的主要功能" class="headerlink" title="TCP/IP参考模型各层的主要功能"></a>TCP/IP参考模型各层的主要功能</h3><p><strong>主机-网络层</strong></p><p>主机-网络层是TCP/IP参考模型的最低层，它负责通过网络发送和接收IP数据报</p><p>主机-网络层没有规定使用哪种协议，它采取开放的策略，允许使用广域网、局域网与城域网的各种协议。任何一种现有的和流行的低层传输协议都可以与网络层接口</p><p><strong>互联网络层</strong></p><ul><li><p>处理来自传输层的数据发送请求，将传输层报文段封装成IP数据报，启动路由选择算法，选择适当的发送路径，并将数据报转发到下一个结点</p></li><li><p>处理接收的数据报，检查接收分组目的IP地址；如果目的地址为本结点的IP地址，则除去报头将分组交送传输层处理；如果需要转发，选择发送路径并转发</p></li><li><p>处理互联网络的路由选择、流量控制与拥塞控制</p></li></ul><p><strong>传输层</strong></p><ul><li><p>传输层负责在会话的进程之间建立和维护端-端的连接，实现网络环境中分布式进程通信</p></li><li><p>传输层定义两种不同的协议：传输控制协议（TCP）与用户数据报协议（UDP）</p></li><li><p>TCP是一种可靠的、面向连接、面向字节流（byte stream）的传输层协议</p></li><li><p>UDP是一种不可靠的无连接传输层协议</p></li></ul><p><strong>应用层</strong></p><p>TCP/IP应用层基本的协议为 : </p><ul><li>远程登录协议（TELNET）实现远程登录功能</li><li>文件传输协议（FTP）实现交互式文件传输功能</li><li>简单邮件传输协议（SMTP）实现电子邮件传输功能</li><li>域名系统（DNS）实现网络设备名字到IP地址映射服务功能</li><li>简单网络管理协议（SNMP）实现网络设备的监控与管理功能</li><li>超文本传输协议（HTTP）实现Web服务功能</li></ul><p><strong>应用层协议与传输层协议的关系</strong></p><p>应用层协议可以分为3类：</p><p>依赖TCP协议的主要有TELNET、SMTP、FTP等<br>依赖UDP协议的主要有SNMP、<strong>TFTP</strong>等<br>既依赖TCP又依赖UDP协议的主要有DNS</p><h3 id="互联网协议标准、RFC文档与管理机构"><a href="#互联网协议标准、RFC文档与管理机构" class="headerlink" title="互联网协议标准、RFC文档与管理机构"></a>互联网协议标准、RFC文档与管理机构</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="media/15723532945682/15725319842174.jpg" alt="-w647" title>                </div>                <div class="image-caption">-w647</div>            </figure><p><strong>TFTP</strong>: TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP-IP协议的主要特点&quot;&gt;&lt;a href=&quot;#TCP-IP协议的主要特点&quot; class=&quot;headerlink&quot; title=&quot;TCP/IP协议的主要特点&quot;&gt;&lt;/a&gt;TCP/IP协议的主要特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;开放的协议标准&lt;/p&gt;
&lt;/li&gt;
      
    
    </summary>
    
      <category term="计算机网络与概论" scheme="https://github.com/jianxiongc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="计算机科学与技术" scheme="https://github.com/jianxiongc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概论 - 网络体系结构概念与 OSI 参考模型</title>
    <link href="https://github.com/jianxiongc/2019/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA-%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5%E4%B8%8E%20OSI%20%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B/"/>
    <id>https://github.com/jianxiongc/2019/10/29/计算机网络概论-网络体系结构概念与 OSI 参考模型/</id>
    <published>2019-10-29T14:37:12.000Z</published>
    <updated>2019-10-31T13:52:00.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概论-网络体系结构概念与-OSI-参考模型"><a href="#计算机网络概论-网络体系结构概念与-OSI-参考模型" class="headerlink" title="计算机网络概论 - 网络体系结构概念与 OSI 参考模型"></a>计算机网络概论 - 网络体系结构概念与 OSI 参考模型</h1><p>邮政系统的信件处理过程</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/jianxiongc/blog/blob/master/2019/10/29/media/15723144537850/15723158227936.jpg" alt="-w636" title>                </div>                <div class="image-caption">-w636</div>            </figure><p><strong>邮政系统和计算机网络系统相似之处</strong></p><ul><li><p>协议</p></li><li><p>层次</p></li><li><p>接口</p></li><li><p>体系结构</p></li></ul><h3 id="网络协议（network-protocol）"><a href="#网络协议（network-protocol）" class="headerlink" title="网络协议（network protocol）"></a>网络协议（network protocol）</h3><ul><li><p>网络协议是为网络中数据交换而制定的规则、约定与标准</p></li><li><p>网络协议的3要素：语法、语义与时序</p></li><li><p>实现一种网络应用通常需要制定一组协议，称为协议栈或协议族（protocol suite）</p></li></ul><h3 id="层次（layer）"><a href="#层次（layer）" class="headerlink" title="层次（layer）"></a>层次（layer）</h3><ul><li><p>层次是人们处理复杂问题的基本方法</p></li><li><p>将总体要实现的很多功能分配在不同层次，对每个层次完成的服务及服务实现的流程都有明确规定</p></li><li><p>不同的系统具有相同的层次</p></li><li><p>不同系统的同等层具有相同的功能</p></li><li><p>高层使用低层提供的服务时，不需要知道低层服务的具体实现方法</p></li></ul><h3 id="接口（interface）"><a href="#接口（interface）" class="headerlink" title="接口（interface）"></a>接口（interface）</h3><ul><li><p>接口是同一结点内相邻层之间交换信息的连接点</p></li><li><p>同一结点的相邻层之间存在明确规定的接口，低层通过接口向高层提供服务</p></li><li><p>只要接口条件不变、低层功能不变，低层功能的具体实现方法与技术的变化不会影响整个系统的工作</p></li></ul><h3 id="网络体系结构（network-architecture）"><a href="#网络体系结构（network-architecture）" class="headerlink" title="网络体系结构（network architecture）"></a>网络体系结构（network architecture）</h3><ul><li><p>网络体系结构是网络层次结构模型与各层协议的集合</p></li><li><p>各层之间相对独立，高层只需知道下层能够提供的服务，而无需知道低层的服务如何实现</p></li><li><p>各层都可以采用最合适的技术来实现</p></li><li><p>整个系统被分解为若干个易于处理的部分</p></li><li><p>每层的功能与提供的服务都已有精确说明，因此这有利于促进协议的标准化</p></li></ul><h2 id="OSI参考模型的基本概念"><a href="#OSI参考模型的基本概念" class="headerlink" title="OSI参考模型的基本概念"></a>OSI参考模型的基本概念</h2><ul><li><p>OSI参考模型中的“开放”是指只要遵循OSI标准，一台计算机就可以与位于世界上任何地方、同样遵循同一标准的其它计算机进行通信</p></li><li><p>OSI参考模型定义开放系统的层次结构、层次之间的相互关系与各层包括的服务</p></li><li><p>OSI参考模型作为一个框架来协调和组织各层协议的制定，也是对网络内部结构精炼的概括与描述</p></li></ul><p>广域网结构与OSI参考模型关系的示意图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/jianxiongc/blog/blob/master/2019/10/29/media/15723144537850/15723144537850/15723383717902.jpg" alt="-w576" title>                </div>                <div class="image-caption">-w576</div>            </figure><p><strong>ISO划分层次的原则</strong></p><ul><li><p>网中各结点都具有相同的层次</p></li><li><p>不同结点的同等层具有相同的功能</p></li><li><p>同一结点内相邻层之间通过接口通信</p></li><li><p>每层可以使用下层提供的服务，并向其上层提供服务</p></li><li><p>不同结点的同等层通过协议来实现对等层次之间的通信</p></li></ul><p><strong>OSI参考模型七层结构</strong></p><ol><li><p>物理层</p></li><li><p>数据链路层</p></li><li><p>网络层</p></li><li><p>传输层</p></li><li><p>会话层</p></li><li><p>表示层</p></li><li><p>应用层</p></li></ol><p><strong>OSI参考模型各层的主要功能</strong></p><ul><li><p>物理层（physical layer）：利用传输介质实现比特序列的传输</p></li><li><p>数据链路层（data link layer）：采用差错控制与流量控制方法，使得有差错的物理线路变成无差错的数据链路</p></li><li><p>网络层（network layer）：实现路由选择、分组转发与拥塞控制等功能，为“分组”传输选择“最佳”的路由</p></li><li><p>传输层（transport layer）：向高层用户提供可靠的“端-端（end-to-end）”通信服务，向高层屏蔽下层数据通信的具体细节</p></li><li><p>会话层（session layer）是：维护两个通信计算机之间的进程通信，管理数据交换</p></li><li><p>表示层（presentation layer）：处理两个通信的计算机系统的数据表示方式，完成数据的格式变换、加密与解密、压缩与恢复</p></li><li><p>应用层（application layer）是：为应用软件提供多种网络服务，例如文件服务、数据库服务、电子邮件与其它服务等</p></li></ul><p><strong>OSI环境（OSI environment，OSIE）</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/jianxiongc/blog/blob/master/2019/10/29/media/15723144537850/15723144537850/15723385629317.jpg" alt="-w640" title>                </div>                <div class="image-caption">-w640</div>            </figure><p><strong>OSI环境中的数据传输的过程</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/jianxiongc/blog/blob/master/2019/10/29/media/15723144537850/15723144537850/15723385903066.jpg" alt="-w683" title>                </div>                <div class="image-caption">-w683</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络概论-网络体系结构概念与-OSI-参考模型&quot;&gt;&lt;a href=&quot;#计算机网络概论-网络体系结构概念与-OSI-参考模型&quot; class=&quot;headerlink&quot; title=&quot;计算机网络概论 - 网络体系结构概念与 OSI 参考模型&quot;&gt;&lt;/a&gt;计算机网络概
      
    
    </summary>
    
      <category term="计算机网络与概论" scheme="https://github.com/jianxiongc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="计算机科学与技术" scheme="https://github.com/jianxiongc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概论 - 计算机网络的拓扑构型</title>
    <link href="https://github.com/jianxiongc/2019/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8B%93%E6%89%91%E6%9E%84%E5%9E%8B/"/>
    <id>https://github.com/jianxiongc/2019/10/28/计算机网络概论-计算机网络的拓扑构型/</id>
    <published>2019-10-28T15:22:12.000Z</published>
    <updated>2019-10-28T15:25:57.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概论-计算机网络的拓扑构型"><a href="#计算机网络概论-计算机网络的拓扑构型" class="headerlink" title="计算机网络概论 - 计算机网络的拓扑构型"></a>计算机网络概论 - 计算机网络的拓扑构型</h1><h2 id="计算机网络拓扑的定义"><a href="#计算机网络拓扑的定义" class="headerlink" title="计算机网络拓扑的定义"></a>计算机网络拓扑的定义</h2><ul><li>计算机网络拓扑是通过网中节点与通信线路之间的几何关系表示网络结构，反映出网络各实体之间的结构关系。</li><li>计算机网络拓扑是指通信子网的拓扑构型。</li></ul><h2 id="基本的网络拓扑"><a href="#基本的网络拓扑" class="headerlink" title="基本的网络拓扑"></a>基本的网络拓扑</h2><ul><li>星型拓扑</li><li>环形拓扑</li><li>总线性拓扑</li><li>树形拓扑</li><li>网状拓扑</li></ul><h3 id="星型拓扑"><a href="#星型拓扑" class="headerlink" title="星型拓扑"></a>星型拓扑</h3><ul><li>节点通过点-点通信线路与中心线路连接</li><li>中心节点控制全网的通信，任何两节点之间的通信都要通过中心节点。</li><li>星型拓扑构型的特点是: 结构简单，易于实现，便于管理。</li><li>缺点: 中心节点成为全网性能的瓶颈</li></ul><h3 id="环形拓扑"><a href="#环形拓扑" class="headerlink" title="环形拓扑"></a>环形拓扑</h3><ul><li>节点通过点-点通信线路连接成闭关</li><li>环中数据将沿一个方向逐站传送</li><li>环形拓扑结构简单，传输延时确定</li><li>但是环中每个结点与连接结点之间的通信线路都会成为网络可靠性的瓶颈</li><li>环网需要设计复杂的环维护协议</li></ul><h3 id="总线形拓扑"><a href="#总线形拓扑" class="headerlink" title="总线形拓扑"></a>总线形拓扑</h3><ul><li>在总线形拓扑结构中，所有结点连接在一条作为公共传输介质的总线；</li><li>当一个结点利用总线发送数据时，其它结点只能接收数据；</li><li>如果有两个及以上的结点同时利用公共总线发送数据时，就会出现冲突，造成传输失败；</li><li>总线形拓扑特点是结构简单；</li><li>缺点是必须解决多结点访问总线介质访问控制策略问题。</li></ul><h3 id="树形拓扑"><a href="#树形拓扑" class="headerlink" title="树形拓扑"></a>树形拓扑</h3><ul><li>树形拓扑结构中结点按层次进行连接，信息交换主要在上、下结点之间进行，相邻及同层结点之间通常不进行数据交换，或数据交换量比较小</li><li>树形拓扑可以看成星形拓扑的扩展</li><li>树形拓扑网络适用于汇集信息的应用要求</li></ul><h3 id="网状拓扑"><a href="#网状拓扑" class="headerlink" title="网状拓扑"></a>网状拓扑</h3><ul><li>在网状拓扑结构中，结点之间的连接是任意的，没有规律</li><li>网状拓扑的优点是系统可靠性高</li><li>网状拓扑结构复杂，必须采用路由选择算法、流量控制与拥塞控制方法</li><li>广域网一般都采用网状拓扑</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络概论-计算机网络的拓扑构型&quot;&gt;&lt;a href=&quot;#计算机网络概论-计算机网络的拓扑构型&quot; class=&quot;headerlink&quot; title=&quot;计算机网络概论 - 计算机网络的拓扑构型&quot;&gt;&lt;/a&gt;计算机网络概论 - 计算机网络的拓扑构型&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="计算机网络与概论" scheme="https://github.com/jianxiongc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="计算机科学与技术" scheme="https://github.com/jianxiongc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概论 - 网络发展的三个主线</title>
    <link href="https://github.com/jianxiongc/2019/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA-%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95%E7%9A%84%E4%B8%89%E4%B8%AA%E4%B8%BB%E7%BA%BF/"/>
    <id>https://github.com/jianxiongc/2019/10/27/计算机网络概论-网络发展的三个主线/</id>
    <published>2019-10-26T16:43:59.000Z</published>
    <updated>2019-10-26T16:43:50.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概论-网络发展的三个主线"><a href="#计算机网络概论-网络发展的三个主线" class="headerlink" title="计算机网络概论-网络发展的三个主线"></a>计算机网络概论-网络发展的三个主线</h1><h3 id="1-从-ARPANET-到-Internet"><a href="#1-从-ARPANET-到-Internet" class="headerlink" title="1. 从 ARPANET 到 Internet"></a>1. 从 ARPANET 到 Internet</h3><p>ARPANET的研究奠定互联网发展的基础，而联系二者的是TCP/IP协议。</p><p>在从ARPANET演变到互联网的过程中，强烈的社会需求促进广域网、城域网与局域网技术的研究与应用的发展，而广域网、城域网与局域网技术的成熟与标准化，又加速了互联网的发展进程。</p><p>与传统的客户/服务器（C/S）工作模式不同，对等（P2P）工作模式淡化了服务提供者与服务使用者的界限，从而达到进一步扩大网络资源共享范围和深度，提高网络资源利用率，达到信息共享最大化的目的。</p><p>新的基于P2P网络应用不断出现，成为21世纪网络应用重要的研究方向之一。</p><p>随着互联网的广泛应用，计算机网络、电信网络与有线电视网络从结构、技术到服务领域正在快速地融合，成为21世纪信息产业发展最具活力的领域。</p><h3 id="2-从无线分组网到无线自组网、无线传感器网络的无线网络技术"><a href="#2-从无线分组网到无线自组网、无线传感器网络的无线网络技术" class="headerlink" title="2. 从无线分组网到无线自组网、无线传感器网络的无线网络技术"></a>2. 从无线分组网到无线自组网、无线传感器网络的无线网络技术</h3><p>无线网络可以分为基于基础设施与无基础设施的两类。802.11<strong>无线局域网</strong>（WLAN）与802.16<strong>无线城域网</strong>（WMAN）属于需要基础设施的一类无线网络。</p><p>无线自组网、无线传感器网络属于不需要基础设施的另一类无线网络。</p><p>在无线分组网的基础上发展起来的<strong>无线自组网</strong>（Ad hoc）是一种特殊的自组织、对等式、多跳、无线移动网络，它是军事、特殊应用领域有着重要的应用前景。</p><p>无线网状网（WMN）是无线自组网在接入领域的一种应用。</p><p>当无线自组网技术日趋成熟的时候，无线通信、微电子、传感器技术得到快速发展。在军事领域中，人们提出将无线自组网与传感器技术相结合的无线传感器网络技术研究。</p><p>无线传感器网络（WSN）被评价为“21世纪最有影响的21项技术之一”和“改变世界的十大技术之首”。</p><p>如果说广域网作用是扩大信息社会中资源共享的范围，局域网是进一步增强信息社会中资源共享的深度，无线网络增强人类共享信息资源的灵活性，那么无线传感器网络将会改变人类与自然界的交互方式，它将极大地扩展现有网络的功能和人类认识世界的能力。</p><h3 id="3-网络安全技术"><a href="#3-网络安全技术" class="headerlink" title="3. 网络安全技术"></a>3. 网络安全技术</h3><p>人类创造了网络虚拟社会的繁荣，也是人类制造了网络虚拟社会的麻烦。</p><p>现实社会对网络技术依赖的程度越高，网络安全技术就越显得重要。网络安全是网络技术研究中一个永恒的主题。</p><p>在“攻击—防御—新攻击—新防御”的循环中，网络攻击技术与网络反攻击技术相互影响、相互制约，共同发展，这个过程将一直延续下去。</p><p>从当前的发展趋势看，网络安全问题已超出技术和传统意义上计算机犯罪的范畴，已发展成为国家之间一种政治与军事的手段。</p><p>各国只能立足于自身，研究网络安全技术，培养专门人才，发展网络安全产业，构筑网络与信息安全保障体系。</p><p><strong>计算机网络的定义：</strong></p><pre><code>以能够相互共享资源的方式互联起来的自治计算机系统的集合。</code></pre><p>计算机网络的基本特征 :</p><pre><code>1. 计算机网络建立的目的是实现计算机资源的共享。2. 互联的计算机是分布在不同地理位置的多台独立的“自治计算机系统”。3. 联网计算机之间的通信必须遵循共同的网络协议。</code></pre><p><strong>计算机网络的分类</strong></p><p>计算机网络分类的方法 :</p><pre><code>1. 按网络采用的传输技术分类2. 按网络覆盖的地理范围分类</code></pre><p>按传输技术分类 :</p><pre><code>1. 广播通信信道—广播网络2. 点-点通信信道—点-点网络</code></pre><p>按照覆盖的地理范围进行分类 :</p><pre><code>1. 局域网2. 城域网3. 广域网</code></pre><p>局域网（LAN）的基本特征 :</p><pre><code>局域网用于将有限范围内（例如一个实验室、一幢大楼、一个校园）的各种计算机、终端与外部设备互联成网；局域网可以分为共享局域网与交换局域网；</code></pre><p>城域网（MAN）的基本特征 :</p><pre><code>城域网的设计目标是要满足几十公里范围内的大量企业、机关、公司的多个局域网互联的需求，以实现大量用户之间的数据、语音、图形与视频等多种信息的传输。宽带城域网的概念逐渐取代传统意义上的城域网。</code></pre><p>广域网（WAN）的基本特征 :</p><pre><code>广域网覆盖的地理范围从几十公里到几千公里；广域网可以是覆盖一个国家、地区，或横跨几个洲；广域网将分布在不同地区的宽带城域网或计算机系统互联起来，提供各种网络服务，实现信息资源共享。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络概论-网络发展的三个主线&quot;&gt;&lt;a href=&quot;#计算机网络概论-网络发展的三个主线&quot; class=&quot;headerlink&quot; title=&quot;计算机网络概论-网络发展的三个主线&quot;&gt;&lt;/a&gt;计算机网络概论-网络发展的三个主线&lt;/h1&gt;&lt;h3 id=&quot;1-从-A
      
    
    </summary>
    
      <category term="计算机网络与概论" scheme="https://github.com/jianxiongc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="计算机科学与技术" scheme="https://github.com/jianxiongc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络与概论 - 计算机发展的四个阶段</title>
    <link href="https://github.com/jianxiongc/2019/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5/"/>
    <id>https://github.com/jianxiongc/2019/10/21/计算机网络概论-计算机发展的四个阶段/</id>
    <published>2019-10-21T14:24:59.000Z</published>
    <updated>2019-10-26T16:45:07.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="四个阶段的特点"><a href="#四个阶段的特点" class="headerlink" title="四个阶段的特点"></a>四个阶段的特点</h3><h4 id="第一阶段：计算机网络技术与理论准备阶段"><a href="#第一阶段：计算机网络技术与理论准备阶段" class="headerlink" title="第一阶段：计算机网络技术与理论准备阶段"></a>第一阶段：计算机网络技术与理论准备阶段</h4><p>20 世纪 50 年代</p><ol><li>数据通信的研究与技术的日趋成熟，为计算机网络的形成奠定了技术基础</li><li><strong>分组交换概念</strong>的提出为计算机网络的研究奠定了理论基础</li></ol><h4 id="第二阶段：计算机网络的形成"><a href="#第二阶段：计算机网络的形成" class="headerlink" title="第二阶段：计算机网络的形成"></a>第二阶段：计算机网络的形成</h4><p>20 世纪 60 年代开始</p><ol><li><strong>ARPANET</strong> 的成功运行证明分组交换理论的正确性</li><li><strong>TCP/IP协议</strong> 的广泛应用为更大规模的网络互联奠定坚实的基础</li><li><strong>DNS</strong>、E-mail、<strong>FTP</strong>、<strong>TELNET</strong>、<strong>BBS</strong> 等应用展现了网络技术应用的广阔前景</li></ol><h4 id="第三阶段：计算机网络的形成"><a href="#第三阶段：计算机网络的形成" class="headerlink" title="第三阶段：计算机网络的形成"></a>第三阶段：计算机网络的形成</h4><p>从20世纪70年代中期开始</p><ol><li><strong>OSI</strong> 参考模型的研究对网络理论体系的形成与发展，以及在推进网络协议标准化方面起到了重要的推动作用</li><li>TCP/IP协议经受了市场和用户的检验，吸引了大量的投资，推动了互联网应用的发展，成为业界事实上的标准。</li></ol><h4 id="第四阶段：互联网应用、无线网络与网络安全技术研究的发展"><a href="#第四阶段：互联网应用、无线网络与网络安全技术研究的发展" class="headerlink" title="第四阶段：互联网应用、无线网络与网络安全技术研究的发展"></a>第四阶段：互联网应用、无线网络与网络安全技术研究的发展</h4><p>从20世纪90年代开始</p><ol><li>互联网作为全球性的网际网与信息系统，在当今政治、经济、文化、科研、教育与社会生活等方面发挥了越来越重要的作用</li><li>计算机网络与电信网络、有线电视网络“三网融合”促进了宽带<strong>城域网</strong>概念、技术的演变</li><li>无线局域网与无线城域网技术日益成熟，已经进入应用阶段，<strong>无线自组网</strong>、<strong>无线传感器网络</strong> 的研究与应用受到了高度重视</li><li><strong>对等（P2P）网络</strong> 的研究使新的网络应用不断涌现，成为现代信息服务业新的产业增长点；</li><li>随着网络应用的快速增长，新的网络安全问题不断出现，促使网络安全技术的研究与应用进入高速发展阶段。</li></ol><h3 id="计算机网络的形成与发展"><a href="#计算机网络的形成与发展" class="headerlink" title="计算机网络的形成与发展"></a>计算机网络的形成与发展</h3><p><strong>网络拓扑结构设计思路</strong></p><p><strong>集中式和非集中式的拓扑构型</strong></p><p><strong>集中式</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15713624202464.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>非集中式</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15713624392304.jpg" alt="-w317" title>                </div>                <div class="image-caption">-w317</div>            </figure><p><strong>分布式网络的拓扑架构</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714548395437.jpg" alt="-w304" title>                </div>                <div class="image-caption">-w304</div>            </figure><h4 id="分组交换技术的基本设计思路"><a href="#分组交换技术的基本设计思路" class="headerlink" title="分组交换技术的基本设计思路"></a>分组交换技术的基本设计思路</h4><p><strong>分组交换技术重要的概念：</strong></p><ul><li><p>分组</p></li><li><p>路由选择</p></li><li><p>存储转发</p></li><li><p>报文与报文分组</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714549049298.jpg" alt="-w598" title>                </div>                <div class="image-caption">-w598</div>            </figure><p><strong>报文存储转发与分组存储转发过程的比较</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714549193740.jpg" alt="-w622" title>                </div>                <div class="image-caption">-w622</div>            </figure><p><strong>ARPANET的设计思想</strong><br>通信子网结构与分组交换原理示意图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714633466706.jpg" alt="-w770" title>                </div>                <div class="image-caption">-w770</div>            </figure><p>ARPANET最早4个结点的结构</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714633691145.jpg" alt="-w640" title>                </div>                <div class="image-caption">-w640</div>            </figure><p><strong>ARPANET的主要贡献</strong><br>开展了对计算机网络定义与分类方法的研究。</p><p>提出了资源子网与通信子网的二级网络结构概念。</p><p>研究了分组交换的协议与实现技术。</p><p>研究了层次型网络体系结构的模型与协议体系。</p><p>开展了TCP/IP协议与网络互联技术的研究。</p><p>TCP/IP协议研究与发展</p><p>ARPANET协议主要包括：主机-主机协议、源IMP-目的IMP协议、IMP-IMP协议；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714634771484.jpg" alt="-w465" title>                </div>                <div class="image-caption">-w465</div>            </figure><p>1977年10月，ARPANET研究人员决定将初期的TCP分为传输控制协议（TCP）与互联网络协议（IP）；</p><p>TCP协议主要用于实现源主机与目的主机之间的分布式进程通信的功能；</p><p>IP协议主要用于实现分组通过通信子网的路由选择功能。</p><p>从ARPANET到Internet的发展过程</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714636217763.jpg" alt="-w638" title>                </div>                <div class="image-caption">-w638</div>            </figure><h4 id="名词理解"><a href="#名词理解" class="headerlink" title="名词理解"></a>名词理解</h4><p><strong>分组交换概念</strong></p><p>在通信过程中，通信双方以分组为单位、使用存储-转发机制实现数据交互的通信方式，被称为分组交换（PS:packet switching）。<br>分组交换也称为包交换，它将用户通信的数据划分成多个更小的等长数据段，在每个数据段的前面加上必要的控制信息作为数据段的首部，每个带有首部的数据段就构成了一个分组。首部指明了该分组发送的地址，当交换机收到分组之后，将根据首部中的地址信息将分组转发到目的地，这个过程就是分组交换。能够进行分组交换的通信网被称为分组交换网。<br>分组交换的本质就是存储转发，它将所接受的分组暂时存储下来，在目的方向路由上排队，当它可以发送信息时，再将信息发送到相应的路由上，完成转发。其存储转发的过程就是分组交换的过程。<br>分组交换的思想来源于报文交换，报文交换也称为存储转发交换，它们交换过程的本质都是存储转发，所不同的是分组交换的最小信息单位是分组，而报文交换则是一个个报文。由于以较小的分组为单位进行传输和交换，所以分组交换比报文交换快。报文交换主要应用于公用电报网中。</p><p> <strong>ARPANET</strong></p><p>高级研究计划局网络（英语：Advanced Research Projects Agency Network），通称阿帕网（英语：ARPANET）是美国国防高级研究计划局开发的世界上第一个运营的数据包交换网络，是全球互联网的鼻祖。</p><p><strong>TCP/IP协议</strong></p><p>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为网际网络的基础通信架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的堆栈，因此又被称为TCP/IP协议栈（英语：TCP/IP Protocol Stack） 。这些协议最早发源于美国国防部（缩写为DoD）的ARPA网项目，因此也被称作DoD模型（DoD Model）。这个协议族由互联网工程任务组负责维护。</p><p>TCP/IP提供了点对点连结的机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为是简化的七层OSI模型。</p><p><strong>OSI 模型</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714523584140.jpg" alt="-w615" title>                </div>                <div class="image-caption">-w615</div>            </figure><p><strong>DNS</strong></p><p>域名系统（英语：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</p><p><strong>FTP</strong></p><p>文件传输协议（File Transfer Protocol，FTP）是用于在网络上进行文件传输的一套标准协议，它工作在 OSI 模型的第七层， TCP 模型的第四层， 即应用层， 使用 TCP 传输而不是 UDP， 客户在和服务器建立连接前要经过一个“三次握手”的过程， 保证客户与服务器之间的连接是可靠的， 而且是面向连接， 为数据传输提供可靠保证。</p><p>FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而， 用户并不真正登录到自己想要存取的计算机上面而成为完全用户， 可用FTP程序访问远程资源， 实现用户往返传输文件、目录管理以及访问电子邮件等等， 即使双方计算机可能配有不同的操作系统和文件存储方式</p><p><strong>城域网</strong></p><p>都会网域（Metropolitan Area Network，MAN）指大型的计算机网络，属于IEEE802.6标准，是介于LAN和WAN之间能传输语音与数据的公用网络。MAN是改进LAN（局域网）中的传输介质，扩大局域网的范围，达到包含一个大学校园、城市或都会区。它是较大型的局域网，需要的成本较高，但可以提供更快的传输速率。例如：某一家企业把在一个城市或同一国家内的服务据点连接起来，就可以称为一个或多个城域网。一些常用于城市区网的技术包括：以太网（10Gbps/100Gbps）、WiMAX（全球互通微波访问）。</p><p> <strong>对等（P2P）网络</strong></p><p>对等式网络（peer-to-peer， 简称P2P），又称点对点技术，是无中心服务器、依靠用户群（peers）交换信息的互联网体系，它的作用在于，减低以往网路传输中的节点，以降低资料遗失的风险。与有中心服务器的中央网络系统不同，对等网络的每个用户端既是一个节点，也有服务器的功能，任何一个节点无法直接找到其他节点，必须依靠其户群进行信息交流。</p><p>P2P节点能遍布整个互联网，也给包括开发者在内的任何人、组织、或政府带来监控难题。P2P在网络隐私要求高和文件共享领域中，得到了广泛的应用。使用一般型P2P技术的网络系统有比特币、Gnutella，或自由网等。另外，P2P技术也被使用在类似VoIP等实时媒体业务的数据通信中。有些网络（如Napster、OpenNAP，或IRC @find）包括搜索的一些功能，也使用客户端-服务器结构，而使用P2P结构来实现另外一些功能。这种网络设计模型不同于客户端-服务器模型，在客户端-服务器模型中通信通常来往于一个中央服务器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;四个阶段的特点&quot;&gt;&lt;a href=&quot;#四个阶段的特点&quot; class=&quot;headerlink&quot; title=&quot;四个阶段的特点&quot;&gt;&lt;/a&gt;四个阶段的特点&lt;/h3&gt;&lt;h4 id=&quot;第一阶段：计算机网络技术与理论准备阶段&quot;&gt;&lt;a href=&quot;#第一阶段：计算机网络技术与理
      
    
    </summary>
    
      <category term="计算机网络与概论" scheme="https://github.com/jianxiongc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="计算机科学与技术" scheme="https://github.com/jianxiongc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>黑客与画家</title>
    <link href="https://github.com/jianxiongc/2019/08/02/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/"/>
    <id>https://github.com/jianxiongc/2019/08/02/黑客与画家/</id>
    <published>2019-08-02T12:24:59.000Z</published>
    <updated>2019-08-02T12:25:46.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑客与画家"><a href="#黑客与画家" class="headerlink" title="黑客与画家"></a>黑客与画家</h1><p>这里总结了自己在阅读这本书时候所做的标注。</p><h4 id="Make-something-people-want"><a href="#Make-something-people-want" class="headerlink" title="Make something people want."></a>Make something people want.</h4><p>抓住最本质的东西 ，做出人们真正需要 真正想要的产品 。为此你需要关注用户需要什么 ， 倾听用户的声音 ， 琢磨他们需要什么。</p><h4 id="为什么书呆子不受欢迎-，-他们的心思在别的地方"><a href="#为什么书呆子不受欢迎-，-他们的心思在别的地方" class="headerlink" title="为什么书呆子不受欢迎 ， 他们的心思在别的地方"></a>为什么书呆子不受欢迎 ， 他们的心思在别的地方</h4><p>健康的等级关系应该是通过各自出色的能力获得的 ， 而不是排挤他人。</p><p>谈到青少年 11 岁到 14 岁是人生中最糟糕的阶段 ， 由在学校内部构建起的野蛮文化 。 如何让自己在集体中变得更受欢迎，还是坚持做一个书呆子 。</p><p>总体上看 ， 我就读的学校与上面所说的监狱差不多 。 校方最重视的事情 ， 就是让学生待在自己应该待的位置 。 与此同时 ， 让学生有东西吃 ， 避免公然的暴力行为 ， 接下来才是尝试教给学生一些东西 。 除此以外 ， 校方并不愿意在学生身上多费心思 。 就像监狱的狱卒 ， 老师们很大程度上对学生是放任自流的 。 结果 ， 学生就像犯人一样 ， 发展出了野蛮的内部文化 。</p><h4 id="因为如果你不爱一件事-，-你不可能把它做的真正优秀-，-要是你很热爱编程-，-你就不可避免的会开发你自己的项目。"><a href="#因为如果你不爱一件事-，-你不可能把它做的真正优秀-，-要是你很热爱编程-，-你就不可避免的会开发你自己的项目。" class="headerlink" title="因为如果你不爱一件事 ， 你不可能把它做的真正优秀 ， 要是你很热爱编程 ， 你就不可避免的会开发你自己的项目。"></a>因为如果你不爱一件事 ， 你不可能把它做的真正优秀 ， 要是你很热爱编程 ， 你就不可避免的会开发你自己的项目。</h4><p>我在工作一年左右的时候开始想要做一些自己的东西 ， 起初只是有一些自己的想法 ，希望时间管理的方式更加简单 。 后来慢慢的开始做到真正的投入给用户 有很多用户反馈给我 ，给了我许多的支持 。 我想这就是我与世界沟通的方式吧。 真正的自己做的项目 ， 没有任何为公司 ，出自于热爱 ，和一个想做好产品的心 。</p><h4 id="小时候-，每个人都会鼓励你不断成长-，变成一个心智成熟-，不在耍小孩子脾气的人-。-但是-，很少有人鼓励你继续成长-，变成一个怀疑和地址社会错误潮流的人-。-如果自己就是潮水的一部分-，-怎么能看见潮流的方向呢-？-你只能永远保持质问-。问自己-，什么话是我不能说的-？-为什么-？"><a href="#小时候-，每个人都会鼓励你不断成长-，变成一个心智成熟-，不在耍小孩子脾气的人-。-但是-，很少有人鼓励你继续成长-，变成一个怀疑和地址社会错误潮流的人-。-如果自己就是潮水的一部分-，-怎么能看见潮流的方向呢-？-你只能永远保持质问-。问自己-，什么话是我不能说的-？-为什么-？" class="headerlink" title="小时候 ，每个人都会鼓励你不断成长 ，变成一个心智成熟 ，不在耍小孩子脾气的人 。 但是 ，很少有人鼓励你继续成长 ，变成一个怀疑和地址社会错误潮流的人 。 如果自己就是潮水的一部分 ， 怎么能看见潮流的方向呢 ？ 你只能永远保持质问 。问自己 ，什么话是我不能说的 ？ 为什么 ？"></a>小时候 ，每个人都会鼓励你不断成长 ，变成一个心智成熟 ，不在耍小孩子脾气的人 。 但是 ，很少有人鼓励你继续成长 ，变成一个怀疑和地址社会错误潮流的人 。 如果自己就是潮水的一部分 ， 怎么能看见潮流的方向呢 ？ 你只能永远保持质问 。问自己 ，什么话是我不能说的 ？ 为什么 ？</h4><p>如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，受到的阻力也会越大，因为你没有迎合社会习俗，而是一步步地与它背道而驰。</p><h4 id="设计者的品味-如何做出优秀的东西？"><a href="#设计者的品味-如何做出优秀的东西？" class="headerlink" title="设计者的品味: 如何做出优秀的东西？"></a>设计者的品味: 如何做出优秀的东西？</h4><p>好设计是简单的设计<br>好设计是永不过时的设计<br>好设计是解决主要问题的设计<br>好设计是启发性的设计<br>好设计通常是有点趣味性的设计<br>好设计常常是大胆的设计<br>好设计常常是奇特的设计<br>好设计是能够复制的设计<br>好设计是一种再设计<br>好设计是模仿大自然的设计<br>好设计是对称的设计<br>好设计是看似容易的设计</p><p>幽默感是强壮的一种表现 ，始终拥有幽默感就代表你对厄运一笑了之 ，而丧失幽默感就代表你被厄运深深伤害到。</p><p>把品味说成个人的偏好可以很好的杜绝争论 ，防止人们争执哪一种品味更好 。 但是问题是 ， 这种说法是不正确的 。只要你开始设计东西 ， 就能明白这一点 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;黑客与画家&quot;&gt;&lt;a href=&quot;#黑客与画家&quot; class=&quot;headerlink&quot; title=&quot;黑客与画家&quot;&gt;&lt;/a&gt;黑客与画家&lt;/h1&gt;&lt;p&gt;这里总结了自己在阅读这本书时候所做的标注。&lt;/p&gt;
&lt;h4 id=&quot;Make-something-people-wa
      
    
    </summary>
    
      <category term="阅读" scheme="https://github.com/jianxiongc/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="读书" scheme="https://github.com/jianxiongc/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Swift常用操作符</title>
    <link href="https://github.com/jianxiongc/2019/08/01/Swift%20-%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>https://github.com/jianxiongc/2019/08/01/Swift - 常用操作符/</id>
    <published>2019-08-01T11:40:37.000Z</published>
    <updated>2019-08-01T12:16:00.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift-常用操作符"><a href="#Swift-常用操作符" class="headerlink" title="Swift 常用操作符"></a>Swift 常用操作符</h1><h2 id="基本操作符"><a href="#基本操作符" class="headerlink" title="基本操作符"></a>基本操作符</h2><p><strong>赋值操作符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=</span><br></pre></td></tr></table></figure><p><strong>基本算术操作符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+</span><br><span class="line">-</span><br><span class="line">*</span><br><span class="line">/</span><br><span class="line">%</span><br></pre></td></tr></table></figure><p>“Swift 3不再允许浮点数取模。例如：8 ％ 2.5这样的写法在Swift 3中将会报错。如果要对浮点数取模，只能这样： 8.truncatingRemainder(dividingBy: 2.5)。”</p><p><strong>复合操作符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+=</span><br><span class="line">-=</span><br><span class="line">*=</span><br><span class="line">/=</span><br><span class="line">%=</span><br></pre></td></tr></table></figure><p>Swift不会把数字自动转换成Bool类型。在需要Bool值的地方，你必须明确使用一个Bool变量。 (不如js方便)<br>“Swift 3中不再支持自增（++）和自减（–）操作符，使用它们的前缀和后缀版本都会得到一个编译器错误。因此，需要+1/-1的时候，只能使用b += 1和b -= 1来实现。”</p><p><strong>比较操作符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==</span><br><span class="line">!=</span><br><span class="line">&gt;</span><br><span class="line">&lt;</span><br><span class="line">&lt;=</span><br><span class="line">&gt;=</span><br></pre></td></tr></table></figure><p><strong>三元运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let result = a ? b : c;</span><br></pre></td></tr></table></figure><p><strong>Nil Coalescing Operator</strong></p><p>需要注意 , 这是 Swift 特有的操作符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// opt != nil ? opt! : b</span><br><span class="line"></span><br><span class="line">let value = userInput ?? &quot;default input&quot;</span><br></pre></td></tr></table></figure><p>如果 opt 是一个 optional ，当其不为nil时，就使用optional变量自身的值，否则，就使用??后面的“默认值”。</p><p><strong>闭区间range operator</strong></p><p>Swift 内 for 循环的新写法 ， 用 begin … end 的方式表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for index in 1...5 &#123;</span><br><span class="line">    print(index) //1,2,3,4,5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>半开半闭区间range operator</strong></p><p>与上面的相似 写法为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for index in 1..&lt;5 &#123;</span><br><span class="line">    print(index)  //1,2,3,4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>逻辑运算符</strong></p><p>与其他语言逻辑运算符一样 ，Swift 支持 NOT，AND 和 OR , 它们都返回一个 Bool</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let isLogin = !res;</span><br><span class="line">let userName = userName &amp;&amp; userNickName</span><br><span class="line">let userAge = userAge || defalutAge</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swift-常用操作符&quot;&gt;&lt;a href=&quot;#Swift-常用操作符&quot; class=&quot;headerlink&quot; title=&quot;Swift 常用操作符&quot;&gt;&lt;/a&gt;Swift 常用操作符&lt;/h1&gt;&lt;h2 id=&quot;基本操作符&quot;&gt;&lt;a href=&quot;#基本操作符&quot; class
      
    
    </summary>
    
      <category term="Swift学习笔记" scheme="https://github.com/jianxiongc/categories/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="https://github.com/jianxiongc/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-Tuple</title>
    <link href="https://github.com/jianxiongc/2019/07/31/Swift%20-%20Tuple/"/>
    <id>https://github.com/jianxiongc/2019/07/31/Swift - Tuple/</id>
    <published>2019-07-31T09:11:40.000Z</published>
    <updated>2019-07-31T09:16:34.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift-Tuple"><a href="#Swift-Tuple" class="headerlink" title="Swift - Tuple"></a>Swift - Tuple</h1><p>相比于 Objective-C ，Swift 提供了一种新的类型 <strong>Tuple</strong> ， Tuple可以创建一组不同类型的集合。</p><p>例如需要返回一个 HTTP 状态信息 : </p><ul><li>状态码 : 200 ; 状态消息 : SUCCESS</li><li>状态码 : 404 ; 状态消息 : File not found</li></ul><h2 id="定义一个-Tuple"><a href="#定义一个-Tuple" class="headerlink" title="定义一个 Tuple"></a>定义一个 Tuple</h2><p>定义一个 HTTP 状态消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//: #### Define a tuple</span><br><span class="line"></span><br><span class="line">let success = (200 ,&quot;SUCCESS&quot;)          //(.0 200, .1 &quot;SUCCESS&quot;)</span><br><span class="line">let fail = (404 ,&quot;File not found&quot;)      //(.0 404, .1 &quot;File not found&quot;)</span><br></pre></td></tr></table></figure><p>定义一个指定命名的Tuple</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let userInfo = (name: &quot;jianxiong&quot;, age: 22, email: &quot;jianxiong1997@gmail.com&quot;)</span><br></pre></td></tr></table></figure><p>定义好之后 ，就可以通过下面的方式访问 Tuple 中的数据成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">success.0           //200</span><br><span class="line">success.1           //&quot;SUCCESS&quot;</span><br><span class="line"></span><br><span class="line">fail.0              //404</span><br><span class="line">fail.1              //&quot;File not found&quot;</span><br><span class="line"></span><br><span class="line">userInfo.name       //&quot;jianxiong&quot;</span><br><span class="line">userInfo.age        //22</span><br><span class="line">userInfo.email      //&quot;jianxiong1997@gmail.com&quot;</span><br></pre></td></tr></table></figure><h2 id="Tuple-Decomposition"><a href="#Tuple-Decomposition" class="headerlink" title="Tuple Decomposition"></a>Tuple Decomposition</h2><p>把一个 Tuple 的值 ，一一拆分到不同的变量上 ，叫做 Tuple Decomposition 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//: #### Tuple Decomposition</span><br><span class="line">let (successCode, successMessage) = success</span><br><span class="line">print(successCode)          //200</span><br><span class="line">print(successMessage)       //SUCCESS</span><br></pre></td></tr></table></figure><p>这里使用success 构建了一个新的 Tuple ，因此修改 successCode 和 successMessage 都不会对原有的 success 产生影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">successCode = 201</span><br><span class="line">successMessage = &quot;Created&quot;</span><br><span class="line">print(successCode)          //201</span><br><span class="line">print(successMessage)       //Created</span><br><span class="line">print(success)              //(200, &quot;SUCCESS&quot;)</span><br></pre></td></tr></table></figure><p>如果只是想要对应到 Tuple 中特定的成员 ，忽略其他成员 ， 可以采用 _ 来表示忽略的成员 ， 例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let (_ ,errorMessage) = fail</span><br><span class="line">print(errorMessage)         //&quot;File not found&quot;</span><br></pre></td></tr></table></figure><h2 id="Tuple-Type"><a href="#Tuple-Type" class="headerlink" title="Tuple Type"></a>Tuple Type</h2><p>每一个 Tuple 的类型 ， 都是有 Tuple 中所有成员决定的 。 例如 success 的类型 就是 (Int ,String) 。 当我们需要用 Type annotation 定义一个 Tuple 时 ， 我们可以这样写。这里不能通过指定命名来取值了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var airPodsInfo:(String ,Double ,String) = (name: &quot;商品名称&quot; ,money: 1168.8 ,mode: &quot;A2031&quot;)</span><br><span class="line">airPodsInfo.0       //&quot;商品名称&quot;</span><br><span class="line">airPodsInfo.1       //1168.8</span><br><span class="line">airPodsInfo.2       //A2031</span><br></pre></td></tr></table></figure><h2 id="Tuple-comparison"><a href="#Tuple-comparison" class="headerlink" title="Tuple comparison"></a>Tuple comparison</h2><p>当我们比较两个Tuple类型的变量时，要遵循下面的规则：</p><p>首先，只有元素个数相同的Tuple变量之间，才能进行比较。例如，下面的代码会引发编译错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let tuple1 = (1,2,3)</span><br><span class="line">let tuple2 = (1,2)</span><br><span class="line"></span><br><span class="line">tuple1 &gt; tuple2  //Binary operator &apos;&gt;&apos; cannot be applied to operands of type &apos;(Int, Int, Int)&apos; and &apos;(Int, Int)&apos;</span><br></pre></td></tr></table></figure><p>从上面的结果就能看到，包含两个Int的Tuple不能和包含三个Int的Tuple进行比较。<br>其次，当Tuple中元素个数相同时，比较是按照Tuple中元素的位置从前向后依次进行的：</p><ul><li>如果Tuple中，相同位置的两个元素相等，则继续比较下一个位置的两个元素，并根据第一个同一位置不相等的两个元素的大小关系，确定两个Tuple变量的关系；</li><li>如果两个Tuple中所有位置的元素都相等，则两个Tuple变量相等；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let tuple1 = (1,3)</span><br><span class="line">let tuple2 = (1,2)</span><br><span class="line"></span><br><span class="line">tuple1 &gt; tuple2  //true</span><br></pre></td></tr></table></figure><p>需要注意下 tuple 最多包含6个元素的Tuple变量进行比较，超过这个数量，Swift会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let tuple1 = (1,3,34,123,135,244,2)</span><br><span class="line">let tuple2 = (1,2,21,421,123,232,4)</span><br><span class="line"></span><br><span class="line">tuple1 &gt; tuple2  //Binary operator &apos;&gt;&apos; cannot be applied to two &apos;(Int, Int, Int, Int, Int, Int, Int)&apos; operands</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swift-Tuple&quot;&gt;&lt;a href=&quot;#Swift-Tuple&quot; class=&quot;headerlink&quot; title=&quot;Swift - Tuple&quot;&gt;&lt;/a&gt;Swift - Tuple&lt;/h1&gt;&lt;p&gt;相比于 Objective-C ，Swift 提供了一种新的
      
    
    </summary>
    
      <category term="Swift学习笔记" scheme="https://github.com/jianxiongc/categories/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="https://github.com/jianxiongc/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift - 整数和浮点数</title>
    <link href="https://github.com/jianxiongc/2019/07/30/Swift%20-%20%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    <id>https://github.com/jianxiongc/2019/07/30/Swift - 整数和浮点数/</id>
    <published>2019-07-30T12:34:22.000Z</published>
    <updated>2019-07-31T09:15:16.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift-整数和浮点数"><a href="#Swift-整数和浮点数" class="headerlink" title="Swift - 整数和浮点数"></a>Swift - 整数和浮点数</h1><p>Swift 中 ，数字分为整数 （例如 ：1 / 10 / 100 /1000 等） 和浮点数 （ 例如 ： 3.14 / 1.44 / 2.71 等）</p><h2 id="整形-Int-amp-UInt"><a href="#整形-Int-amp-UInt" class="headerlink" title="整形 - Int &amp; UInt"></a>整形 - Int &amp; UInt</h2><p>根据一个整形变量所占的内存空间 （8 / 16 / 32 /64-bit） 以及整数是否带有符号 （Unsinged） ， Swift 一共定义了8中不同类型的整数类型 :</p><ul><li>Int (8 / 16 / 32 / 64)</li><li>UInt (8 / 16 / 32 / 64)</li></ul><p>Int 的四个类型 分别表示 8 / 16 / 32 /64-bit 的有符号整数<br>UInt 的四个类型分别代表 8 / 16 / 32 /64-bit 的无符号整数</p><p>但在 Swift 中通常不会去指定具体的类型 ，Swift 编译器会根据目标编译平台 ，把 Int 或 UInt 转换成对应的整数。</p><p>在64位平台上 ，可以分别使用 min 和 max 方法，来查看在64位机器上整数类型可以表达的数值范围: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Int.max    //9223372036854775807</span><br><span class="line">Int.min    //-9223372036854775808</span><br><span class="line"></span><br><span class="line">Int64.max  //9223372036854775807</span><br><span class="line">Int64.min  //-9223372036854775807</span><br><span class="line"></span><br><span class="line">Int32.max  //2147483647</span><br><span class="line">Int32.min  //-2147483648</span><br><span class="line"></span><br><span class="line">Int8.max   //127</span><br><span class="line">Int8.min   //-128</span><br><span class="line"></span><br><span class="line">Int16.max  //32767</span><br><span class="line">Int16.min  //-32768</span><br><span class="line"></span><br><span class="line">UInt.max   //9223372036854775807</span><br><span class="line">UInt.min   //0</span><br><span class="line"></span><br><span class="line">UInt64.max //9223372036854775807</span><br><span class="line">UInt64.min //0</span><br><span class="line"></span><br><span class="line">UInt32.max //4294967295</span><br><span class="line">UInt32.min //0</span><br><span class="line"></span><br><span class="line">UInt8.max  //255</span><br><span class="line">UInt8.min  //0</span><br></pre></td></tr></table></figure><h2 id="整数的常用表达方式"><a href="#整数的常用表达方式" class="headerlink" title="整数的常用表达方式"></a>整数的常用表达方式</h2><p>在 Swift 里，我们可以用多种方式来表示一个整数。 包括使用 10 进制 、 16 进制  、 8 进制 、 2 进制: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let fifteenInDecimal = 10       //10</span><br><span class="line">let fiftennInHex = 0xff         //255</span><br><span class="line">let fifteenInOctal = 0o17       //15</span><br><span class="line">let fifteenInBinary = 0b0111    //7</span><br></pre></td></tr></table></figure><p>以及可以在数字中使用分隔符 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let inDecimal = 10       //10</span><br><span class="line">let inHex = 0xff         //255</span><br><span class="line">let inOctal = 0o17       //15</span><br><span class="line">let inBinary = 0b0111    //7</span><br><span class="line"></span><br><span class="line">let million = 1_000_000  //1000000</span><br></pre></td></tr></table></figure><p>除非我们所在硬件平台有特别明确的需求需要我们使用 <strong>UInt</strong> 来定义无符号整数 ， 否则我们应该尽可能使用 <strong>Int</strong> 来表达所有的整数类型 ， 哪怕我们确定一个整数一定是一个非负数。这会给我们减少很多不必要的类型转换的麻烦 。</p><h2 id="浮点型-Float-amp-Double"><a href="#浮点型-Float-amp-Double" class="headerlink" title="浮点型 Float &amp; Double"></a>浮点型 Float &amp; Double</h2><p>在 Swift 中 ，根据可以表达的精度范围，有两种不同的浮点类型 : </p><ul><li><strong>Float</strong> : 最多表达6位精度的浮点数</li><li><strong>Double</strong> : 至少可以表达15位精度的浮点数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let floatValue : Float = 1/3    //0.3333333</span><br><span class="line"></span><br><span class="line">let doubleValue : Double = 1/3  //0.3333333333333333</span><br></pre></td></tr></table></figure><p>除了使用常规的十进制表达浮点数之外 , 我们还可以使用科学计数法 。 例如 ，表示浮点数 PI :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var PI = 0.314e1    //3.14</span><br></pre></td></tr></table></figure><p>如果没有明确的需求，我们应该用Double来统一定义浮点数</p><h2 id="和数字有关的-Type-Inference"><a href="#和数字有关的-Type-Inference" class="headerlink" title="和数字有关的 Type Inference"></a>和数字有关的 Type Inference</h2><p>在 Swift 中 ，我们使用一个整数 ， 编译器会将它推导为 <strong>Int</strong> ， 使用一个浮点数 ，编译器会将它编译成 <strong>Double</strong><br>使用 <strong>type(of:)</strong> 查看一个变量或者常量的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let four = 5</span><br><span class="line">type(of: four)  //Int.Type</span><br><span class="line"></span><br><span class="line">let zeroPointFour = 0.5</span><br><span class="line">type(of: zeroPointFour) //Double.Type</span><br></pre></td></tr></table></figure><p>在 Swift 中 ，可以对不同类型数字的字面量进行计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let three = 2.8 + 0.2  //3</span><br><span class="line">type(of: three)        //Double.Type</span><br><span class="line"></span><br><span class="line">let four = 1 + 3       //4</span><br><span class="line">type(of: four)         //Int.Type</span><br></pre></td></tr></table></figure><p>但是在 Swift 中 ，不能把不同数字类型的变量直接进行算术运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let zeroPointOne = 0.1;</span><br><span class="line">let one = 1;</span><br><span class="line"></span><br><span class="line">let onePointOne = zeroPointOne + one  //Binary operator &apos;+&apos; cannot be applied to operands of type &apos;Double&apos; and &apos;Int&apos;</span><br></pre></td></tr></table></figure><p>当对变量进行算数运算的时候，所有变量的类型必须是相同的，如果变量类型不同，我们必须明确将其中的一些变量进行类型转换。像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let zeroPointOne = 0.1;</span><br><span class="line">let one = 1;</span><br><span class="line"></span><br><span class="line">let onePointOne = zeroPointOne + Double(one)  //1.1</span><br></pre></td></tr></table></figure><p>通过 Double(value) 重新初始化了一个 Double 类型的 one 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swift-整数和浮点数&quot;&gt;&lt;a href=&quot;#Swift-整数和浮点数&quot; class=&quot;headerlink&quot; title=&quot;Swift - 整数和浮点数&quot;&gt;&lt;/a&gt;Swift - 整数和浮点数&lt;/h1&gt;&lt;p&gt;Swift 中 ，数字分为整数 （例如 ：1 / 1
      
    
    </summary>
    
      <category term="Swift学习笔记" scheme="https://github.com/jianxiongc/categories/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="https://github.com/jianxiongc/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>蓝牙后台分析</title>
    <link href="https://github.com/jianxiongc/2019/07/24/iOS%E5%90%8E%E5%8F%B0%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/jianxiongc/2019/07/24/iOS后台分析/</id>
    <published>2019-07-23T23:12:12.000Z</published>
    <updated>2019-10-07T11:55:20.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蓝牙-iOS-后台分析"><a href="#蓝牙-iOS-后台分析" class="headerlink" title="蓝牙 iOS 后台分析"></a>蓝牙 iOS 后台分析</h1><hr><h3 id="iOS支持的后台方式"><a href="#iOS支持的后台方式" class="headerlink" title="iOS支持的后台方式:"></a>iOS支持的后台方式:</h3><h3 id="Audio-AirPlay-and-Picture-in-Picture"><a href="#Audio-AirPlay-and-Picture-in-Picture" class="headerlink" title="Audio, AirPlay and Picture in Picture"></a><strong>Audio, AirPlay and Picture in Picture</strong></h3><p>此个选项包含四种场景，分别是：音频的播放，录音，AirPlay 及画中画的视频播放。<br>音频的播放：在播放音频时，即使应用退到后台，只要一直有音频在播放，那应用就可以一直在后台运行。</p><p>代码实现可参考：<a href>http://www.linuxidc.com/Linux/2012-08/68364.htm</a></p><p>录音：应用可以请求使用麦克风，而当开启了此后台选项，应用在使用麦克风的时候，即使退到后台，也可以一直后台运行，通过查看微信安装包中的 plist 文件，微信的语音聊天，就是通过这种方式实现的。而当该类应用退到后台后，iOS 系统的状态栏会变成红色，并在状态栏中显示正在使用麦克风的应用的名称。</p><p>AirPlay：AirPlay 是指将 iOS 设备，或者 Mac 设备上的音视频，同步到另一个设备中播放。举两个例子，第一个是把 iPhone 上的音乐通过蓝牙的方式在汽车的蓝牙音响播放，第二个是把 iPhone 上的视频，同步到智能电视屏幕上播放。此功能一般用于多端及多屏的交互。<br>关于 AirPlay 的开发文档：<a href>http://nto.github.io/AirPlay.html</a></p><p>画中画的视频播放：画中画是 iPad 版本的 iOS 9 新增加的功能，可以在 iOS 的桌面，或者其他应用的界面的上面播放视频，从而该视频区域所属的应用就可以后台运行了。此功能现在只在 iPad 应用中提供。<br>代码实现可参考：<a href>http://www.cocoachina.com/ios/20150714/12558.html</a></p><h3 id="Location-updates"><a href="#Location-updates" class="headerlink" title="Location updates"></a>Location updates</h3><p>一般用于导航应用中，开启此选项后，应用退到后台，还可以得到系统的定位更新，从而使得应用可以根据定位的变化做出不同的反应。<br>代码实现可参考：<a href>https://github.com/voyage11/Location</a></p><h3 id="Voice-over-IP"><a href="#Voice-over-IP" class="headerlink" title="Voice over IP"></a>Voice over IP</h3><p>VOIP 类的应用允许用户使用网络而不是手机打电话，因此这一类的应用需要保持同它相关的服务的网络连接，用以收到来电事件和其他数据。iOS 不是通过一直让该应用处于激活状态来达到这个目的，而是同样也会将这类的应用挂起，但同时会在应用被挂起期间由系统接管它的 VOIP 的 Socket，当这个 Socket 有数据通信时，系统会再次唤醒处于挂起状态的应用，同时将 Socket 的控制权交还给该应用，以让其正常的处理来电事件和其他数据。</p><h3 id="Newsstand-downloads"><a href="#Newsstand-downloads" class="headerlink" title="Newsstand downloads"></a>Newsstand downloads</h3><p>在 iOS 开发中，有一类叫报刊杂志类应用比较特别，在 iOS 9 之前的系统中，此类应用会统一收在系统内置的「报刊杂志」应用中，在 iOS 9 中则去掉了内置的「报刊杂志」应用，此类应用得以以单独的图标入口出现在桌面中。<br>此后台运行的选项就是提供给报刊杂志类应用可以在后台下载及处理报刊杂志内容，而下载的过程需要使用 NewsstandKit 中的 NKAssetDownload 进行下载。需要注意的是，下载的过程中，应用可能还是会被挂起，甚至应用被退出，而 iOS 会在 Wi-Fi 环境下继续下载，直到下载完成。而一旦下载完成，如果应用只是被挂起，则 iOS 会唤醒对应的应用，回调对应的事件；如果应用已经退出，则会启动应用，在启动参数中会带上对应的标识表示这次启动是因为下载报刊杂志内容完成。<br>代码实现可参考：<a href>http://www.viggiosoft.com/blog/blog/2011/10/17/ios-newsstand-tutorial/</a></p><h3 id="External-Accessory-communication"><a href="#External-Accessory-communication" class="headerlink" title="External Accessory communication"></a>External Accessory communication</h3><p>此选项提供给一些 MFi 外设通过蓝牙，或者 Lightning 接头等方式与 iOS 设备连接，从而可在外设发送消息时，唤醒已经被挂起的应用。而一旦被唤醒，一般情况下， 应用只有最多 10 秒钟的执行时间。<br>MFi 外设：是指通过苹果 MFi 认证的设备，而 MFi 认证是对其授权配件厂商生产的外置配件的一种标识使用许可，是 Made for iOS 的英文缩写。</p><h3 id="Uses-Bluetooth-LE-accessories"><a href="#Uses-Bluetooth-LE-accessories" class="headerlink" title="Uses Bluetooth LE accessories"></a>Uses Bluetooth LE accessories</h3><p>此选项与 External Accessory communication 类似，只是此选项无需限制 MFi 外设，而需要的是 Bluetooth LE 设备。</p><h3 id="Acts-as-a-Bluetooth-LE-accessory"><a href="#Acts-as-a-Bluetooth-LE-accessory" class="headerlink" title="Acts as a Bluetooth LE accessory"></a>Acts as a Bluetooth LE accessory</h3><p>此选项是指 iOS 设备作为一个蓝牙外设连接时，对应的应用可以后台运行，但是使用此模式需要用户进行授权认证。</p><h3 id="Background-fetch"><a href="#Background-fetch" class="headerlink" title="Background fetch"></a>Background fetch</h3><p>iOS 7 新增加的一个选项，用于即使在后台，也需要频繁更新数据的应用。例如一个 PM2.5 的应用，需要几个小时更新一次数据，那么可以开启此选项，设置一个时间间隔，从而让 iOS 在间隔时间内在后台启动该应用，执行指定数据的获取工作，而此过程最多只能执行 30 秒钟。<br>代码实现可参考：<a href>http://objccn.io/issue-5-5/</a></p><h3 id="Remote-notifications"><a href="#Remote-notifications" class="headerlink" title="Remote notifications"></a>Remote notifications</h3><p>iOS 7 新增加的一个选项，是一种静默推送，它有别于一般的推送，应用收到此类推送后，不会有任何的界面提示，而当应用退出或者挂起时收到此类推送，iOS 也会启动或者唤醒对应的应用。<br>例如一个阅读应用，用户订阅的博客更新了，那么可以先发一个静默推送，应用收到此种推送后，可以先把用户订阅的博客内容都下载好，再通知用户，这样用户一打开应用就可以马上开始阅读。<br>收到静默推送，会回调对应的回调方法，而此回调方法最多只能执行 30 秒钟。<br>代码实现可参考：<a href>http://objccn.io/issue-5-5/</a></p><h3 id="基于-NSURLSession-的后台传输"><a href="#基于-NSURLSession-的后台传输" class="headerlink" title="基于 NSURLSession 的后台传输"></a>基于 NSURLSession 的后台传输</h3><p>此为 iOS 7 新增加的特性，用于在后台下载或者上传大文件，步骤如下：创建后台传输用的 NSURLSession 对象；向这个对象中加入对应的传输的 NSURLSessionTask，并开始传输；在实现 AppDelegate 里实现 -application:handleEventsForBackgroundURLSession:completionHandler: 方法，以刷新 UI 及通知系统传输结束。<br>一旦后台传输的状态发生变化（包括正常结束和失败）的时候，应用将被唤醒并运行 AppDelegate 中的回调。<br>但是也有一些限制，后台传输只会通过 Wi-Fi 来进行。后台下载的时间与以前的关闭应用后X分钟的模式不一样，而是为了节省电力变为离散式的下载。<br>代码实现可以参考：<a href>http://onevcat.com/2013/08/ios7-background-multitask/</a></p><h3 id="其他后台运行操作"><a href="#其他后台运行操作" class="headerlink" title="其他后台运行操作"></a>其他后台运行操作</h3><h4 id="一直循环播放一段没声音的音频"><a href="#一直循环播放一段没声音的音频" class="headerlink" title="一直循环播放一段没声音的音频"></a>一直循环播放一段没声音的音频</h4><p>可以在后台选项中选择「Audio, AirPlay and Picture in Picture」，而开始循环播放一段是没声音的音频，即在 Audio Unit 回调函数中使用 kAudioUnitRenderAction_OutputIsSilence 标志位，但是这种方式两个大的缺点：</p><ol><li>苹果的审核人员如果发现，会被拒；</li><li>应用程序的 Audio Session 不能被打断。当应用执行在后台时，只要另一个应用使用 kAudioSessionCategory_RecordAndPlay （比如 Skype）或者 kAudioSessionCategory_SoloAmbientSound，那么该应用就会被立即打断。<br>代码实现可参考：<a href>https://github.com/marcop/MMPDeepSleepPreventer</a></li></ol><h4 id="越狱下开发-System-级别的应用"><a href="#越狱下开发-System-级别的应用" class="headerlink" title="越狱下开发 System 级别的应用"></a>越狱下开发 System 级别的应用</h4><p>一般的应用都是 Mobile 级别的，在越狱的情况下，可以开发一个 System 级别的应用，从而使得应用不受 iOS 一般应用的限制，实现真正的后台运行，但是缺点就是应用只能运行在越狱设备上，也不能上 App Store。<br>代码实现可参考：<a href>http://www.cnblogs.com/doudouyoutang/p/4712331.html</a></p><h4 id="iOS-BackgroundMode-Documents参考链接"><a href="#iOS-BackgroundMode-Documents参考链接" class="headerlink" title="iOS BackgroundMode Documents参考链接:"></a>iOS BackgroundMode Documents参考链接:</h4><p><a href>https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html</a></p><h4 id="iOS-能耗参考"><a href="#iOS-能耗参考" class="headerlink" title="iOS 能耗参考:"></a>iOS 能耗参考:</h4><p><a href="http://pv0t5k9bg.bkt.clouddn.com/238_writing_energy_efficient_apps.pdf" target="_blank" rel="noopener">238_writing_energy_efficient_apps</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;蓝牙-iOS-后台分析&quot;&gt;&lt;a href=&quot;#蓝牙-iOS-后台分析&quot; class=&quot;headerlink&quot; title=&quot;蓝牙 iOS 后台分析&quot;&gt;&lt;/a&gt;蓝牙 iOS 后台分析&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;iOS支持的后台方式&quot;&gt;&lt;a href=&quot;#iO
      
    
    </summary>
    
    
      <category term="蓝牙 后台" scheme="https://github.com/jianxiongc/tags/%E8%93%9D%E7%89%99-%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>uni-app踩坑记录</title>
    <link href="https://github.com/jianxiongc/2019/07/22/uni-app%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://github.com/jianxiongc/2019/07/22/uni-app踩坑记录/</id>
    <published>2019-07-22T13:34:22.000Z</published>
    <updated>2019-07-22T13:35:36.127Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>注意像素尺寸 ,uni-app官方推荐用upx,小程序是rpx,weex是px，不要弄混了。<a href="https://uniapp.dcloud.io/frame?id=%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D" target="_blank" rel="noopener">https://uniapp.dcloud.io/frame?id=%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D</a></p></li><li><p>注意HBudiler 保存代码机制，默认代码不会保存，记得随手写完command/ctrl + s,编译时检查代码是否都保存了</p></li><li><p>image 标签一定要设置高度和宽度，100%  或者 绝对定位都是无效的。地图也一样。 image标签里边不要套text等标签了，不生效；</p></li><li><p>uni-app同小程序一样 display 默认不是flex,所以在使用到flex的特性是 需要加上display:flex。</p></li><li><p>有些情况下需要获取全屏高度，但是不能使用flex:1 或者 abosulte的方式。这个时候可以采用 获取 系统屏幕宽度  / 750 * 系统屏幕高度。代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const systemInfo = uni.getSystemInfoSync();</span><br><span class="line">if (systemInfo.windowWidth &amp;&amp; systemInfo.windowHeight) &#123;</span><br><span class="line">let multiple = 750/systemInfo.windowWidth;</span><br><span class="line">that.screenHeight = systemInfo.windowHeight * multiple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>uniapp 给Data赋值时和微信小程序的区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    value: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//小程序采用</span><br><span class="line">this.setData(&#123;</span><br><span class="line">  value: 1</span><br><span class="line">&#125;)</span><br><span class="line">//uni-app</span><br><span class="line">this.value = 1;</span><br></pre></td></tr></table></figure></li><li><p>uni-app map的 controls 中 position 使用的是px，而外部css使用的upx,这里要注意不要写成upx的值了。 并且position 只支持了 top 和 left定位。 如果要bottom 的话 需要先计算屏幕高度，然后再更改一次正确的位置。默认可以给 iPhone 7标准尺寸的 绝对定位。</p></li><li><p>cover-view 或者 cover-image 支持position 但同样  只支持top 和 left 。需要写 bottom 同 7。</p></li><li><p>iconfont 的使用方式与小程序不同 ，跟weex方式差不多，需要注意copy下来的地址加协议头。<a href="https://uniapp.dcloud.io/frame?id=%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87" target="_blank" rel="noopener">https://uniapp.dcloud.io/frame?id=%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87</a>， text支持  ,cover-view 在模拟器显示 真机不显示</p></li><li><p><map> 标签中的@regionchange  不触发</map></p><blockquote><p>官方说明：事件映射表中没有的原生事件也可以使用，例如map组件的regionchange 事件直接在组件上写成 @regionchange,同时这个事件也非常特殊，它的 event type 有 begin 和 end 两个，导致我们无法在handleProxy 中区分到底是什么事件，所以你在监听此类事件的时候同时监听事件名和事件类型既 &lt;map @regionchange=”functionName” @end=”functionName” @begin=”functionName”&gt;<map>。</map></p></blockquote></li><li><p>uni-app 官方文档中 map并没有支持多边形，但仍然可以按照微信小程序的方式实现。</p></li><li><p>支付宝小程序 如果不是在首页 ，左上角会始终出现返回按钮或者回到主页按钮，不建议在小程序中添加启动页面， 原有启动逻辑可以放在App生命周期中。</p></li><li><p>支付宝小程序想设置navigationBar自定义，文档中并未说明，但在示例Demo中发现 通过页面json文件，”transparentTitle”: “auto”可以实现navigationBar的自定义 ，但是要注意支付宝左上角会有按钮。</p></li><li><p>注意：以:style=””这样的方式设置px像素值，其值为实际像素，不会被编译器转换。</p></li><li><p>非H5端不支持 <a href="https://cn.vuejs.org/v2/guide/class-and-style.html" target="_blank" rel="noopener">Vue官方文档：Class 与 Style 绑定</a> 中的 classObject 和 styleObject 语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//不支持示例</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;view :class=&quot;[activeClass]&quot; :style=&quot;[baseStyles,overridingStyles]&quot;&gt;&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                activeClass: &#123;</span><br><span class="line">                    &apos;active&apos;: true,</span><br><span class="line">                    &apos;text-danger&apos;: false</span><br><span class="line">                &#125;,</span><br><span class="line">                baseStyles: &#123;</span><br><span class="line">                    color: &apos;green&apos;,</span><br><span class="line">                    fontSize: &apos;30px&apos;</span><br><span class="line">                &#125;,</span><br><span class="line">                overridingStyles: &#123;</span><br><span class="line">                    &apos;font-weight&apos;: &apos;bold&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><p>### </p><ol><li>iconfont 不显示</li></ol><ul><li>看看css文件中是否导入 font-face</li><li>text 的class中是否有font-family</li><li>iconfont文件中是否这个图标</li><li>css是否存在同名的 iconfont class.</li></ul><ol><li>css 标签选择器设置的属性可能权重过大，导致后面的类选择器无法覆盖它所设置的属性</li><li>uni-app button标签 自带了border属性 ，如果要去掉 参考<a href="http://ask.dcloud.net.cn/question/62262" target="_blank" rel="noopener">http://ask.dcloud.net.cn/question/62262</a></li><li>v-for 中 @click 带参数，必须设置key ，不然click的参数会为空</li><li>map 中绘制线，一定要注意polyline 类型是Array, 虽然它里面是一个Object,但是最外层一定要变成Array，不然会无法显示</li><li>data中声明 mpType的变量，会导致所有的Data设置失效。官方文档并没有将其保留为关键字，但是他的存在确实是所有的Data赋值失效了。主要是与App.mpType冲突，注意下这个坑。 </li><li>mac和windows 下 uni-requset  的Promise支持可能不一致代码如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uni.request().then(data =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;).catch(error =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>这段代码在Windows下编译并能正常执行到iOS ，Andorid的微信小程序端。在Mac 下编译会报 ui-request…then not functoin 。已提交issuse  <a href="https://github.com/dcloudio/uni-app/issues/351">https://github.com/dcloudio/uni-app/issues/351</a></p><ol><li>uni-bluetooth ， 注意外围设备的services 和characteristic  在iOS 都是大写，在android 都是小写。 注意 createConnection 后还需要discoverServices 和 discovcerCharacteristics 。</li><li>map marker . label = {} 时Android 会出现小蓝点，iOS不会。设置marker的label 为null可以解决。</li><li>微信小程序下，怀疑relaunch页面跳转没有清除， 具体表现为在B页面设置蓝牙状态监听，relaunch 到 C页面，B页面依然能打印蓝牙状态监听的log<a href="https://developers.weixin.qq.com/community/develop/doc/0000e8551d0f309fadc8b123751000?fromCreate=1" target="_blank" rel="noopener">https://developers.weixin.qq.com/community/develop/doc/0000e8551d0f309fadc8b123751000?fromCreate=1</a></li><li>小程序的triggerEvent在uniapp中不支持；</li><li>uni-app 中在data使用 Object.assgin 一定要加在Data中的最后一行，不然小程序会在iOS 9.3的机器上出现白屏问题。目前不清楚是小程序的问题还是uni-app的问题。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;注意像素尺寸 ,uni-app官方推荐用upx,小程序是rpx,weex是px，不要弄混了。&lt;a href=&quot;https://uniapp.dcloud.io/frame?id=%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D&quot; t
      
    
    </summary>
    
    
      <category term="uni-app 微信小程序" scheme="https://github.com/jianxiongc/tags/uni-app-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构基础-数组</title>
    <link href="https://github.com/jianxiongc/2019/07/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80-%E6%95%B0%E7%BB%84/"/>
    <id>https://github.com/jianxiongc/2019/07/21/数据结构基础-数组/</id>
    <published>2019-07-20T23:19:07.000Z</published>
    <updated>2019-10-21T07:08:50.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构基础-数组"><a href="#数据结构基础-数组" class="headerlink" title="数据结构基础 - 数组"></a>数据结构基础 - 数组</h1><p>什么是数组？<br>数组对应的英文是Array ， 是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。数组是最为简单，最为常用的数据结构。<br>已整数数组为例，数组的存储形式如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/21/数据结构基础-数组/media/1.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>数组里每一个元素都有自己的下标，这个下标从0开始，一直到数组长度-1.</p><p>数组的另一个特点，就是在程序中顺序存储，因此可以很好的实现逻辑上的顺序表。<br>数组在内存中的顺序存储，具体是什么样子呢。</p><p>内存是由一个个连续的内存单元组成的，每一个内存单元都有自己的地址。在这些内存单元中，有些被其他数据占用了，有些是空闲的。</p><p>数组的每一个元素，都存储在内存单元中，并且元素之间精密排列，即不能打乱元素的存储顺序，也不能跳过过个存储单元进行存储。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/21/数据结构基础-数组/media/2.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在上图中，橙色的格子代表空闲的存储单元，灰色的格子代表已占用的存储单元，而蓝色的连续格子代表数组在内存中的位置。<br>不同类型的数组，每个元素所占的字节个数也不同，本图只是一个简单的示意图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构基础-数组&quot;&gt;&lt;a href=&quot;#数据结构基础-数组&quot; class=&quot;headerlink&quot; title=&quot;数据结构基础 - 数组&quot;&gt;&lt;/a&gt;数据结构基础 - 数组&lt;/h1&gt;&lt;p&gt;什么是数组？&lt;br&gt;数组对应的英文是Array ， 是有限个相同类型的变量所
      
    
    </summary>
    
      <category term="算法学习笔记" scheme="https://github.com/jianxiongc/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Array" scheme="https://github.com/jianxiongc/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Swift - 变量与常量</title>
    <link href="https://github.com/jianxiongc/2019/07/20/Swift%20-%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/"/>
    <id>https://github.com/jianxiongc/2019/07/20/Swift - 变量与常量/</id>
    <published>2019-07-20T15:20:04.000Z</published>
    <updated>2019-07-31T09:15:35.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift-变量与常量"><a href="#Swift-变量与常量" class="headerlink" title="Swift - 变量与常量"></a>Swift - 变量与常量</h1><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量是编程语言中最常用的语法元素，它们用于在程序中把一个名字（例如：swiftString）和某种特定类型的值（例如：”Swift is fun.”）关联起来。</p><p>在Swift中，我们使用关键字 <strong>var</strong> 来定义各种不同的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var hello = &quot;你好&quot;</span><br></pre></td></tr></table></figure><p>例如，定义一些熟悉的基本类型变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//: #### Fundamental types</span><br><span class="line"></span><br><span class="line">//: Integer</span><br><span class="line">var hours = 24</span><br><span class="line"></span><br><span class="line">//: Double</span><br><span class="line">var PI = 3.14</span><br><span class="line"></span><br><span class="line">//: Bool</span><br><span class="line">var swiftIsFun = true</span><br><span class="line"></span><br><span class="line">//: String</span><br><span class="line">var hello = &quot;你好&quot;</span><br></pre></td></tr></table></figure><p>除了基本类型变量之外，Swift 还有 <strong>Tuple</strong> ,多类型数据混合到一个数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//: Tuple - Pack many types of values together</span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">var me = (&quot;name&quot;,&quot;jianxiong&quot;,[&quot;like&quot; : [&quot;code&quot;,&quot;code2&quot;,&quot;code3&quot;]],18)</span><br><span class="line"></span><br><span class="line">me.0  //&quot;name&quot;</span><br><span class="line"></span><br><span class="line">me.1  //&quot;jianxiong&quot;</span><br><span class="line"></span><br><span class="line">me.2  //[&quot;like&quot; : [&quot;code&quot;,&quot;code2&quot;,&quot;code3&quot;]]</span><br><span class="line"></span><br><span class="line">me.3  //18</span><br></pre></td></tr></table></figure><p>定义好一个Tuple之后，就可以使用代码 me.0 me.1 me.2 这样的方式来访问Tuple中的变量了，同时也可以直接修改变量的值 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// update Tuple value</span><br><span class="line">me.3 = 22</span><br><span class="line"></span><br><span class="line">var hour = 24 </span><br><span class="line">hour = 12</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="如果我们定义的值不希望被修改"><a href="#如果我们定义的值不希望被修改" class="headerlink" title="如果我们定义的值不希望被修改"></a>如果我们定义的值不希望被修改</h3><p>定义常量的方法和变量类似，我们把关键字<strong>var</strong>，变成关键字<strong>let</strong>就可以了。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let minutes = 30</span><br><span class="line">let fireIsHot = true</span><br></pre></td></tr></table></figure><p>一旦我们定义常量之后，就不能再修改常量的值了，否则，编译器会告诉我们发生了错误。例如，我们修改常量fireIsHot：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fireIsHot = false</span><br></pre></td></tr></table></figure><p>这时，我们就可以在Playground中直接看到一个编译错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot assign to value: &apos;firelsHot&apos; is a &apos;let&apos; constant</span><br></pre></td></tr></table></figure><p>只要程序中的变量值不会被修改，就总应该使用let来定义它。这不仅可以防止变量被意外修改，编译器还可以针对常量做更多优化。</p><h2 id="Type-inference-annotation"><a href="#Type-inference-annotation" class="headerlink" title="Type inference / annotation"></a>Type inference / annotation</h2><p>在前面的例子里，我们可以发现，无论是整数、浮点数、字符串还有Tuple，我们都没有明确的指定变量的类型， Swift编译器会根据我们为变量的赋值自动推导变量的类型，这个特性，在Swift里叫做Type Inference。</p><p>但有时，我们定义变量的时候，并不能确定变量的初始值，这个时候，我们就必须像下面这样明确告诉编译器我们需要的变量类型：var Name:Type。这种通过:Type指定变量类型的形式，在Swift中叫做Type annotation。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x: Int</span><br><span class="line">var s: String</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swift-变量与常量&quot;&gt;&lt;a href=&quot;#Swift-变量与常量&quot; class=&quot;headerlink&quot; title=&quot;Swift - 变量与常量&quot;&gt;&lt;/a&gt;Swift - 变量与常量&lt;/h1&gt;&lt;h2 id=&quot;变量和常量&quot;&gt;&lt;a href=&quot;#变量和常量&quot; c
      
    
    </summary>
    
      <category term="Swift学习笔记" scheme="https://github.com/jianxiongc/categories/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="https://github.com/jianxiongc/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>协程 阿里开源库 coobjc 初步分析</title>
    <link href="https://github.com/jianxiongc/2019/07/16/%E5%8D%8F%E7%A8%8B-%E9%98%BF%E9%87%8C%E5%BC%80%E6%BA%90%E5%BA%93-coobjc-%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/</id>
    <published>2019-07-16T02:09:24.000Z</published>
    <updated>2019-10-21T13:52:23.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><em>协程是计算机程序的一类组件，推广了非抢先多任务的子程序，允许执行被挂起与被恢复。</em><br><em>相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。</em><br><em>协程源自 Simula 和 Modula-2 语言，但也有其他语言支持。</em><br><em>协程更适合于用来实现彼此熟悉的程序组件，如合作式多任务、异常处理、事件循环、迭代器、无限列表和管道。</em><br><em>根据高德纳的说法, 马尔文·康威于1958年发明了术语 coroutine 并用于构建汇编程序。</em><br><em>—— Wikipedia</em></p><h2 id="coobjc-解决的问题"><a href="#coobjc-解决的问题" class="headerlink" title="coobjc 解决的问题"></a>coobjc 解决的问题</h2><h3 id="iOS-异步编程问题"><a href="#iOS-异步编程问题" class="headerlink" title="iOS 异步编程问题"></a>iOS 异步编程问题</h3><p>官网描述:</p><p>基于 Block 的异步编程回调是目前 iOS 使用最广泛的异步编程方式，iOS 系统提供的 GCD 库让异步开发变得很简单方便，但是基于这种编程方式的缺点也有很多，主要有以下几点：</p><p>容易进入”嵌套地狱”<br>错误处理复杂和冗长<br>容易忘记调用 completion handler<br>条件执行变得很困难<br>从互相独立的调用中组合返回结果变得极其困难<br>在错误的线程中继续执行<br>难以定位原因的多线程崩溃<br>锁和信号量滥用带来的卡顿、卡死<br>上述问题反应到线上应用本身就会出现大量的多线程崩溃</p><h3 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h3><p>官网描述:</p><p><strong>简明</strong><br>概念少：只有很少的几个操作符，相比响应式几十个操作符，简直不能再简单了<br>原理简单: 协程的实现原理很简单，整个协程库只有几千行代码<br><strong>易用</strong><br>使用简单：它的使用方式比 GCD 还要简单，接口很少<br>改造方便：现有代码只需要进行很少的改动就可以协程化，同时我们针对系统库提供了大量协程化接口<br><strong>清晰</strong><br>同步写异步逻辑：同步顺序方式写代码是人类最容易接受的方式，这可以极大的减少出错的概率<br>可读性高: 使用协程方式编写的代码比 block 嵌套写出来的代码可读性要高很多<br><strong>性能</strong><br>调度性能更快：协程本身不需要进行内核级线程的切换，调度性能快，即使创建上万个协程也毫无压力<br>减少卡顿卡死: 协程的使用以帮助开发减少锁、信号量的滥用，通过封装会引起阻塞的 IO 等协程接口，可以从根源上减少卡顿、卡死，提升应用整体的性能</p><h3 id="核心能力"><a href="#核心能力" class="headerlink" title="核心能力"></a>核心能力</h3><p>提供了类似C#和Javascript语言中的Async/Await编程方式支持，在协程中通过调用await方法即可同步得到异步方法的执行结果，非常适合IO、网络等异步耗时调用的同步顺序执行改造。<br>提供了类似Kotlin中的Generator功能，用于懒计算生成序列化数据，非常适合多线程可中断的序列化数据生成和访问。<br>提供了Actor Model的实现，基于Actor Model，开发者可以开发出更加线程安全的模块，避免由于直接函数调用引发的各种多线程崩溃问题。<br>提供了元组的支持，通过元组Objective-C开发者可以享受到类似Python语言中多值返回的好处。</p><h3 id="内置系统扩展库"><a href="#内置系统扩展库" class="headerlink" title="内置系统扩展库"></a>内置系统扩展库</h3><ul><li><p>提供了对NSArray、NSDictionary等容器库的协程化扩展，用于解决序列化和反序列化过程中的异步调用问题。</p></li><li><p>提供了对NSData、NSString、UIImage等数据对象的协程化扩展，用于解决读写IO过程中的异步调用问题。</p></li><li><p>提供了对NSURLConnection和NSURLSession的协程化扩展，用于解决网络异步请求过程中的异步调用问题。</p></li><li><p>提供了对NSKeyedArchieve、NSJSONSerialization等解析库的扩展，用于解决解析过程中的异步调用问题。</p></li></ul><h3 id="coobjc-设计"><a href="#coobjc-设计" class="headerlink" title="coobjc 设计"></a>coobjc 设计</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/1.png" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure><p>最底层是协程内核，包含了栈切换的管理、协程调度器的实现、协程间通信channel的实现等。<br>中间层是基于协程的操作符的包装，目前支持async/await、Generator、Actor等编程模型。<br>最上层是对系统库的协程化扩展，目前基本上覆盖了Foundation和UIKit的所有IO和耗时方法。</p><h3 id="核心实现原理"><a href="#核心实现原理" class="headerlink" title="核心实现原理"></a>核心实现原理</h3><p>协程的核心思想是控制调用栈的主动让出和恢复。一般的协程实现都会提供两个重要的操作：</p><p>Yield：是让出cpu的意思，它会中断当前的执行，回到上一次Resume的地方。<br>Resume：继续协程的运行。执行Resume后，回到上一次协程Yield的地方。</p><p>我们基于线程的代码执行时候，是没法做出暂停操作的，我们现在要做的事情就是要代码执行能够暂停，还能够再恢复。 基本上代码执行都是一种基于调用栈的模型，所以如果我们能把当前调用栈上的状态都保存下来，然后再能从缓存中恢复，那我们就能够实现yield和 resume。<br>实现这样操作有几种方法呢？</p><p>第一种：利用glibc 的 ucontext组件(云风的库)。<br>第二种：使用汇编代码来切换上下文(实现c协程)，原理同ucontext。<br>第三种：利用C语言语法switch-case的奇淫技巧来实现（Protothreads)。<br>第四种：利用了 C 语言的 setjmp 和 longjmp。<br>第五种：利用编译器支持语法糖。</p><p>上述第三种和第四种只是能过做到跳转，但是没法保存调用栈上的状态，看起来基本上不能算是实现了协程，只能算做做demo，第五种除非官方支持，否则自行改写编译器通用性很差。而第一种方案的 ucontext 在iOS上是废弃了的，不能使用。那么我们使用的是第二种方案，自己用汇编模拟一下 ucontext。<br>模拟ucontext的核心是通过getContext和setContext实现保存和恢复调用栈。需要熟悉不同CPU架构下的调用约定(Calling Convention). 汇编实现就是要针对不同cpu实现一套，我们目前实现了 armv7、arm64、i386、x86_64，支持iPhone真机和模拟器。</p><h2 id="官方例子"><a href="#官方例子" class="headerlink" title="官方例子"></a>官方例子</h2><p>整体结构如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/3.jpg" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure><ul><li><strong>cokit</strong>       cokit库为Foundation和UIKit系统库提供了一个协程封装，它依赖于coobjc库，为IO，网络等耗时的方法提供协同处理的封装。</li><li><strong>coobjc</strong>    coobjc的Objective-C版实现的源代码</li><li>*<em>coswift  *</em> coswift的Swift版源代码</li><li><strong>Examples</strong>    coobjcBaseExample是OC版本的Demo    coSwiftExample是OC版本的Demo    <h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3>直接看看coobjcBaseExample的效果<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/4.jpg" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure></li></ul><p>这个界面可以看到一个简单的列表页。<br>对应到代码中的<strong>KMDiscoverListViewController</strong><br>ViewDidLoad中有如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [self setupTableView];</span><br><span class="line">    [self requestMovies];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法名可以得知，<strong>requestMovies</strong>实现了网络拉取电影列表的功能。<br>看 <strong>requestMovies</strong> 中的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)requestMovies</span><br><span class="line">&#123;</span><br><span class="line">    co_launch(^&#123;</span><br><span class="line">        NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;];</span><br><span class="line">        [self.refreshControl endRefreshing];</span><br><span class="line">        </span><br><span class="line">        if (dataArray != nil)</span><br><span class="line">        &#123;</span><br><span class="line">            [self processData:dataArray];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            [self.networkLoadingViewController showErrorView];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先抛开co_launch不管，可以发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;];</span><br></pre></td></tr></table></figure><p>实现了网络请求，获取数据，<strong>getDiscoverList</strong>实现代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray*)getDiscoverList:(NSString *)pageLimit;</span><br><span class="line">&#123;</span><br><span class="line">    NSString *url = [NSString stringWithFormat:@&quot;%@&amp;page=%@&quot;, [self prepareUrl], pageLimit];</span><br><span class="line">    id json = [[DataService sharedInstance] requestJSONWithURL:url];</span><br><span class="line">    NSDictionary* infosDictionary = [self dictionaryFromResponseObject:json jsonPatternFile:@&quot;KMDiscoverSourceJsonPattern.json&quot;];</span><br><span class="line">    return [self processResponseObject:infosDictionary];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码可以发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id json = [[DataService sharedInstance] requestJSONWithURL:url];</span><br></pre></td></tr></table></figure><p>这一段实现了网络请求，然后继续去进入<strong>requestJSONWithURL</strong>去看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (id)requestJSONWithURL:(NSString*)url CO_ASYNC&#123;</span><br><span class="line">    SURE_ASYNC</span><br><span class="line">    return await([self.jsonActor sendMessage:url]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候发现 <strong>SURE_ASYNC</strong> 和 <strong>awiat</strong> 类似于<strong>ES7</strong>中的<strong>async</strong> 和 <strong>await</strong>，<strong>ES7</strong>中<strong>async-await</strong>是<strong>promise</strong>和<strong>generator</strong>的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性，看起来这块起到了类似的作用。<br>再来仔细了解下协程。</p><h3 id="协程入门"><a href="#协程入门" class="headerlink" title="协程入门"></a>协程入门</h3><p>上面的<strong>核心实现原理</strong>中有提到，实现核心的<strong>yield</strong>和<strong>resume</strong>有五种方法，<br>其中说到第三、四种只能做到过跳转，没办法保存调用栈,无法真正的实现协程。第五种除非官方支持。第一种ucontext在iOS是废弃了的。那么第二种方案，自己用汇编模拟ucontext。</p><p>首先，ucontext 是啥？</p><p><strong>ucontext</strong> 机制是<strong>GUN C</strong>库提供的一组用于创建、保存、切换用户态执行context的API。主要包括以下四个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);</span><br><span class="line">int swapcontext(ucontext_t *oucp, ucontext_t *ucp);</span><br><span class="line">int getcontext(ucontext_t *ucp);</span><br><span class="line">int setcontext(const ucontext_t *ucp);</span><br></pre></td></tr></table></figure><p>详细参见<br>[我所理解的ucontext族函数]<a href="https://www.jianshu.com/p/dfd7ac1402f0" target="_blank" rel="noopener">https://www.jianshu.com/p/dfd7ac1402f0</a><br>[构建C协程之ucontext篇]<a href="https://blog.csdn.net/gettogetto/article/details/53306897" target="_blank" rel="noopener">https://blog.csdn.net/gettogetto/article/details/53306897</a></p><p>来看一段简单的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">//由于在Mac OS X 10.6.6 ucontext被弃用的关系 ，需要使用sys/ucontext.h</span><br><span class="line">#include &lt;sys/ucontext.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">// ----&gt; ucontext </span><br><span class="line">ucontext_t context;</span><br><span class="line">getcontext(&amp;context);</span><br><span class="line">puts(&quot;Hello world&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line">setcontext(&amp;context);</span><br><span class="line"></span><br><span class="line">// ----&gt; goto </span><br><span class="line">// loop: puts(&quot;%s\n&quot;,&quot;Hello world&quot;);</span><br><span class="line">//     sleep(1);</span><br><span class="line">//     goto loop;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存上述代码到 example.c，执行编译命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc example.c -o example</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/5.jpg" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure><p>可以看到这里会不断执行，通过setcontext和getcontext实现切换。<br>更详细参见<br><a href="https://www.jianshu.com/p/dfd7ac1402f0" target="_blank" rel="noopener">我所理解的ucontext族函数</a><br><a href="https://blog.csdn.net/gettogetto/article/details/53306897" target="_blank" rel="noopener">构建C协程之ucontext篇</a><br>上面<strong>核心实现原理</strong>中讲到了第二种：使用汇编代码来切换上下文(实现c协程)，原理同ucontext。<br>我们在coobjc中的库中发现了唯一一个汇编文件<strong>coroutine_context.s</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://uploader.shimo.im/f/O0mWE5ILsUwn44oQ.jpg!thumbnail" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure><p>在汇编文件中发现主要提供了三个方法</p><ul><li>_coroutine_getcontext</li><li>_coroutine_begin</li><li>_coroutine_setcontext</li></ul><p>同样在 <strong>coroutine_context.h</strong>中暴露了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern int coroutine_getcontext (coroutine_ucontext_t *__ucp);</span><br><span class="line"></span><br><span class="line">extern int coroutine_setcontext (coroutine_ucontext_t *__ucp);</span><br><span class="line">extern int coroutine_begin (coroutine_ucontext_t *__ucp);</span><br><span class="line"></span><br><span class="line">extern void coroutine_makecontext (coroutine_ucontext_t *__ucp, IMP func, void *arg, void *stackTop);</span><br></pre></td></tr></table></figure><p>其中<strong>coroutine_makecontext</strong>在<strong>coroutine_context.m</strong>中实现<br>回到例子中<br><strong>co_launch</strong> 来自 <strong>coobjc.h</strong> ,来关注一下<strong>coobjc.h</strong> 里的内联函数</p><ul><li>co_launch 创建一个协程，然后在当前线程中异步恢复它</li><li>co_launch_now 创建一个协程，然后在当前线程立即恢复它</li><li>co_launch_withStackSize 创建一个协程，然后在当前线程中异步恢复它，与co_launch不同 ，他可以设定堆栈大小 默认为65536 最大限制为1M</li><li>co_launch_onqueue 创建一个协程，并在给定的线程中异步恢复它</li><li>co_sequence 创建一个生成器</li><li>co_sequence_onqueue 在指定的线程中创建一个生成器</li><li>co_actor 创建一个容器</li><li>co_actor_onqueue 在指定线程中创建一个容器</li><li>await 用await得到异步执行的结果，等待异步方法的执行</li><li>batch_await 批量的await 目前没找到哪里用</li><li>co_delay 使当前协程sleep 多少秒</li><li>co_isActive 判断一个协程是否有效</li><li>co_isCancelled 检查当前协程是否取消</li></ul><p>其他的一些宏定义</p><ul><li>CO_ASYNC 给方法一个标记，表示方法是可被暂停的，类似于JS中 async</li><li>SURE_ASYNC 断言</li><li>yield 暂停</li></ul><p>在看看用到的<strong>co_launch</strong> 文档描述在当前线程中创建协程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)requestMovies</span><br><span class="line">&#123;</span><br><span class="line">    //创建协程</span><br><span class="line">    co_launch(^&#123;</span><br><span class="line">        //进行网络加载，但并没有在这里进行await</span><br><span class="line">        NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;];</span><br><span class="line">        [self.refreshControl endRefreshing];</span><br><span class="line">        </span><br><span class="line">        if (dataArray != nil)</span><br><span class="line">        &#123;</span><br><span class="line">            [self processData:dataArray];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><pre><code>else</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        &#123;</span><br><span class="line">            [self.networkLoadingViewController showErrorView];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着往下看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在这里写了CO_ASYNC 表示该方法是可以被暂停的 同时在方法内await等待异步的结果</span><br><span class="line">- (id)requestJSONWithURL:(NSString*)url CO_ASYNC&#123;</span><br><span class="line">    SURE_ASYNC</span><br><span class="line">    return await([self.jsonActor sendMessage:url]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看看 <strong>self.jsonActor</strong> 及  <strong>sendMessage</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">jsonActor 是一个COActor 的对象，文档中描述</span><br><span class="line">_ Actor 的概念来自于 Erlang ，在 AKKA 中，可以认为一个 Actor 就是一个容器，用以存储状态、行为、Mailbox 以及子 Actor 与 Supervisor 策略。Actor 之间并不直接通信，而是通过 Mail 来互通有无。_</span><br><span class="line">*/</span><br><span class="line">@property (nonatomic, strong) COActor *jsonActor;</span><br></pre></td></tr></table></figure><p>此时看到 DataService.m中有init 注册了接受消息的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_jsonActor = co_actor_onqueue(_jsonQueue, ^(COActorChan *channel) &#123;</span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    id json = nil;</span><br><span class="line">    COActorCompletable *completable = nil;</span><br><span class="line">    for (COActorMessage *message in channel) &#123;</span><br><span class="line">        NSString *url = [message stringType];</span><br><span class="line">        json = nil;</span><br><span class="line">        if (url.length &gt; 0) &#123;</span><br><span class="line">            //这里接受到消息之后将消息发送到 networkActor</span><br><span class="line">            completable = [self.networkActor sendMessage:url];</span><br><span class="line">            data = await(completable);</span><br><span class="line">            if (data) &#123;</span><br><span class="line">                json = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];</span><br><span class="line">            &#125;</span><br><span class="line">            message.complete(json);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            message.complete(nil);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>收到消息后将json的消息回复到上层。展示数据</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p>[阿里云栖社区对coobjc介绍]<a href="https://www.jianshu.com/p/cd7f6ef5a8fd" target="_blank" rel="noopener">https://www.jianshu.com/p/cd7f6ef5a8fd</a><br>[我所理解的ucontext族函数]<a href="https://www.jianshu.com/p/dfd7ac1402f0" target="_blank" rel="noopener">https://www.jianshu.com/p/dfd7ac1402f0</a><br>[构建C协程之ucontext篇]<a href="https://blog.csdn.net/gettogetto/article/details/53306897" target="_blank" rel="noopener">https://blog.csdn.net/gettogetto/article/details/53306897</a><br>[理解 JavaScript 的 async/await]<a href="https://segmentfault.com/a/1190000007535316?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007535316?utm_source=tag-newest</a><br>[GC 7.1 Mac OS X 10.6.6: ucontext routines are deprecated]<a href="https://www.hpl.hp.com/hosted/linux/mail-archives/gc/2011-February/004354.html" target="_blank" rel="noopener">https://www.hpl.hp.com/hosted/linux/mail-archives/gc/2011-February/004354.html</a><br>[PSA: avoiding the “ucontext routines are deprecated” error on Mac OS X Snow Leopard]<a href="http://duriansoftware.com/joe/PSA%3a-avoiding-the-%22ucontext-routines-are-deprecated%22-error-on-Mac-OS-X-Snow-Leopard.html" target="_blank" rel="noopener">http://duriansoftware.com/joe/PSA%3a-avoiding-the-%22ucontext-routines-are-deprecated%22-error-on-Mac-OS-X-Snow-Leopard.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;em&gt;协程是计算机程序的一类组件，推广了非抢先多任务的子程序，允许执行被挂起与被恢复。&lt;/em&gt;&lt;br&gt;&lt;em&gt;相对子例程而言，协程更为一
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/jianxiongc/tags/iOS/"/>
    
  </entry>
  
</feed>
