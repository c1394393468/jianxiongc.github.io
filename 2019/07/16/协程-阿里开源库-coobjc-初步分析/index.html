<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>协程 阿里开源库 coobjc 初步分析 | Jianxiong</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="iOS">
    <meta name="description" content="简介协程是计算机程序的一类组件，推广了非抢先多任务的子程序，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程源自 Simula 和 Modula-2 语言，但也有其他语言支持。协程更适合于用来实现彼此熟悉的程序组件，如合作式多任务、异常处理、事件循环、迭代器、无限列表和管道。根据高德纳的说法, 马尔文·康威于1958年发明了术语 coroutine">
<meta name="keywords" content="iOS">
<meta property="og:type" content="article">
<meta property="og:title" content="协程 阿里开源库 coobjc 初步分析">
<meta property="og:url" content="https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/index.html">
<meta property="og:site_name" content="Jianxiong">
<meta property="og:description" content="简介协程是计算机程序的一类组件，推广了非抢先多任务的子程序，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程源自 Simula 和 Modula-2 语言，但也有其他语言支持。协程更适合于用来实现彼此熟悉的程序组件，如合作式多任务、异常处理、事件循环、迭代器、无限列表和管道。根据高德纳的说法, 马尔文·康威于1958年发明了术语 coroutine">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/1.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/3.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/4.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/5.jpg">
<meta property="og:image" content="https://uploader.shimo.im/f/O0mWE5ILsUwn44oQ.jpg!thumbnail">
<meta property="og:updated_time" content="2019-10-21T11:42:36.782Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="协程 阿里开源库 coobjc 初步分析">
<meta name="twitter:description" content="简介协程是计算机程序的一类组件，推广了非抢先多任务的子程序，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程源自 Simula 和 Modula-2 语言，但也有其他语言支持。协程更适合于用来实现彼此熟悉的程序组件，如合作式多任务、异常处理、事件循环、迭代器、无限列表和管道。根据高德纳的说法, 马尔文·康威于1958年发明了术语 coroutine">
<meta name="twitter:image" content="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/1.jpg">
    
        <link rel="alternate" type="application/atom+xml" title="Jianxiong" href="/blog/atom.xml">
    
    <link rel="shortcut icon" href="/blog/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/blog/img/carillustration.gif)">
      <div class="brand">
        <a href="/blog/" class="avatar waves-effect waves-circle waves-light">
          <img src="/blog/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Jianxiong</h5>
          <a href="mailto:jianxiong_1997@126.com" title="jianxiong_1997@126.com" class="mail">jianxiong_1997@126.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/blog/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/blog/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/blog/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/blog/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/jianxiongc" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/blog/custom"  >
                <i class="icon icon-lg icon-link"></i>
                还没想好放啥
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">协程 阿里开源库 coobjc 初步分析</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">协程 阿里开源库 coobjc 初步分析</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-07-16T02:09:24.000Z" itemprop="datePublished" class="page-time">
  2019-07-16
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#简介"><span class="post-toc-number">1.</span> <span class="post-toc-text">简介</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#coobjc-解决的问题"><span class="post-toc-number">2.</span> <span class="post-toc-text">coobjc 解决的问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#iOS-异步编程问题"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">iOS 异步编程问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#协程的优势"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">协程的优势</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#核心能力"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">核心能力</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#内置系统扩展库"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">内置系统扩展库</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#coobjc-设计"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">coobjc 设计</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#核心实现原理"><span class="post-toc-number">2.6.</span> <span class="post-toc-text">核心实现原理</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#官方例子"><span class="post-toc-number">3.</span> <span class="post-toc-text">官方例子</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#项目运行"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">项目运行</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#协程入门"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">协程入门</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考阅读"><span class="post-toc-number">4.</span> <span class="post-toc-text">参考阅读</span></a></li></ol>
        </nav>
    </aside>


<article id="post-协程-阿里开源库-coobjc-初步分析"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">协程 阿里开源库 coobjc 初步分析</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-07-16 10:09:24" datetime="2019-07-16T02:09:24.000Z"  itemprop="datePublished">2019-07-16</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><em>协程是计算机程序的一类组件，推广了非抢先多任务的子程序，允许执行被挂起与被恢复。</em><br><em>相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。</em><br><em>协程源自 Simula 和 Modula-2 语言，但也有其他语言支持。</em><br><em>协程更适合于用来实现彼此熟悉的程序组件，如合作式多任务、异常处理、事件循环、迭代器、无限列表和管道。</em><br><em>根据高德纳的说法, 马尔文·康威于1958年发明了术语 coroutine 并用于构建汇编程序。</em><br><em>—— Wikipedia</em></p>
<h2 id="coobjc-解决的问题"><a href="#coobjc-解决的问题" class="headerlink" title="coobjc 解决的问题"></a>coobjc 解决的问题</h2><h3 id="iOS-异步编程问题"><a href="#iOS-异步编程问题" class="headerlink" title="iOS 异步编程问题"></a>iOS 异步编程问题</h3><p>官网描述:</p>
<p>基于 Block 的异步编程回调是目前 iOS 使用最广泛的异步编程方式，iOS 系统提供的 GCD 库让异步开发变得很简单方便，但是基于这种编程方式的缺点也有很多，主要有以下几点：</p>
<p>容易进入”嵌套地狱”<br>错误处理复杂和冗长<br>容易忘记调用 completion handler<br>条件执行变得很困难<br>从互相独立的调用中组合返回结果变得极其困难<br>在错误的线程中继续执行<br>难以定位原因的多线程崩溃<br>锁和信号量滥用带来的卡顿、卡死<br>上述问题反应到线上应用本身就会出现大量的多线程崩溃</p>
<h3 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h3><p>官网描述:</p>
<p><strong>简明</strong><br>概念少：只有很少的几个操作符，相比响应式几十个操作符，简直不能再简单了<br>原理简单: 协程的实现原理很简单，整个协程库只有几千行代码<br><strong>易用</strong><br>使用简单：它的使用方式比 GCD 还要简单，接口很少<br>改造方便：现有代码只需要进行很少的改动就可以协程化，同时我们针对系统库提供了大量协程化接口<br><strong>清晰</strong><br>同步写异步逻辑：同步顺序方式写代码是人类最容易接受的方式，这可以极大的减少出错的概率<br>可读性高: 使用协程方式编写的代码比 block 嵌套写出来的代码可读性要高很多<br><strong>性能</strong><br>调度性能更快：协程本身不需要进行内核级线程的切换，调度性能快，即使创建上万个协程也毫无压力<br>减少卡顿卡死: 协程的使用以帮助开发减少锁、信号量的滥用，通过封装会引起阻塞的 IO 等协程接口，可以从根源上减少卡顿、卡死，提升应用整体的性能</p>
<h3 id="核心能力"><a href="#核心能力" class="headerlink" title="核心能力"></a>核心能力</h3><p>提供了类似C#和Javascript语言中的Async/Await编程方式支持，在协程中通过调用await方法即可同步得到异步方法的执行结果，非常适合IO、网络等异步耗时调用的同步顺序执行改造。<br>提供了类似Kotlin中的Generator功能，用于懒计算生成序列化数据，非常适合多线程可中断的序列化数据生成和访问。<br>提供了Actor Model的实现，基于Actor Model，开发者可以开发出更加线程安全的模块，避免由于直接函数调用引发的各种多线程崩溃问题。<br>提供了元组的支持，通过元组Objective-C开发者可以享受到类似Python语言中多值返回的好处。</p>
<h3 id="内置系统扩展库"><a href="#内置系统扩展库" class="headerlink" title="内置系统扩展库"></a>内置系统扩展库</h3><ul>
<li><p>提供了对NSArray、NSDictionary等容器库的协程化扩展，用于解决序列化和反序列化过程中的异步调用问题。</p>
</li>
<li><p>提供了对NSData、NSString、UIImage等数据对象的协程化扩展，用于解决读写IO过程中的异步调用问题。</p>
</li>
<li><p>提供了对NSURLConnection和NSURLSession的协程化扩展，用于解决网络异步请求过程中的异步调用问题。</p>
</li>
<li><p>提供了对NSKeyedArchieve、NSJSONSerialization等解析库的扩展，用于解决解析过程中的异步调用问题。</p>
</li>
</ul>
<h3 id="coobjc-设计"><a href="#coobjc-设计" class="headerlink" title="coobjc 设计"></a>coobjc 设计</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/1.jpg" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

<p>最底层是协程内核，包含了栈切换的管理、协程调度器的实现、协程间通信channel的实现等。<br>中间层是基于协程的操作符的包装，目前支持async/await、Generator、Actor等编程模型。<br>最上层是对系统库的协程化扩展，目前基本上覆盖了Foundation和UIKit的所有IO和耗时方法。</p>
<h3 id="核心实现原理"><a href="#核心实现原理" class="headerlink" title="核心实现原理"></a>核心实现原理</h3><p>协程的核心思想是控制调用栈的主动让出和恢复。一般的协程实现都会提供两个重要的操作：</p>
<p>Yield：是让出cpu的意思，它会中断当前的执行，回到上一次Resume的地方。<br>Resume：继续协程的运行。执行Resume后，回到上一次协程Yield的地方。</p>
<p>我们基于线程的代码执行时候，是没法做出暂停操作的，我们现在要做的事情就是要代码执行能够暂停，还能够再恢复。 基本上代码执行都是一种基于调用栈的模型，所以如果我们能把当前调用栈上的状态都保存下来，然后再能从缓存中恢复，那我们就能够实现yield和 resume。<br>实现这样操作有几种方法呢？</p>
<p>第一种：利用glibc 的 ucontext组件(云风的库)。<br>第二种：使用汇编代码来切换上下文(实现c协程)，原理同ucontext。<br>第三种：利用C语言语法switch-case的奇淫技巧来实现（Protothreads)。<br>第四种：利用了 C 语言的 setjmp 和 longjmp。<br>第五种：利用编译器支持语法糖。</p>
<p>上述第三种和第四种只是能过做到跳转，但是没法保存调用栈上的状态，看起来基本上不能算是实现了协程，只能算做做demo，第五种除非官方支持，否则自行改写编译器通用性很差。而第一种方案的 ucontext 在iOS上是废弃了的，不能使用。那么我们使用的是第二种方案，自己用汇编模拟一下 ucontext。<br>模拟ucontext的核心是通过getContext和setContext实现保存和恢复调用栈。需要熟悉不同CPU架构下的调用约定(Calling Convention). 汇编实现就是要针对不同cpu实现一套，我们目前实现了 armv7、arm64、i386、x86_64，支持iPhone真机和模拟器。</p>
<h2 id="官方例子"><a href="#官方例子" class="headerlink" title="官方例子"></a>官方例子</h2><p>整体结构如下</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/3.jpg" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

<ul>
<li><strong>cokit</strong>       cokit库为Foundation和UIKit系统库提供了一个协程封装，它依赖于coobjc库，为IO，网络等耗时的方法提供协同处理的封装。</li>
<li><strong>coobjc</strong>    coobjc的Objective-C版实现的源代码</li>
<li>*<em>coswift  *</em> coswift的Swift版源代码</li>
<li><strong>Examples</strong>    coobjcBaseExample是OC版本的Demo    coSwiftExample是OC版本的Demo    <h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3>直接看看coobjcBaseExample的效果<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/4.jpg" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>

</li>
</ul>
<p>这个界面可以看到一个简单的列表页。<br>对应到代码中的<strong>KMDiscoverListViewController</strong><br>ViewDidLoad中有如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [self setupTableView];</span><br><span class="line">    [self requestMovies];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从方法名可以得知，<strong>requestMovies</strong>实现了网络拉取电影列表的功能。<br>看 <strong>requestMovies</strong> 中的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)requestMovies</span><br><span class="line">&#123;</span><br><span class="line">    co_launch(^&#123;</span><br><span class="line">        NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;];</span><br><span class="line">        [self.refreshControl endRefreshing];</span><br><span class="line">        </span><br><span class="line">        if (dataArray != nil)</span><br><span class="line">        &#123;</span><br><span class="line">            [self processData:dataArray];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            [self.networkLoadingViewController showErrorView];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先抛开co_launch不管，可以发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;];</span><br></pre></td></tr></table></figure>

<p>实现了网络请求，获取数据，<strong>getDiscoverList</strong>实现代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray*)getDiscoverList:(NSString *)pageLimit;</span><br><span class="line">&#123;</span><br><span class="line">    NSString *url = [NSString stringWithFormat:@&quot;%@&amp;page=%@&quot;, [self prepareUrl], pageLimit];</span><br><span class="line">    id json = [[DataService sharedInstance] requestJSONWithURL:url];</span><br><span class="line">    NSDictionary* infosDictionary = [self dictionaryFromResponseObject:json jsonPatternFile:@&quot;KMDiscoverSourceJsonPattern.json&quot;];</span><br><span class="line">    return [self processResponseObject:infosDictionary];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据代码可以发现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id json = [[DataService sharedInstance] requestJSONWithURL:url];</span><br></pre></td></tr></table></figure>

<p>这一段实现了网络请求，然后继续去进入<strong>requestJSONWithURL</strong>去看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (id)requestJSONWithURL:(NSString*)url CO_ASYNC&#123;</span><br><span class="line">    SURE_ASYNC</span><br><span class="line">    return await([self.jsonActor sendMessage:url]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候发现 <strong>SURE_ASYNC</strong> 和 <strong>awiat</strong> 类似于<strong>ES7</strong>中的<strong>async</strong> 和 <strong>await</strong>，<strong>ES7</strong>中<strong>async-await</strong>是<strong>promise</strong>和<strong>generator</strong>的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性，看起来这块起到了类似的作用。<br>再来仔细了解下协程。</p>
<h3 id="协程入门"><a href="#协程入门" class="headerlink" title="协程入门"></a>协程入门</h3><p>上面的<strong>核心实现原理</strong>中有提到，实现核心的<strong>yield</strong>和<strong>resume</strong>有五种方法，<br>其中说到第三、四种只能做到过跳转，没办法保存调用栈,无法真正的实现协程。第五种除非官方支持。第一种ucontext在iOS是废弃了的。那么第二种方案，自己用汇编模拟ucontext。</p>
<p>首先，ucontext 是啥？</p>
<p><strong>ucontext</strong> 机制是<strong>GUN C</strong>库提供的一组用于创建、保存、切换用户态执行context的API。主要包括以下四个函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);</span><br><span class="line">int swapcontext(ucontext_t *oucp, ucontext_t *ucp);</span><br><span class="line">int getcontext(ucontext_t *ucp);</span><br><span class="line">int setcontext(const ucontext_t *ucp);</span><br></pre></td></tr></table></figure>

<p>详细参见<br>[我所理解的ucontext族函数]<a href="https://www.jianshu.com/p/dfd7ac1402f0" target="_blank" rel="noopener">https://www.jianshu.com/p/dfd7ac1402f0</a><br>[构建C协程之ucontext篇]<a href="https://blog.csdn.net/gettogetto/article/details/53306897" target="_blank" rel="noopener">https://blog.csdn.net/gettogetto/article/details/53306897</a></p>
<p>来看一段简单的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">//由于在Mac OS X 10.6.6 ucontext被弃用的关系 ，需要使用sys/ucontext.h</span><br><span class="line">#include &lt;sys/ucontext.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	// ----&gt; ucontext </span><br><span class="line">	ucontext_t context;	</span><br><span class="line">	getcontext(&amp;context);</span><br><span class="line">	puts(&quot;Hello world&quot;);</span><br><span class="line">	sleep(1);</span><br><span class="line">	setcontext(&amp;context);</span><br><span class="line"></span><br><span class="line">// ----&gt; goto </span><br><span class="line">// loop: puts(&quot;%s\n&quot;,&quot;Hello world&quot;);</span><br><span class="line">// 	    sleep(1);</span><br><span class="line">// 	    goto loop;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存上述代码到 example.c，执行编译命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc example.c -o example</span><br></pre></td></tr></table></figure>

<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/5.jpg" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>
<p>可以看到这里会不断执行，通过setcontext和getcontext实现切换。<br>更详细参见<br><a href="https://www.jianshu.com/p/dfd7ac1402f0" target="_blank" rel="noopener">我所理解的ucontext族函数</a><br><a href="https://blog.csdn.net/gettogetto/article/details/53306897" target="_blank" rel="noopener">构建C协程之ucontext篇</a><br>上面<strong>核心实现原理</strong>中讲到了第二种：使用汇编代码来切换上下文(实现c协程)，原理同ucontext。<br>我们在coobjc中的库中发现了唯一一个汇编文件<strong>coroutine_context.s</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://uploader.shimo.im/f/O0mWE5ILsUwn44oQ.jpg!thumbnail" alt="图片" title>
                </div>
                <div class="image-caption">图片</div>
            </figure>
<p>在汇编文件中发现主要提供了三个方法</p>
<ul>
<li>_coroutine_getcontext</li>
<li>_coroutine_begin</li>
<li>_coroutine_setcontext</li>
</ul>
<p>同样在 <strong>coroutine_context.h</strong>中暴露了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern int coroutine_getcontext (coroutine_ucontext_t *__ucp);</span><br><span class="line"></span><br><span class="line">extern int coroutine_setcontext (coroutine_ucontext_t *__ucp);</span><br><span class="line">extern int coroutine_begin (coroutine_ucontext_t *__ucp);</span><br><span class="line"></span><br><span class="line">extern void coroutine_makecontext (coroutine_ucontext_t *__ucp, IMP func, void *arg, void *stackTop);</span><br></pre></td></tr></table></figure>

<p>其中<strong>coroutine_makecontext</strong>在<strong>coroutine_context.m</strong>中实现<br>回到例子中<br><strong>co_launch</strong> 来自 <strong>coobjc.h</strong> ,来关注一下<strong>coobjc.h</strong> 里的内联函数</p>
<ul>
<li>co_launch 创建一个协程，然后在当前线程中异步恢复它</li>
<li>co_launch_now 创建一个协程，然后在当前线程立即恢复它</li>
<li>co_launch_withStackSize 创建一个协程，然后在当前线程中异步恢复它，与co_launch不同 ，他可以设定堆栈大小 默认为65536 最大限制为1M</li>
<li>co_launch_onqueue 创建一个协程，并在给定的线程中异步恢复它</li>
<li>co_sequence 创建一个生成器</li>
<li>co_sequence_onqueue 在指定的线程中创建一个生成器</li>
<li>co_actor 创建一个容器</li>
<li>co_actor_onqueue 在指定线程中创建一个容器</li>
<li>await 用await得到异步执行的结果，等待异步方法的执行</li>
<li>batch_await 批量的await 目前没找到哪里用</li>
<li>co_delay 使当前协程sleep 多少秒</li>
<li>co_isActive 判断一个协程是否有效</li>
<li>co_isCancelled 检查当前协程是否取消</li>
</ul>
<p>其他的一些宏定义</p>
<ul>
<li>CO_ASYNC 给方法一个标记，表示方法是可被暂停的，类似于JS中 async</li>
<li>SURE_ASYNC 断言</li>
<li>yield 暂停</li>
</ul>
<p>在看看用到的<strong>co_launch</strong> 文档描述在当前线程中创建协程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)requestMovies</span><br><span class="line">&#123;</span><br><span class="line">    //创建协程</span><br><span class="line">    co_launch(^&#123;</span><br><span class="line">        //进行网络加载，但并没有在这里进行await</span><br><span class="line">        NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;];</span><br><span class="line">        [self.refreshControl endRefreshing];</span><br><span class="line">        </span><br><span class="line">        if (dataArray != nil)</span><br><span class="line">        &#123;</span><br><span class="line">            [self processData:dataArray];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<pre><code>else</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        &#123;</span><br><span class="line">            [self.networkLoadingViewController showErrorView];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着往下看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在这里写了CO_ASYNC 表示该方法是可以被暂停的 同时在方法内await等待异步的结果</span><br><span class="line">- (id)requestJSONWithURL:(NSString*)url CO_ASYNC&#123;</span><br><span class="line">    SURE_ASYNC</span><br><span class="line">    return await([self.jsonActor sendMessage:url]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看看 <strong>self.jsonActor</strong> 及  <strong>sendMessage</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">jsonActor 是一个COActor 的对象，文档中描述</span><br><span class="line">_ Actor 的概念来自于 Erlang ，在 AKKA 中，可以认为一个 Actor 就是一个容器，用以存储状态、行为、Mailbox 以及子 Actor 与 Supervisor 策略。Actor 之间并不直接通信，而是通过 Mail 来互通有无。_</span><br><span class="line">*/</span><br><span class="line">@property (nonatomic, strong) COActor *jsonActor;</span><br></pre></td></tr></table></figure>

<p>此时看到 DataService.m中有init 注册了接受消息的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_jsonActor = co_actor_onqueue(_jsonQueue, ^(COActorChan *channel) &#123;</span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    id json = nil;</span><br><span class="line">    COActorCompletable *completable = nil;</span><br><span class="line">    for (COActorMessage *message in channel) &#123;</span><br><span class="line">        NSString *url = [message stringType];</span><br><span class="line">        json = nil;</span><br><span class="line">        if (url.length &gt; 0) &#123;</span><br><span class="line">            //这里接受到消息之后将消息发送到 networkActor</span><br><span class="line">            completable = [self.networkActor sendMessage:url];</span><br><span class="line">            data = await(completable);</span><br><span class="line">            if (data) &#123;</span><br><span class="line">                json = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];</span><br><span class="line">            &#125;</span><br><span class="line">            message.complete(json);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            message.complete(nil);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>收到消息后将json的消息回复到上层。展示数据</p>
<h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p>[阿里云栖社区对coobjc介绍]<a href="https://www.jianshu.com/p/cd7f6ef5a8fd" target="_blank" rel="noopener">https://www.jianshu.com/p/cd7f6ef5a8fd</a><br>[我所理解的ucontext族函数]<a href="https://www.jianshu.com/p/dfd7ac1402f0" target="_blank" rel="noopener">https://www.jianshu.com/p/dfd7ac1402f0</a><br>[构建C协程之ucontext篇]<a href="https://blog.csdn.net/gettogetto/article/details/53306897" target="_blank" rel="noopener">https://blog.csdn.net/gettogetto/article/details/53306897</a><br>[理解 JavaScript 的 async/await]<a href="https://segmentfault.com/a/1190000007535316?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007535316?utm_source=tag-newest</a><br>[GC 7.1 Mac OS X 10.6.6: ucontext routines are deprecated]<a href="https://www.hpl.hp.com/hosted/linux/mail-archives/gc/2011-February/004354.html" target="_blank" rel="noopener">https://www.hpl.hp.com/hosted/linux/mail-archives/gc/2011-February/004354.html</a><br>[PSA: avoiding the “ucontext routines are deprecated” error on Mac OS X Snow Leopard]<a href="http://duriansoftware.com/joe/PSA%3a-avoiding-the-%22ucontext-routines-are-deprecated%22-error-on-Mac-OS-X-Snow-Leopard.html" target="_blank" rel="noopener">http://duriansoftware.com/joe/PSA%3a-avoiding-the-%22ucontext-routines-are-deprecated%22-error-on-Mac-OS-X-Snow-Leopard.html</a></p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2019-10-21T11:42:36.782Z" itemprop="dateUpdated">2019-10-21 19:42:36</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/blog/2019/07/16/协程-阿里开源库-coobjc-初步分析/" target="_blank" rel="external">https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/</a>
        
    </div>
    
    <footer>
        <a href="https://github.com/jianxiongc">
            <img src="/blog/img/avatar.jpg" alt="Jianxiong">
            Jianxiong
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/iOS/">iOS</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/&title=《协程 阿里开源库 coobjc 初步分析》 — Jianxiong&pic=https://github.com/jianxiongc/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/&title=《协程 阿里开源库 coobjc 初步分析》 — Jianxiong&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《协程 阿里开源库 coobjc 初步分析》 — Jianxiong&url=https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/&via=https://github.com/jianxiongc" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/blog/2019/07/20/Swift - 变量与常量/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Swift - 变量与常量</h4>
      </a>
    </div>
  

  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/blog/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/blog/img/wechat.jpg" data-alipay="/blog/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/blog/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Jianxiong &copy; 2015 - 2019</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/&title=《协程 阿里开源库 coobjc 初步分析》 — Jianxiong&pic=https://github.com/jianxiongc/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/&title=《协程 阿里开源库 coobjc 初步分析》 — Jianxiong&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《协程 阿里开源库 coobjc 初步分析》 — Jianxiong&url=https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/&via=https://github.com/jianxiongc" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACpUlEQVR42u3aUW7bMBAE0Nz/0u0BUrkzu6TjAE9fgaNIfAzApYf79RVff75dT59/v2f2tNd3Hr7w8PDw1kNvX5NgTk1cPa14eHh413ivh/X0c35/WzD2Y8DDw8P7LbwW0+6K8fDw8H4vbxMi5Ev/jxUGPDw8vICXfPmfLdP7gONNWQseHh7e5GTqK9n+fsLPV8738PDw8Nan6vv4NSkDrwtDXgz+8Xw8PDy8C7x8wZ1tuPNWgHaLn080Hh4e3lne6+V4FiXMQoqn+zclBA8PD+8GL98Q5+1T+XHabOh1CwIeHh7eUd5muK+X8mTo0X6/DHMfSwIeHh7eUd6sOSDfjucDzac4OgzDw8PDu8ZrI4lZq8Em6p3dj4eHh3eDl9+Ul5DkSCwf9Gzrj4eHh3ePdyO6bZ/TtiDkMTQeHh7eDV572N9GFbMlvj3J+s8neHh4eNd4m1aANsxNpqmdUDw8PLz38PIAYhNbtMWmDTIewXh4eHiXefs4oI4JFm0BUbnCw8PDu8DLr2OLddmA1QYQbcyBh4eH1/LONl1tmg/yICNvOMDDw8N7J68tFcliPWvAascTFQY8PDy8Q7z8ZflvN1PT/m2RUuPh4eGtee0rN0PPY+K2zDy2DuDh4eEd5c2Or9oYN2+faqOHZMx4eHh493jtwVW73Lfs2Ujq4eLh4eEteO2GuN1GbwKOtoTg4eHhvYc3iwPySGJ2z4ELDw8P7xqsjRja57QRQxKFFDEEHh4e3iHefo3dl5994JuEGnh4eHhneW0xaAvGJl/dtBrg4eHh3ea1r58t/bMisQo18PDw8D6Md6rltAUUT8DDw8P7GN5sQ5wHHPuwGA8PD+82L3lZ+3lSPE4Fvo//Kjw8PLwLvPYLfxvXtlOZvPdwwxYeHh5e+sa/lOSccUVJi98AAAAASUVORK5CYII=" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/blog/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
