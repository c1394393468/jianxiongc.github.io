<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jianxiong</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://github.com/jianxiongc/"/>
  <updated>2019-10-28T15:25:57.625Z</updated>
  <id>https://github.com/jianxiongc/</id>
  
  <author>
    <name>Jianxiong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络概论 - 计算机网络的拓扑构型</title>
    <link href="https://github.com/jianxiongc/2019/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%8B%93%E6%89%91%E6%9E%84%E5%9E%8B/"/>
    <id>https://github.com/jianxiongc/2019/10/28/计算机网络概论-计算机网络的拓扑构型/</id>
    <published>2019-10-28T15:22:12.000Z</published>
    <updated>2019-10-28T15:25:57.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概论-计算机网络的拓扑构型"><a href="#计算机网络概论-计算机网络的拓扑构型" class="headerlink" title="计算机网络概论 - 计算机网络的拓扑构型"></a>计算机网络概论 - 计算机网络的拓扑构型</h1><h2 id="计算机网络拓扑的定义"><a href="#计算机网络拓扑的定义" class="headerlink" title="计算机网络拓扑的定义"></a>计算机网络拓扑的定义</h2><ul><li>计算机网络拓扑是通过网中节点与通信线路之间的几何关系表示网络结构，反映出网络各实体之间的结构关系。</li><li>计算机网络拓扑是指通信子网的拓扑构型。</li></ul><h2 id="基本的网络拓扑"><a href="#基本的网络拓扑" class="headerlink" title="基本的网络拓扑"></a>基本的网络拓扑</h2><ul><li>星型拓扑</li><li>环形拓扑</li><li>总线性拓扑</li><li>树形拓扑</li><li>网状拓扑</li></ul><h3 id="星型拓扑"><a href="#星型拓扑" class="headerlink" title="星型拓扑"></a>星型拓扑</h3><ul><li>节点通过点-点通信线路与中心线路连接</li><li>中心节点控制全网的通信，任何两节点之间的通信都要通过中心节点。</li><li>星型拓扑构型的特点是: 结构简单，易于实现，便于管理。</li><li>缺点: 中心节点成为全网性能的瓶颈</li></ul><h3 id="环形拓扑"><a href="#环形拓扑" class="headerlink" title="环形拓扑"></a>环形拓扑</h3><ul><li>节点通过点-点通信线路连接成闭关</li><li>环中数据将沿一个方向逐站传送</li><li>环形拓扑结构简单，传输延时确定</li><li>但是环中每个结点与连接结点之间的通信线路都会成为网络可靠性的瓶颈</li><li>环网需要设计复杂的环维护协议</li></ul><h3 id="总线形拓扑"><a href="#总线形拓扑" class="headerlink" title="总线形拓扑"></a>总线形拓扑</h3><ul><li>在总线形拓扑结构中，所有结点连接在一条作为公共传输介质的总线；</li><li>当一个结点利用总线发送数据时，其它结点只能接收数据；</li><li>如果有两个及以上的结点同时利用公共总线发送数据时，就会出现冲突，造成传输失败；</li><li>总线形拓扑特点是结构简单；</li><li>缺点是必须解决多结点访问总线介质访问控制策略问题。</li></ul><h3 id="树形拓扑"><a href="#树形拓扑" class="headerlink" title="树形拓扑"></a>树形拓扑</h3><ul><li>树形拓扑结构中结点按层次进行连接，信息交换主要在上、下结点之间进行，相邻及同层结点之间通常不进行数据交换，或数据交换量比较小</li><li>树形拓扑可以看成星形拓扑的扩展</li><li>树形拓扑网络适用于汇集信息的应用要求</li></ul><h3 id="网状拓扑"><a href="#网状拓扑" class="headerlink" title="网状拓扑"></a>网状拓扑</h3><ul><li>在网状拓扑结构中，结点之间的连接是任意的，没有规律</li><li>网状拓扑的优点是系统可靠性高</li><li>网状拓扑结构复杂，必须采用路由选择算法、流量控制与拥塞控制方法</li><li>广域网一般都采用网状拓扑</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络概论-计算机网络的拓扑构型&quot;&gt;&lt;a href=&quot;#计算机网络概论-计算机网络的拓扑构型&quot; class=&quot;headerlink&quot; title=&quot;计算机网络概论 - 计算机网络的拓扑构型&quot;&gt;&lt;/a&gt;计算机网络概论 - 计算机网络的拓扑构型&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="计算机网络与概论" scheme="https://github.com/jianxiongc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="计算机科学与技术" scheme="https://github.com/jianxiongc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概论 - 网络发展的三个主线</title>
    <link href="https://github.com/jianxiongc/2019/10/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA-%E7%BD%91%E7%BB%9C%E5%8F%91%E5%B1%95%E7%9A%84%E4%B8%89%E4%B8%AA%E4%B8%BB%E7%BA%BF/"/>
    <id>https://github.com/jianxiongc/2019/10/27/计算机网络概论-网络发展的三个主线/</id>
    <published>2019-10-26T16:43:59.000Z</published>
    <updated>2019-10-26T16:43:50.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概论-网络发展的三个主线"><a href="#计算机网络概论-网络发展的三个主线" class="headerlink" title="计算机网络概论-网络发展的三个主线"></a>计算机网络概论-网络发展的三个主线</h1><h3 id="1-从-ARPANET-到-Internet"><a href="#1-从-ARPANET-到-Internet" class="headerlink" title="1. 从 ARPANET 到 Internet"></a>1. 从 ARPANET 到 Internet</h3><p>ARPANET的研究奠定互联网发展的基础，而联系二者的是TCP/IP协议。</p><p>在从ARPANET演变到互联网的过程中，强烈的社会需求促进广域网、城域网与局域网技术的研究与应用的发展，而广域网、城域网与局域网技术的成熟与标准化，又加速了互联网的发展进程。</p><p>与传统的客户/服务器（C/S）工作模式不同，对等（P2P）工作模式淡化了服务提供者与服务使用者的界限，从而达到进一步扩大网络资源共享范围和深度，提高网络资源利用率，达到信息共享最大化的目的。</p><p>新的基于P2P网络应用不断出现，成为21世纪网络应用重要的研究方向之一。</p><p>随着互联网的广泛应用，计算机网络、电信网络与有线电视网络从结构、技术到服务领域正在快速地融合，成为21世纪信息产业发展最具活力的领域。</p><h3 id="2-从无线分组网到无线自组网、无线传感器网络的无线网络技术"><a href="#2-从无线分组网到无线自组网、无线传感器网络的无线网络技术" class="headerlink" title="2. 从无线分组网到无线自组网、无线传感器网络的无线网络技术"></a>2. 从无线分组网到无线自组网、无线传感器网络的无线网络技术</h3><p>无线网络可以分为基于基础设施与无基础设施的两类。802.11<strong>无线局域网</strong>（WLAN）与802.16<strong>无线城域网</strong>（WMAN）属于需要基础设施的一类无线网络。</p><p>无线自组网、无线传感器网络属于不需要基础设施的另一类无线网络。</p><p>在无线分组网的基础上发展起来的<strong>无线自组网</strong>（Ad hoc）是一种特殊的自组织、对等式、多跳、无线移动网络，它是军事、特殊应用领域有着重要的应用前景。</p><p>无线网状网（WMN）是无线自组网在接入领域的一种应用。</p><p>当无线自组网技术日趋成熟的时候，无线通信、微电子、传感器技术得到快速发展。在军事领域中，人们提出将无线自组网与传感器技术相结合的无线传感器网络技术研究。</p><p>无线传感器网络（WSN）被评价为“21世纪最有影响的21项技术之一”和“改变世界的十大技术之首”。</p><p>如果说广域网作用是扩大信息社会中资源共享的范围，局域网是进一步增强信息社会中资源共享的深度，无线网络增强人类共享信息资源的灵活性，那么无线传感器网络将会改变人类与自然界的交互方式，它将极大地扩展现有网络的功能和人类认识世界的能力。</p><h3 id="3-网络安全技术"><a href="#3-网络安全技术" class="headerlink" title="3. 网络安全技术"></a>3. 网络安全技术</h3><p>人类创造了网络虚拟社会的繁荣，也是人类制造了网络虚拟社会的麻烦。</p><p>现实社会对网络技术依赖的程度越高，网络安全技术就越显得重要。网络安全是网络技术研究中一个永恒的主题。</p><p>在“攻击—防御—新攻击—新防御”的循环中，网络攻击技术与网络反攻击技术相互影响、相互制约，共同发展，这个过程将一直延续下去。</p><p>从当前的发展趋势看，网络安全问题已超出技术和传统意义上计算机犯罪的范畴，已发展成为国家之间一种政治与军事的手段。</p><p>各国只能立足于自身，研究网络安全技术，培养专门人才，发展网络安全产业，构筑网络与信息安全保障体系。</p><p><strong>计算机网络的定义：</strong></p><pre><code>以能够相互共享资源的方式互联起来的自治计算机系统的集合。</code></pre><p>计算机网络的基本特征 :</p><pre><code>1. 计算机网络建立的目的是实现计算机资源的共享。2. 互联的计算机是分布在不同地理位置的多台独立的“自治计算机系统”。3. 联网计算机之间的通信必须遵循共同的网络协议。</code></pre><p><strong>计算机网络的分类</strong></p><p>计算机网络分类的方法 :</p><pre><code>1. 按网络采用的传输技术分类2. 按网络覆盖的地理范围分类</code></pre><p>按传输技术分类 :</p><pre><code>1. 广播通信信道—广播网络2. 点-点通信信道—点-点网络</code></pre><p>按照覆盖的地理范围进行分类 :</p><pre><code>1. 局域网2. 城域网3. 广域网</code></pre><p>局域网（LAN）的基本特征 :</p><pre><code>局域网用于将有限范围内（例如一个实验室、一幢大楼、一个校园）的各种计算机、终端与外部设备互联成网；局域网可以分为共享局域网与交换局域网；</code></pre><p>城域网（MAN）的基本特征 :</p><pre><code>城域网的设计目标是要满足几十公里范围内的大量企业、机关、公司的多个局域网互联的需求，以实现大量用户之间的数据、语音、图形与视频等多种信息的传输。宽带城域网的概念逐渐取代传统意义上的城域网。</code></pre><p>广域网（WAN）的基本特征 :</p><pre><code>广域网覆盖的地理范围从几十公里到几千公里；广域网可以是覆盖一个国家、地区，或横跨几个洲；广域网将分布在不同地区的宽带城域网或计算机系统互联起来，提供各种网络服务，实现信息资源共享。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机网络概论-网络发展的三个主线&quot;&gt;&lt;a href=&quot;#计算机网络概论-网络发展的三个主线&quot; class=&quot;headerlink&quot; title=&quot;计算机网络概论-网络发展的三个主线&quot;&gt;&lt;/a&gt;计算机网络概论-网络发展的三个主线&lt;/h1&gt;&lt;h3 id=&quot;1-从-A
      
    
    </summary>
    
      <category term="计算机网络与概论" scheme="https://github.com/jianxiongc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="计算机科学与技术" scheme="https://github.com/jianxiongc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络与概论 - 计算机发展的四个阶段</title>
    <link href="https://github.com/jianxiongc/2019/10/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%AE%BA-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8F%91%E5%B1%95%E7%9A%84%E5%9B%9B%E4%B8%AA%E9%98%B6%E6%AE%B5/"/>
    <id>https://github.com/jianxiongc/2019/10/21/计算机网络概论-计算机发展的四个阶段/</id>
    <published>2019-10-21T14:24:59.000Z</published>
    <updated>2019-10-26T16:45:07.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="四个阶段的特点"><a href="#四个阶段的特点" class="headerlink" title="四个阶段的特点"></a>四个阶段的特点</h3><h4 id="第一阶段：计算机网络技术与理论准备阶段"><a href="#第一阶段：计算机网络技术与理论准备阶段" class="headerlink" title="第一阶段：计算机网络技术与理论准备阶段"></a>第一阶段：计算机网络技术与理论准备阶段</h4><p>20 世纪 50 年代</p><ol><li>数据通信的研究与技术的日趋成熟，为计算机网络的形成奠定了技术基础</li><li><strong>分组交换概念</strong>的提出为计算机网络的研究奠定了理论基础</li></ol><h4 id="第二阶段：计算机网络的形成"><a href="#第二阶段：计算机网络的形成" class="headerlink" title="第二阶段：计算机网络的形成"></a>第二阶段：计算机网络的形成</h4><p>20 世纪 60 年代开始</p><ol><li><strong>ARPANET</strong> 的成功运行证明分组交换理论的正确性</li><li><strong>TCP/IP协议</strong> 的广泛应用为更大规模的网络互联奠定坚实的基础</li><li><strong>DNS</strong>、E-mail、<strong>FTP</strong>、<strong>TELNET</strong>、<strong>BBS</strong> 等应用展现了网络技术应用的广阔前景</li></ol><h4 id="第三阶段：计算机网络的形成"><a href="#第三阶段：计算机网络的形成" class="headerlink" title="第三阶段：计算机网络的形成"></a>第三阶段：计算机网络的形成</h4><p>从20世纪70年代中期开始</p><ol><li><strong>OSI</strong> 参考模型的研究对网络理论体系的形成与发展，以及在推进网络协议标准化方面起到了重要的推动作用</li><li>TCP/IP协议经受了市场和用户的检验，吸引了大量的投资，推动了互联网应用的发展，成为业界事实上的标准。</li></ol><h4 id="第四阶段：互联网应用、无线网络与网络安全技术研究的发展"><a href="#第四阶段：互联网应用、无线网络与网络安全技术研究的发展" class="headerlink" title="第四阶段：互联网应用、无线网络与网络安全技术研究的发展"></a>第四阶段：互联网应用、无线网络与网络安全技术研究的发展</h4><p>从20世纪90年代开始</p><ol><li>互联网作为全球性的网际网与信息系统，在当今政治、经济、文化、科研、教育与社会生活等方面发挥了越来越重要的作用</li><li>计算机网络与电信网络、有线电视网络“三网融合”促进了宽带<strong>城域网</strong>概念、技术的演变</li><li>无线局域网与无线城域网技术日益成熟，已经进入应用阶段，<strong>无线自组网</strong>、<strong>无线传感器网络</strong> 的研究与应用受到了高度重视</li><li><strong>对等（P2P）网络</strong> 的研究使新的网络应用不断涌现，成为现代信息服务业新的产业增长点；</li><li>随着网络应用的快速增长，新的网络安全问题不断出现，促使网络安全技术的研究与应用进入高速发展阶段。</li></ol><h3 id="计算机网络的形成与发展"><a href="#计算机网络的形成与发展" class="headerlink" title="计算机网络的形成与发展"></a>计算机网络的形成与发展</h3><p><strong>网络拓扑结构设计思路</strong></p><p><strong>集中式和非集中式的拓扑构型</strong></p><p><strong>集中式</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15713624202464.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p><strong>非集中式</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15713624392304.jpg" alt="-w317" title>                </div>                <div class="image-caption">-w317</div>            </figure><p><strong>分布式网络的拓扑架构</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714548395437.jpg" alt="-w304" title>                </div>                <div class="image-caption">-w304</div>            </figure><h4 id="分组交换技术的基本设计思路"><a href="#分组交换技术的基本设计思路" class="headerlink" title="分组交换技术的基本设计思路"></a>分组交换技术的基本设计思路</h4><p><strong>分组交换技术重要的概念：</strong></p><ul><li><p>分组</p></li><li><p>路由选择</p></li><li><p>存储转发</p></li><li><p>报文与报文分组</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714549049298.jpg" alt="-w598" title>                </div>                <div class="image-caption">-w598</div>            </figure><p><strong>报文存储转发与分组存储转发过程的比较</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714549193740.jpg" alt="-w622" title>                </div>                <div class="image-caption">-w622</div>            </figure><p><strong>ARPANET的设计思想</strong><br>通信子网结构与分组交换原理示意图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714633466706.jpg" alt="-w770" title>                </div>                <div class="image-caption">-w770</div>            </figure><p>ARPANET最早4个结点的结构</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714633691145.jpg" alt="-w640" title>                </div>                <div class="image-caption">-w640</div>            </figure><p><strong>ARPANET的主要贡献</strong><br>开展了对计算机网络定义与分类方法的研究。</p><p>提出了资源子网与通信子网的二级网络结构概念。</p><p>研究了分组交换的协议与实现技术。</p><p>研究了层次型网络体系结构的模型与协议体系。</p><p>开展了TCP/IP协议与网络互联技术的研究。</p><p>TCP/IP协议研究与发展</p><p>ARPANET协议主要包括：主机-主机协议、源IMP-目的IMP协议、IMP-IMP协议；</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714634771484.jpg" alt="-w465" title>                </div>                <div class="image-caption">-w465</div>            </figure><p>1977年10月，ARPANET研究人员决定将初期的TCP分为传输控制协议（TCP）与互联网络协议（IP）；</p><p>TCP协议主要用于实现源主机与目的主机之间的分布式进程通信的功能；</p><p>IP协议主要用于实现分组通过通信子网的路由选择功能。</p><p>从ARPANET到Internet的发展过程</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714636217763.jpg" alt="-w638" title>                </div>                <div class="image-caption">-w638</div>            </figure><h4 id="名词理解"><a href="#名词理解" class="headerlink" title="名词理解"></a>名词理解</h4><p><strong>分组交换概念</strong></p><p>在通信过程中，通信双方以分组为单位、使用存储-转发机制实现数据交互的通信方式，被称为分组交换（PS:packet switching）。<br>分组交换也称为包交换，它将用户通信的数据划分成多个更小的等长数据段，在每个数据段的前面加上必要的控制信息作为数据段的首部，每个带有首部的数据段就构成了一个分组。首部指明了该分组发送的地址，当交换机收到分组之后，将根据首部中的地址信息将分组转发到目的地，这个过程就是分组交换。能够进行分组交换的通信网被称为分组交换网。<br>分组交换的本质就是存储转发，它将所接受的分组暂时存储下来，在目的方向路由上排队，当它可以发送信息时，再将信息发送到相应的路由上，完成转发。其存储转发的过程就是分组交换的过程。<br>分组交换的思想来源于报文交换，报文交换也称为存储转发交换，它们交换过程的本质都是存储转发，所不同的是分组交换的最小信息单位是分组，而报文交换则是一个个报文。由于以较小的分组为单位进行传输和交换，所以分组交换比报文交换快。报文交换主要应用于公用电报网中。</p><p> <strong>ARPANET</strong></p><p>高级研究计划局网络（英语：Advanced Research Projects Agency Network），通称阿帕网（英语：ARPANET）是美国国防高级研究计划局开发的世界上第一个运营的数据包交换网络，是全球互联网的鼻祖。</p><p><strong>TCP/IP协议</strong></p><p>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为网际网络的基础通信架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的堆栈，因此又被称为TCP/IP协议栈（英语：TCP/IP Protocol Stack） 。这些协议最早发源于美国国防部（缩写为DoD）的ARPA网项目，因此也被称作DoD模型（DoD Model）。这个协议族由互联网工程任务组负责维护。</p><p>TCP/IP提供了点对点连结的机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为是简化的七层OSI模型。</p><p><strong>OSI 模型</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/10/21/media/15714523584140.jpg" alt="-w615" title>                </div>                <div class="image-caption">-w615</div>            </figure><p><strong>DNS</strong></p><p>域名系统（英语：Domain Name System，缩写：DNS）是互联网的一项服务。它作为将域名和IP地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。DNS使用TCP和UDP端口53。当前，对于每一级域名长度的限制是63个字符，域名总长度则不能超过253个字符。</p><p><strong>FTP</strong></p><p>文件传输协议（File Transfer Protocol，FTP）是用于在网络上进行文件传输的一套标准协议，它工作在 OSI 模型的第七层， TCP 模型的第四层， 即应用层， 使用 TCP 传输而不是 UDP， 客户在和服务器建立连接前要经过一个“三次握手”的过程， 保证客户与服务器之间的连接是可靠的， 而且是面向连接， 为数据传输提供可靠保证。</p><p>FTP允许用户以文件操作的方式（如文件的增、删、改、查、传送等）与另一主机相互通信。然而， 用户并不真正登录到自己想要存取的计算机上面而成为完全用户， 可用FTP程序访问远程资源， 实现用户往返传输文件、目录管理以及访问电子邮件等等， 即使双方计算机可能配有不同的操作系统和文件存储方式</p><p><strong>城域网</strong></p><p>都会网域（Metropolitan Area Network，MAN）指大型的计算机网络，属于IEEE802.6标准，是介于LAN和WAN之间能传输语音与数据的公用网络。MAN是改进LAN（局域网）中的传输介质，扩大局域网的范围，达到包含一个大学校园、城市或都会区。它是较大型的局域网，需要的成本较高，但可以提供更快的传输速率。例如：某一家企业把在一个城市或同一国家内的服务据点连接起来，就可以称为一个或多个城域网。一些常用于城市区网的技术包括：以太网（10Gbps/100Gbps）、WiMAX（全球互通微波访问）。</p><p> <strong>对等（P2P）网络</strong></p><p>对等式网络（peer-to-peer， 简称P2P），又称点对点技术，是无中心服务器、依靠用户群（peers）交换信息的互联网体系，它的作用在于，减低以往网路传输中的节点，以降低资料遗失的风险。与有中心服务器的中央网络系统不同，对等网络的每个用户端既是一个节点，也有服务器的功能，任何一个节点无法直接找到其他节点，必须依靠其户群进行信息交流。</p><p>P2P节点能遍布整个互联网，也给包括开发者在内的任何人、组织、或政府带来监控难题。P2P在网络隐私要求高和文件共享领域中，得到了广泛的应用。使用一般型P2P技术的网络系统有比特币、Gnutella，或自由网等。另外，P2P技术也被使用在类似VoIP等实时媒体业务的数据通信中。有些网络（如Napster、OpenNAP，或IRC @find）包括搜索的一些功能，也使用客户端-服务器结构，而使用P2P结构来实现另外一些功能。这种网络设计模型不同于客户端-服务器模型，在客户端-服务器模型中通信通常来往于一个中央服务器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;四个阶段的特点&quot;&gt;&lt;a href=&quot;#四个阶段的特点&quot; class=&quot;headerlink&quot; title=&quot;四个阶段的特点&quot;&gt;&lt;/a&gt;四个阶段的特点&lt;/h3&gt;&lt;h4 id=&quot;第一阶段：计算机网络技术与理论准备阶段&quot;&gt;&lt;a href=&quot;#第一阶段：计算机网络技术与理
      
    
    </summary>
    
      <category term="计算机网络与概论" scheme="https://github.com/jianxiongc/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%A6%82%E8%AE%BA/"/>
    
    
      <category term="计算机科学与技术" scheme="https://github.com/jianxiongc/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E4%B8%8E%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>黑客与画家</title>
    <link href="https://github.com/jianxiongc/2019/08/02/%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6/"/>
    <id>https://github.com/jianxiongc/2019/08/02/黑客与画家/</id>
    <published>2019-08-02T12:24:59.000Z</published>
    <updated>2019-08-02T12:25:46.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="黑客与画家"><a href="#黑客与画家" class="headerlink" title="黑客与画家"></a>黑客与画家</h1><p>这里总结了自己在阅读这本书时候所做的标注。</p><h4 id="Make-something-people-want"><a href="#Make-something-people-want" class="headerlink" title="Make something people want."></a>Make something people want.</h4><p>抓住最本质的东西 ，做出人们真正需要 真正想要的产品 。为此你需要关注用户需要什么 ， 倾听用户的声音 ， 琢磨他们需要什么。</p><h4 id="为什么书呆子不受欢迎-，-他们的心思在别的地方"><a href="#为什么书呆子不受欢迎-，-他们的心思在别的地方" class="headerlink" title="为什么书呆子不受欢迎 ， 他们的心思在别的地方"></a>为什么书呆子不受欢迎 ， 他们的心思在别的地方</h4><p>健康的等级关系应该是通过各自出色的能力获得的 ， 而不是排挤他人。</p><p>谈到青少年 11 岁到 14 岁是人生中最糟糕的阶段 ， 由在学校内部构建起的野蛮文化 。 如何让自己在集体中变得更受欢迎，还是坚持做一个书呆子 。</p><p>总体上看 ， 我就读的学校与上面所说的监狱差不多 。 校方最重视的事情 ， 就是让学生待在自己应该待的位置 。 与此同时 ， 让学生有东西吃 ， 避免公然的暴力行为 ， 接下来才是尝试教给学生一些东西 。 除此以外 ， 校方并不愿意在学生身上多费心思 。 就像监狱的狱卒 ， 老师们很大程度上对学生是放任自流的 。 结果 ， 学生就像犯人一样 ， 发展出了野蛮的内部文化 。</p><h4 id="因为如果你不爱一件事-，-你不可能把它做的真正优秀-，-要是你很热爱编程-，-你就不可避免的会开发你自己的项目。"><a href="#因为如果你不爱一件事-，-你不可能把它做的真正优秀-，-要是你很热爱编程-，-你就不可避免的会开发你自己的项目。" class="headerlink" title="因为如果你不爱一件事 ， 你不可能把它做的真正优秀 ， 要是你很热爱编程 ， 你就不可避免的会开发你自己的项目。"></a>因为如果你不爱一件事 ， 你不可能把它做的真正优秀 ， 要是你很热爱编程 ， 你就不可避免的会开发你自己的项目。</h4><p>我在工作一年左右的时候开始想要做一些自己的东西 ， 起初只是有一些自己的想法 ，希望时间管理的方式更加简单 。 后来慢慢的开始做到真正的投入给用户 有很多用户反馈给我 ，给了我许多的支持 。 我想这就是我与世界沟通的方式吧。 真正的自己做的项目 ， 没有任何为公司 ，出自于热爱 ，和一个想做好产品的心 。</p><h4 id="小时候-，每个人都会鼓励你不断成长-，变成一个心智成熟-，不在耍小孩子脾气的人-。-但是-，很少有人鼓励你继续成长-，变成一个怀疑和地址社会错误潮流的人-。-如果自己就是潮水的一部分-，-怎么能看见潮流的方向呢-？-你只能永远保持质问-。问自己-，什么话是我不能说的-？-为什么-？"><a href="#小时候-，每个人都会鼓励你不断成长-，变成一个心智成熟-，不在耍小孩子脾气的人-。-但是-，很少有人鼓励你继续成长-，变成一个怀疑和地址社会错误潮流的人-。-如果自己就是潮水的一部分-，-怎么能看见潮流的方向呢-？-你只能永远保持质问-。问自己-，什么话是我不能说的-？-为什么-？" class="headerlink" title="小时候 ，每个人都会鼓励你不断成长 ，变成一个心智成熟 ，不在耍小孩子脾气的人 。 但是 ，很少有人鼓励你继续成长 ，变成一个怀疑和地址社会错误潮流的人 。 如果自己就是潮水的一部分 ， 怎么能看见潮流的方向呢 ？ 你只能永远保持质问 。问自己 ，什么话是我不能说的 ？ 为什么 ？"></a>小时候 ，每个人都会鼓励你不断成长 ，变成一个心智成熟 ，不在耍小孩子脾气的人 。 但是 ，很少有人鼓励你继续成长 ，变成一个怀疑和地址社会错误潮流的人 。 如果自己就是潮水的一部分 ， 怎么能看见潮流的方向呢 ？ 你只能永远保持质问 。问自己 ，什么话是我不能说的 ？ 为什么 ？</h4><p>如果你想要清晰地思考，就必须远离人群。但是走得越远，你的处境就会越困难，受到的阻力也会越大，因为你没有迎合社会习俗，而是一步步地与它背道而驰。</p><h4 id="设计者的品味-如何做出优秀的东西？"><a href="#设计者的品味-如何做出优秀的东西？" class="headerlink" title="设计者的品味: 如何做出优秀的东西？"></a>设计者的品味: 如何做出优秀的东西？</h4><p>好设计是简单的设计<br>好设计是永不过时的设计<br>好设计是解决主要问题的设计<br>好设计是启发性的设计<br>好设计通常是有点趣味性的设计<br>好设计常常是大胆的设计<br>好设计常常是奇特的设计<br>好设计是能够复制的设计<br>好设计是一种再设计<br>好设计是模仿大自然的设计<br>好设计是对称的设计<br>好设计是看似容易的设计</p><p>幽默感是强壮的一种表现 ，始终拥有幽默感就代表你对厄运一笑了之 ，而丧失幽默感就代表你被厄运深深伤害到。</p><p>把品味说成个人的偏好可以很好的杜绝争论 ，防止人们争执哪一种品味更好 。 但是问题是 ， 这种说法是不正确的 。只要你开始设计东西 ， 就能明白这一点 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;黑客与画家&quot;&gt;&lt;a href=&quot;#黑客与画家&quot; class=&quot;headerlink&quot; title=&quot;黑客与画家&quot;&gt;&lt;/a&gt;黑客与画家&lt;/h1&gt;&lt;p&gt;这里总结了自己在阅读这本书时候所做的标注。&lt;/p&gt;
&lt;h4 id=&quot;Make-something-people-wa
      
    
    </summary>
    
      <category term="阅读" scheme="https://github.com/jianxiongc/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="读书" scheme="https://github.com/jianxiongc/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Swift常用操作符</title>
    <link href="https://github.com/jianxiongc/2019/08/01/Swift%20-%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>https://github.com/jianxiongc/2019/08/01/Swift - 常用操作符/</id>
    <published>2019-08-01T11:40:37.000Z</published>
    <updated>2019-08-01T12:16:00.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift-常用操作符"><a href="#Swift-常用操作符" class="headerlink" title="Swift 常用操作符"></a>Swift 常用操作符</h1><h2 id="基本操作符"><a href="#基本操作符" class="headerlink" title="基本操作符"></a>基本操作符</h2><p><strong>赋值操作符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=</span><br></pre></td></tr></table></figure><p><strong>基本算术操作符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+</span><br><span class="line">-</span><br><span class="line">*</span><br><span class="line">/</span><br><span class="line">%</span><br></pre></td></tr></table></figure><p>“Swift 3不再允许浮点数取模。例如：8 ％ 2.5这样的写法在Swift 3中将会报错。如果要对浮点数取模，只能这样： 8.truncatingRemainder(dividingBy: 2.5)。”</p><p><strong>复合操作符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+=</span><br><span class="line">-=</span><br><span class="line">*=</span><br><span class="line">/=</span><br><span class="line">%=</span><br></pre></td></tr></table></figure><p>Swift不会把数字自动转换成Bool类型。在需要Bool值的地方，你必须明确使用一个Bool变量。 (不如js方便)<br>“Swift 3中不再支持自增（++）和自减（–）操作符，使用它们的前缀和后缀版本都会得到一个编译器错误。因此，需要+1/-1的时候，只能使用b += 1和b -= 1来实现。”</p><p><strong>比较操作符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">==</span><br><span class="line">!=</span><br><span class="line">&gt;</span><br><span class="line">&lt;</span><br><span class="line">&lt;=</span><br><span class="line">&gt;=</span><br></pre></td></tr></table></figure><p><strong>三元运算符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let result = a ? b : c;</span><br></pre></td></tr></table></figure><p><strong>Nil Coalescing Operator</strong></p><p>需要注意 , 这是 Swift 特有的操作符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// opt != nil ? opt! : b</span><br><span class="line"></span><br><span class="line">let value = userInput ?? &quot;default input&quot;</span><br></pre></td></tr></table></figure><p>如果 opt 是一个 optional ，当其不为nil时，就使用optional变量自身的值，否则，就使用??后面的“默认值”。</p><p><strong>闭区间range operator</strong></p><p>Swift 内 for 循环的新写法 ， 用 begin … end 的方式表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for index in 1...5 &#123;</span><br><span class="line">    print(index) //1,2,3,4,5</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>半开半闭区间range operator</strong></p><p>与上面的相似 写法为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for index in 1..&lt;5 &#123;</span><br><span class="line">    print(index)  //1,2,3,4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>逻辑运算符</strong></p><p>与其他语言逻辑运算符一样 ，Swift 支持 NOT，AND 和 OR , 它们都返回一个 Bool</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let isLogin = !res;</span><br><span class="line">let userName = userName &amp;&amp; userNickName</span><br><span class="line">let userAge = userAge || defalutAge</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swift-常用操作符&quot;&gt;&lt;a href=&quot;#Swift-常用操作符&quot; class=&quot;headerlink&quot; title=&quot;Swift 常用操作符&quot;&gt;&lt;/a&gt;Swift 常用操作符&lt;/h1&gt;&lt;h2 id=&quot;基本操作符&quot;&gt;&lt;a href=&quot;#基本操作符&quot; class
      
    
    </summary>
    
      <category term="Swift学习笔记" scheme="https://github.com/jianxiongc/categories/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="https://github.com/jianxiongc/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-Tuple</title>
    <link href="https://github.com/jianxiongc/2019/07/31/Swift%20-%20Tuple/"/>
    <id>https://github.com/jianxiongc/2019/07/31/Swift - Tuple/</id>
    <published>2019-07-31T09:11:40.000Z</published>
    <updated>2019-07-31T09:16:34.397Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift-Tuple"><a href="#Swift-Tuple" class="headerlink" title="Swift - Tuple"></a>Swift - Tuple</h1><p>相比于 Objective-C ，Swift 提供了一种新的类型 <strong>Tuple</strong> ， Tuple可以创建一组不同类型的集合。</p><p>例如需要返回一个 HTTP 状态信息 : </p><ul><li>状态码 : 200 ; 状态消息 : SUCCESS</li><li>状态码 : 404 ; 状态消息 : File not found</li></ul><h2 id="定义一个-Tuple"><a href="#定义一个-Tuple" class="headerlink" title="定义一个 Tuple"></a>定义一个 Tuple</h2><p>定义一个 HTTP 状态消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//: #### Define a tuple</span><br><span class="line"></span><br><span class="line">let success = (200 ,&quot;SUCCESS&quot;)          //(.0 200, .1 &quot;SUCCESS&quot;)</span><br><span class="line">let fail = (404 ,&quot;File not found&quot;)      //(.0 404, .1 &quot;File not found&quot;)</span><br></pre></td></tr></table></figure><p>定义一个指定命名的Tuple</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let userInfo = (name: &quot;jianxiong&quot;, age: 22, email: &quot;jianxiong1997@gmail.com&quot;)</span><br></pre></td></tr></table></figure><p>定义好之后 ，就可以通过下面的方式访问 Tuple 中的数据成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">success.0           //200</span><br><span class="line">success.1           //&quot;SUCCESS&quot;</span><br><span class="line"></span><br><span class="line">fail.0              //404</span><br><span class="line">fail.1              //&quot;File not found&quot;</span><br><span class="line"></span><br><span class="line">userInfo.name       //&quot;jianxiong&quot;</span><br><span class="line">userInfo.age        //22</span><br><span class="line">userInfo.email      //&quot;jianxiong1997@gmail.com&quot;</span><br></pre></td></tr></table></figure><h2 id="Tuple-Decomposition"><a href="#Tuple-Decomposition" class="headerlink" title="Tuple Decomposition"></a>Tuple Decomposition</h2><p>把一个 Tuple 的值 ，一一拆分到不同的变量上 ，叫做 Tuple Decomposition 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//: #### Tuple Decomposition</span><br><span class="line">let (successCode, successMessage) = success</span><br><span class="line">print(successCode)          //200</span><br><span class="line">print(successMessage)       //SUCCESS</span><br></pre></td></tr></table></figure><p>这里使用success 构建了一个新的 Tuple ，因此修改 successCode 和 successMessage 都不会对原有的 success 产生影响</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">successCode = 201</span><br><span class="line">successMessage = &quot;Created&quot;</span><br><span class="line">print(successCode)          //201</span><br><span class="line">print(successMessage)       //Created</span><br><span class="line">print(success)              //(200, &quot;SUCCESS&quot;)</span><br></pre></td></tr></table></figure><p>如果只是想要对应到 Tuple 中特定的成员 ，忽略其他成员 ， 可以采用 _ 来表示忽略的成员 ， 例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let (_ ,errorMessage) = fail</span><br><span class="line">print(errorMessage)         //&quot;File not found&quot;</span><br></pre></td></tr></table></figure><h2 id="Tuple-Type"><a href="#Tuple-Type" class="headerlink" title="Tuple Type"></a>Tuple Type</h2><p>每一个 Tuple 的类型 ， 都是有 Tuple 中所有成员决定的 。 例如 success 的类型 就是 (Int ,String) 。 当我们需要用 Type annotation 定义一个 Tuple 时 ， 我们可以这样写。这里不能通过指定命名来取值了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var airPodsInfo:(String ,Double ,String) = (name: &quot;商品名称&quot; ,money: 1168.8 ,mode: &quot;A2031&quot;)</span><br><span class="line">airPodsInfo.0       //&quot;商品名称&quot;</span><br><span class="line">airPodsInfo.1       //1168.8</span><br><span class="line">airPodsInfo.2       //A2031</span><br></pre></td></tr></table></figure><h2 id="Tuple-comparison"><a href="#Tuple-comparison" class="headerlink" title="Tuple comparison"></a>Tuple comparison</h2><p>当我们比较两个Tuple类型的变量时，要遵循下面的规则：</p><p>首先，只有元素个数相同的Tuple变量之间，才能进行比较。例如，下面的代码会引发编译错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let tuple1 = (1,2,3)</span><br><span class="line">let tuple2 = (1,2)</span><br><span class="line"></span><br><span class="line">tuple1 &gt; tuple2  //Binary operator &apos;&gt;&apos; cannot be applied to operands of type &apos;(Int, Int, Int)&apos; and &apos;(Int, Int)&apos;</span><br></pre></td></tr></table></figure><p>从上面的结果就能看到，包含两个Int的Tuple不能和包含三个Int的Tuple进行比较。<br>其次，当Tuple中元素个数相同时，比较是按照Tuple中元素的位置从前向后依次进行的：</p><ul><li>如果Tuple中，相同位置的两个元素相等，则继续比较下一个位置的两个元素，并根据第一个同一位置不相等的两个元素的大小关系，确定两个Tuple变量的关系；</li><li>如果两个Tuple中所有位置的元素都相等，则两个Tuple变量相等；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let tuple1 = (1,3)</span><br><span class="line">let tuple2 = (1,2)</span><br><span class="line"></span><br><span class="line">tuple1 &gt; tuple2  //true</span><br></pre></td></tr></table></figure><p>需要注意下 tuple 最多包含6个元素的Tuple变量进行比较，超过这个数量，Swift会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let tuple1 = (1,3,34,123,135,244,2)</span><br><span class="line">let tuple2 = (1,2,21,421,123,232,4)</span><br><span class="line"></span><br><span class="line">tuple1 &gt; tuple2  //Binary operator &apos;&gt;&apos; cannot be applied to two &apos;(Int, Int, Int, Int, Int, Int, Int)&apos; operands</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swift-Tuple&quot;&gt;&lt;a href=&quot;#Swift-Tuple&quot; class=&quot;headerlink&quot; title=&quot;Swift - Tuple&quot;&gt;&lt;/a&gt;Swift - Tuple&lt;/h1&gt;&lt;p&gt;相比于 Objective-C ，Swift 提供了一种新的
      
    
    </summary>
    
      <category term="Swift学习笔记" scheme="https://github.com/jianxiongc/categories/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="https://github.com/jianxiongc/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift - 整数和浮点数</title>
    <link href="https://github.com/jianxiongc/2019/07/30/Swift%20-%20%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0/"/>
    <id>https://github.com/jianxiongc/2019/07/30/Swift - 整数和浮点数/</id>
    <published>2019-07-30T12:34:22.000Z</published>
    <updated>2019-07-31T09:15:16.257Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift-整数和浮点数"><a href="#Swift-整数和浮点数" class="headerlink" title="Swift - 整数和浮点数"></a>Swift - 整数和浮点数</h1><p>Swift 中 ，数字分为整数 （例如 ：1 / 10 / 100 /1000 等） 和浮点数 （ 例如 ： 3.14 / 1.44 / 2.71 等）</p><h2 id="整形-Int-amp-UInt"><a href="#整形-Int-amp-UInt" class="headerlink" title="整形 - Int &amp; UInt"></a>整形 - Int &amp; UInt</h2><p>根据一个整形变量所占的内存空间 （8 / 16 / 32 /64-bit） 以及整数是否带有符号 （Unsinged） ， Swift 一共定义了8中不同类型的整数类型 :</p><ul><li>Int (8 / 16 / 32 / 64)</li><li>UInt (8 / 16 / 32 / 64)</li></ul><p>Int 的四个类型 分别表示 8 / 16 / 32 /64-bit 的有符号整数<br>UInt 的四个类型分别代表 8 / 16 / 32 /64-bit 的无符号整数</p><p>但在 Swift 中通常不会去指定具体的类型 ，Swift 编译器会根据目标编译平台 ，把 Int 或 UInt 转换成对应的整数。</p><p>在64位平台上 ，可以分别使用 min 和 max 方法，来查看在64位机器上整数类型可以表达的数值范围: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Int.max    //9223372036854775807</span><br><span class="line">Int.min    //-9223372036854775808</span><br><span class="line"></span><br><span class="line">Int64.max  //9223372036854775807</span><br><span class="line">Int64.min  //-9223372036854775807</span><br><span class="line"></span><br><span class="line">Int32.max  //2147483647</span><br><span class="line">Int32.min  //-2147483648</span><br><span class="line"></span><br><span class="line">Int8.max   //127</span><br><span class="line">Int8.min   //-128</span><br><span class="line"></span><br><span class="line">Int16.max  //32767</span><br><span class="line">Int16.min  //-32768</span><br><span class="line"></span><br><span class="line">UInt.max   //9223372036854775807</span><br><span class="line">UInt.min   //0</span><br><span class="line"></span><br><span class="line">UInt64.max //9223372036854775807</span><br><span class="line">UInt64.min //0</span><br><span class="line"></span><br><span class="line">UInt32.max //4294967295</span><br><span class="line">UInt32.min //0</span><br><span class="line"></span><br><span class="line">UInt8.max  //255</span><br><span class="line">UInt8.min  //0</span><br></pre></td></tr></table></figure><h2 id="整数的常用表达方式"><a href="#整数的常用表达方式" class="headerlink" title="整数的常用表达方式"></a>整数的常用表达方式</h2><p>在 Swift 里，我们可以用多种方式来表示一个整数。 包括使用 10 进制 、 16 进制  、 8 进制 、 2 进制: </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let fifteenInDecimal = 10       //10</span><br><span class="line">let fiftennInHex = 0xff         //255</span><br><span class="line">let fifteenInOctal = 0o17       //15</span><br><span class="line">let fifteenInBinary = 0b0111    //7</span><br></pre></td></tr></table></figure><p>以及可以在数字中使用分隔符 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let inDecimal = 10       //10</span><br><span class="line">let inHex = 0xff         //255</span><br><span class="line">let inOctal = 0o17       //15</span><br><span class="line">let inBinary = 0b0111    //7</span><br><span class="line"></span><br><span class="line">let million = 1_000_000  //1000000</span><br></pre></td></tr></table></figure><p>除非我们所在硬件平台有特别明确的需求需要我们使用 <strong>UInt</strong> 来定义无符号整数 ， 否则我们应该尽可能使用 <strong>Int</strong> 来表达所有的整数类型 ， 哪怕我们确定一个整数一定是一个非负数。这会给我们减少很多不必要的类型转换的麻烦 。</p><h2 id="浮点型-Float-amp-Double"><a href="#浮点型-Float-amp-Double" class="headerlink" title="浮点型 Float &amp; Double"></a>浮点型 Float &amp; Double</h2><p>在 Swift 中 ，根据可以表达的精度范围，有两种不同的浮点类型 : </p><ul><li><strong>Float</strong> : 最多表达6位精度的浮点数</li><li><strong>Double</strong> : 至少可以表达15位精度的浮点数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let floatValue : Float = 1/3    //0.3333333</span><br><span class="line"></span><br><span class="line">let doubleValue : Double = 1/3  //0.3333333333333333</span><br></pre></td></tr></table></figure><p>除了使用常规的十进制表达浮点数之外 , 我们还可以使用科学计数法 。 例如 ，表示浮点数 PI :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var PI = 0.314e1    //3.14</span><br></pre></td></tr></table></figure><p>如果没有明确的需求，我们应该用Double来统一定义浮点数</p><h2 id="和数字有关的-Type-Inference"><a href="#和数字有关的-Type-Inference" class="headerlink" title="和数字有关的 Type Inference"></a>和数字有关的 Type Inference</h2><p>在 Swift 中 ，我们使用一个整数 ， 编译器会将它推导为 <strong>Int</strong> ， 使用一个浮点数 ，编译器会将它编译成 <strong>Double</strong><br>使用 <strong>type(of:)</strong> 查看一个变量或者常量的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let four = 5</span><br><span class="line">type(of: four)  //Int.Type</span><br><span class="line"></span><br><span class="line">let zeroPointFour = 0.5</span><br><span class="line">type(of: zeroPointFour) //Double.Type</span><br></pre></td></tr></table></figure><p>在 Swift 中 ，可以对不同类型数字的字面量进行计算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let three = 2.8 + 0.2  //3</span><br><span class="line">type(of: three)        //Double.Type</span><br><span class="line"></span><br><span class="line">let four = 1 + 3       //4</span><br><span class="line">type(of: four)         //Int.Type</span><br></pre></td></tr></table></figure><p>但是在 Swift 中 ，不能把不同数字类型的变量直接进行算术运算</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let zeroPointOne = 0.1;</span><br><span class="line">let one = 1;</span><br><span class="line"></span><br><span class="line">let onePointOne = zeroPointOne + one  //Binary operator &apos;+&apos; cannot be applied to operands of type &apos;Double&apos; and &apos;Int&apos;</span><br></pre></td></tr></table></figure><p>当对变量进行算数运算的时候，所有变量的类型必须是相同的，如果变量类型不同，我们必须明确将其中的一些变量进行类型转换。像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let zeroPointOne = 0.1;</span><br><span class="line">let one = 1;</span><br><span class="line"></span><br><span class="line">let onePointOne = zeroPointOne + Double(one)  //1.1</span><br></pre></td></tr></table></figure><p>通过 Double(value) 重新初始化了一个 Double 类型的 one 。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swift-整数和浮点数&quot;&gt;&lt;a href=&quot;#Swift-整数和浮点数&quot; class=&quot;headerlink&quot; title=&quot;Swift - 整数和浮点数&quot;&gt;&lt;/a&gt;Swift - 整数和浮点数&lt;/h1&gt;&lt;p&gt;Swift 中 ，数字分为整数 （例如 ：1 / 1
      
    
    </summary>
    
      <category term="Swift学习笔记" scheme="https://github.com/jianxiongc/categories/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="https://github.com/jianxiongc/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>蓝牙后台分析</title>
    <link href="https://github.com/jianxiongc/2019/07/24/iOS%E5%90%8E%E5%8F%B0%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/jianxiongc/2019/07/24/iOS后台分析/</id>
    <published>2019-07-23T23:12:12.000Z</published>
    <updated>2019-10-07T11:55:20.079Z</updated>
    
    <content type="html"><![CDATA[<h1 id="蓝牙-iOS-后台分析"><a href="#蓝牙-iOS-后台分析" class="headerlink" title="蓝牙 iOS 后台分析"></a>蓝牙 iOS 后台分析</h1><hr><h3 id="iOS支持的后台方式"><a href="#iOS支持的后台方式" class="headerlink" title="iOS支持的后台方式:"></a>iOS支持的后台方式:</h3><h3 id="Audio-AirPlay-and-Picture-in-Picture"><a href="#Audio-AirPlay-and-Picture-in-Picture" class="headerlink" title="Audio, AirPlay and Picture in Picture"></a><strong>Audio, AirPlay and Picture in Picture</strong></h3><p>此个选项包含四种场景，分别是：音频的播放，录音，AirPlay 及画中画的视频播放。<br>音频的播放：在播放音频时，即使应用退到后台，只要一直有音频在播放，那应用就可以一直在后台运行。</p><p>代码实现可参考：<a href>http://www.linuxidc.com/Linux/2012-08/68364.htm</a></p><p>录音：应用可以请求使用麦克风，而当开启了此后台选项，应用在使用麦克风的时候，即使退到后台，也可以一直后台运行，通过查看微信安装包中的 plist 文件，微信的语音聊天，就是通过这种方式实现的。而当该类应用退到后台后，iOS 系统的状态栏会变成红色，并在状态栏中显示正在使用麦克风的应用的名称。</p><p>AirPlay：AirPlay 是指将 iOS 设备，或者 Mac 设备上的音视频，同步到另一个设备中播放。举两个例子，第一个是把 iPhone 上的音乐通过蓝牙的方式在汽车的蓝牙音响播放，第二个是把 iPhone 上的视频，同步到智能电视屏幕上播放。此功能一般用于多端及多屏的交互。<br>关于 AirPlay 的开发文档：<a href>http://nto.github.io/AirPlay.html</a></p><p>画中画的视频播放：画中画是 iPad 版本的 iOS 9 新增加的功能，可以在 iOS 的桌面，或者其他应用的界面的上面播放视频，从而该视频区域所属的应用就可以后台运行了。此功能现在只在 iPad 应用中提供。<br>代码实现可参考：<a href>http://www.cocoachina.com/ios/20150714/12558.html</a></p><h3 id="Location-updates"><a href="#Location-updates" class="headerlink" title="Location updates"></a>Location updates</h3><p>一般用于导航应用中，开启此选项后，应用退到后台，还可以得到系统的定位更新，从而使得应用可以根据定位的变化做出不同的反应。<br>代码实现可参考：<a href>https://github.com/voyage11/Location</a></p><h3 id="Voice-over-IP"><a href="#Voice-over-IP" class="headerlink" title="Voice over IP"></a>Voice over IP</h3><p>VOIP 类的应用允许用户使用网络而不是手机打电话，因此这一类的应用需要保持同它相关的服务的网络连接，用以收到来电事件和其他数据。iOS 不是通过一直让该应用处于激活状态来达到这个目的，而是同样也会将这类的应用挂起，但同时会在应用被挂起期间由系统接管它的 VOIP 的 Socket，当这个 Socket 有数据通信时，系统会再次唤醒处于挂起状态的应用，同时将 Socket 的控制权交还给该应用，以让其正常的处理来电事件和其他数据。</p><h3 id="Newsstand-downloads"><a href="#Newsstand-downloads" class="headerlink" title="Newsstand downloads"></a>Newsstand downloads</h3><p>在 iOS 开发中，有一类叫报刊杂志类应用比较特别，在 iOS 9 之前的系统中，此类应用会统一收在系统内置的「报刊杂志」应用中，在 iOS 9 中则去掉了内置的「报刊杂志」应用，此类应用得以以单独的图标入口出现在桌面中。<br>此后台运行的选项就是提供给报刊杂志类应用可以在后台下载及处理报刊杂志内容，而下载的过程需要使用 NewsstandKit 中的 NKAssetDownload 进行下载。需要注意的是，下载的过程中，应用可能还是会被挂起，甚至应用被退出，而 iOS 会在 Wi-Fi 环境下继续下载，直到下载完成。而一旦下载完成，如果应用只是被挂起，则 iOS 会唤醒对应的应用，回调对应的事件；如果应用已经退出，则会启动应用，在启动参数中会带上对应的标识表示这次启动是因为下载报刊杂志内容完成。<br>代码实现可参考：<a href>http://www.viggiosoft.com/blog/blog/2011/10/17/ios-newsstand-tutorial/</a></p><h3 id="External-Accessory-communication"><a href="#External-Accessory-communication" class="headerlink" title="External Accessory communication"></a>External Accessory communication</h3><p>此选项提供给一些 MFi 外设通过蓝牙，或者 Lightning 接头等方式与 iOS 设备连接，从而可在外设发送消息时，唤醒已经被挂起的应用。而一旦被唤醒，一般情况下， 应用只有最多 10 秒钟的执行时间。<br>MFi 外设：是指通过苹果 MFi 认证的设备，而 MFi 认证是对其授权配件厂商生产的外置配件的一种标识使用许可，是 Made for iOS 的英文缩写。</p><h3 id="Uses-Bluetooth-LE-accessories"><a href="#Uses-Bluetooth-LE-accessories" class="headerlink" title="Uses Bluetooth LE accessories"></a>Uses Bluetooth LE accessories</h3><p>此选项与 External Accessory communication 类似，只是此选项无需限制 MFi 外设，而需要的是 Bluetooth LE 设备。</p><h3 id="Acts-as-a-Bluetooth-LE-accessory"><a href="#Acts-as-a-Bluetooth-LE-accessory" class="headerlink" title="Acts as a Bluetooth LE accessory"></a>Acts as a Bluetooth LE accessory</h3><p>此选项是指 iOS 设备作为一个蓝牙外设连接时，对应的应用可以后台运行，但是使用此模式需要用户进行授权认证。</p><h3 id="Background-fetch"><a href="#Background-fetch" class="headerlink" title="Background fetch"></a>Background fetch</h3><p>iOS 7 新增加的一个选项，用于即使在后台，也需要频繁更新数据的应用。例如一个 PM2.5 的应用，需要几个小时更新一次数据，那么可以开启此选项，设置一个时间间隔，从而让 iOS 在间隔时间内在后台启动该应用，执行指定数据的获取工作，而此过程最多只能执行 30 秒钟。<br>代码实现可参考：<a href>http://objccn.io/issue-5-5/</a></p><h3 id="Remote-notifications"><a href="#Remote-notifications" class="headerlink" title="Remote notifications"></a>Remote notifications</h3><p>iOS 7 新增加的一个选项，是一种静默推送，它有别于一般的推送，应用收到此类推送后，不会有任何的界面提示，而当应用退出或者挂起时收到此类推送，iOS 也会启动或者唤醒对应的应用。<br>例如一个阅读应用，用户订阅的博客更新了，那么可以先发一个静默推送，应用收到此种推送后，可以先把用户订阅的博客内容都下载好，再通知用户，这样用户一打开应用就可以马上开始阅读。<br>收到静默推送，会回调对应的回调方法，而此回调方法最多只能执行 30 秒钟。<br>代码实现可参考：<a href>http://objccn.io/issue-5-5/</a></p><h3 id="基于-NSURLSession-的后台传输"><a href="#基于-NSURLSession-的后台传输" class="headerlink" title="基于 NSURLSession 的后台传输"></a>基于 NSURLSession 的后台传输</h3><p>此为 iOS 7 新增加的特性，用于在后台下载或者上传大文件，步骤如下：创建后台传输用的 NSURLSession 对象；向这个对象中加入对应的传输的 NSURLSessionTask，并开始传输；在实现 AppDelegate 里实现 -application:handleEventsForBackgroundURLSession:completionHandler: 方法，以刷新 UI 及通知系统传输结束。<br>一旦后台传输的状态发生变化（包括正常结束和失败）的时候，应用将被唤醒并运行 AppDelegate 中的回调。<br>但是也有一些限制，后台传输只会通过 Wi-Fi 来进行。后台下载的时间与以前的关闭应用后X分钟的模式不一样，而是为了节省电力变为离散式的下载。<br>代码实现可以参考：<a href>http://onevcat.com/2013/08/ios7-background-multitask/</a></p><h3 id="其他后台运行操作"><a href="#其他后台运行操作" class="headerlink" title="其他后台运行操作"></a>其他后台运行操作</h3><h4 id="一直循环播放一段没声音的音频"><a href="#一直循环播放一段没声音的音频" class="headerlink" title="一直循环播放一段没声音的音频"></a>一直循环播放一段没声音的音频</h4><p>可以在后台选项中选择「Audio, AirPlay and Picture in Picture」，而开始循环播放一段是没声音的音频，即在 Audio Unit 回调函数中使用 kAudioUnitRenderAction_OutputIsSilence 标志位，但是这种方式两个大的缺点：</p><ol><li>苹果的审核人员如果发现，会被拒；</li><li>应用程序的 Audio Session 不能被打断。当应用执行在后台时，只要另一个应用使用 kAudioSessionCategory_RecordAndPlay （比如 Skype）或者 kAudioSessionCategory_SoloAmbientSound，那么该应用就会被立即打断。<br>代码实现可参考：<a href>https://github.com/marcop/MMPDeepSleepPreventer</a></li></ol><h4 id="越狱下开发-System-级别的应用"><a href="#越狱下开发-System-级别的应用" class="headerlink" title="越狱下开发 System 级别的应用"></a>越狱下开发 System 级别的应用</h4><p>一般的应用都是 Mobile 级别的，在越狱的情况下，可以开发一个 System 级别的应用，从而使得应用不受 iOS 一般应用的限制，实现真正的后台运行，但是缺点就是应用只能运行在越狱设备上，也不能上 App Store。<br>代码实现可参考：<a href>http://www.cnblogs.com/doudouyoutang/p/4712331.html</a></p><h4 id="iOS-BackgroundMode-Documents参考链接"><a href="#iOS-BackgroundMode-Documents参考链接" class="headerlink" title="iOS BackgroundMode Documents参考链接:"></a>iOS BackgroundMode Documents参考链接:</h4><p><a href>https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html</a></p><h4 id="iOS-能耗参考"><a href="#iOS-能耗参考" class="headerlink" title="iOS 能耗参考:"></a>iOS 能耗参考:</h4><p><a href="http://pv0t5k9bg.bkt.clouddn.com/238_writing_energy_efficient_apps.pdf" target="_blank" rel="noopener">238_writing_energy_efficient_apps</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;蓝牙-iOS-后台分析&quot;&gt;&lt;a href=&quot;#蓝牙-iOS-后台分析&quot; class=&quot;headerlink&quot; title=&quot;蓝牙 iOS 后台分析&quot;&gt;&lt;/a&gt;蓝牙 iOS 后台分析&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;iOS支持的后台方式&quot;&gt;&lt;a href=&quot;#iO
      
    
    </summary>
    
    
      <category term="蓝牙 后台" scheme="https://github.com/jianxiongc/tags/%E8%93%9D%E7%89%99-%E5%90%8E%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>uni-app踩坑记录</title>
    <link href="https://github.com/jianxiongc/2019/07/22/uni-app%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <id>https://github.com/jianxiongc/2019/07/22/uni-app踩坑记录/</id>
    <published>2019-07-22T13:34:22.000Z</published>
    <updated>2019-07-22T13:35:36.127Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>注意像素尺寸 ,uni-app官方推荐用upx,小程序是rpx,weex是px，不要弄混了。<a href="https://uniapp.dcloud.io/frame?id=%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D" target="_blank" rel="noopener">https://uniapp.dcloud.io/frame?id=%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D</a></p></li><li><p>注意HBudiler 保存代码机制，默认代码不会保存，记得随手写完command/ctrl + s,编译时检查代码是否都保存了</p></li><li><p>image 标签一定要设置高度和宽度，100%  或者 绝对定位都是无效的。地图也一样。 image标签里边不要套text等标签了，不生效；</p></li><li><p>uni-app同小程序一样 display 默认不是flex,所以在使用到flex的特性是 需要加上display:flex。</p></li><li><p>有些情况下需要获取全屏高度，但是不能使用flex:1 或者 abosulte的方式。这个时候可以采用 获取 系统屏幕宽度  / 750 * 系统屏幕高度。代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const systemInfo = uni.getSystemInfoSync();</span><br><span class="line">if (systemInfo.windowWidth &amp;&amp; systemInfo.windowHeight) &#123;</span><br><span class="line">let multiple = 750/systemInfo.windowWidth;</span><br><span class="line">that.screenHeight = systemInfo.windowHeight * multiple;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>uniapp 给Data赋值时和微信小程序的区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    value: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//小程序采用</span><br><span class="line">this.setData(&#123;</span><br><span class="line">  value: 1</span><br><span class="line">&#125;)</span><br><span class="line">//uni-app</span><br><span class="line">this.value = 1;</span><br></pre></td></tr></table></figure></li><li><p>uni-app map的 controls 中 position 使用的是px，而外部css使用的upx,这里要注意不要写成upx的值了。 并且position 只支持了 top 和 left定位。 如果要bottom 的话 需要先计算屏幕高度，然后再更改一次正确的位置。默认可以给 iPhone 7标准尺寸的 绝对定位。</p></li><li><p>cover-view 或者 cover-image 支持position 但同样  只支持top 和 left 。需要写 bottom 同 7。</p></li><li><p>iconfont 的使用方式与小程序不同 ，跟weex方式差不多，需要注意copy下来的地址加协议头。<a href="https://uniapp.dcloud.io/frame?id=%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87" target="_blank" rel="noopener">https://uniapp.dcloud.io/frame?id=%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87</a>， text支持  ,cover-view 在模拟器显示 真机不显示</p></li><li><p><map> 标签中的@regionchange  不触发</map></p><blockquote><p>官方说明：事件映射表中没有的原生事件也可以使用，例如map组件的regionchange 事件直接在组件上写成 @regionchange,同时这个事件也非常特殊，它的 event type 有 begin 和 end 两个，导致我们无法在handleProxy 中区分到底是什么事件，所以你在监听此类事件的时候同时监听事件名和事件类型既 &lt;map @regionchange=”functionName” @end=”functionName” @begin=”functionName”&gt;<map>。</map></p></blockquote></li><li><p>uni-app 官方文档中 map并没有支持多边形，但仍然可以按照微信小程序的方式实现。</p></li><li><p>支付宝小程序 如果不是在首页 ，左上角会始终出现返回按钮或者回到主页按钮，不建议在小程序中添加启动页面， 原有启动逻辑可以放在App生命周期中。</p></li><li><p>支付宝小程序想设置navigationBar自定义，文档中并未说明，但在示例Demo中发现 通过页面json文件，”transparentTitle”: “auto”可以实现navigationBar的自定义 ，但是要注意支付宝左上角会有按钮。</p></li><li><p>注意：以:style=””这样的方式设置px像素值，其值为实际像素，不会被编译器转换。</p></li><li><p>非H5端不支持 <a href="https://cn.vuejs.org/v2/guide/class-and-style.html" target="_blank" rel="noopener">Vue官方文档：Class 与 Style 绑定</a> 中的 classObject 和 styleObject 语法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//不支持示例</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;view :class=&quot;[activeClass]&quot; :style=&quot;[baseStyles,overridingStyles]&quot;&gt;&lt;/view&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                activeClass: &#123;</span><br><span class="line">                    &apos;active&apos;: true,</span><br><span class="line">                    &apos;text-danger&apos;: false</span><br><span class="line">                &#125;,</span><br><span class="line">                baseStyles: &#123;</span><br><span class="line">                    color: &apos;green&apos;,</span><br><span class="line">                    fontSize: &apos;30px&apos;</span><br><span class="line">                &#125;,</span><br><span class="line">                overridingStyles: &#123;</span><br><span class="line">                    &apos;font-weight&apos;: &apos;bold&apos;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ol><p>### </p><ol><li>iconfont 不显示</li></ol><ul><li>看看css文件中是否导入 font-face</li><li>text 的class中是否有font-family</li><li>iconfont文件中是否这个图标</li><li>css是否存在同名的 iconfont class.</li></ul><ol><li>css 标签选择器设置的属性可能权重过大，导致后面的类选择器无法覆盖它所设置的属性</li><li>uni-app button标签 自带了border属性 ，如果要去掉 参考<a href="http://ask.dcloud.net.cn/question/62262" target="_blank" rel="noopener">http://ask.dcloud.net.cn/question/62262</a></li><li>v-for 中 @click 带参数，必须设置key ，不然click的参数会为空</li><li>map 中绘制线，一定要注意polyline 类型是Array, 虽然它里面是一个Object,但是最外层一定要变成Array，不然会无法显示</li><li>data中声明 mpType的变量，会导致所有的Data设置失效。官方文档并没有将其保留为关键字，但是他的存在确实是所有的Data赋值失效了。主要是与App.mpType冲突，注意下这个坑。 </li><li>mac和windows 下 uni-requset  的Promise支持可能不一致代码如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">uni.request().then(data =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;).catch(error =&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>这段代码在Windows下编译并能正常执行到iOS ，Andorid的微信小程序端。在Mac 下编译会报 ui-request…then not functoin 。已提交issuse  <a href="https://github.com/dcloudio/uni-app/issues/351">https://github.com/dcloudio/uni-app/issues/351</a></p><ol><li>uni-bluetooth ， 注意外围设备的services 和characteristic  在iOS 都是大写，在android 都是小写。 注意 createConnection 后还需要discoverServices 和 discovcerCharacteristics 。</li><li>map marker . label = {} 时Android 会出现小蓝点，iOS不会。设置marker的label 为null可以解决。</li><li>微信小程序下，怀疑relaunch页面跳转没有清除， 具体表现为在B页面设置蓝牙状态监听，relaunch 到 C页面，B页面依然能打印蓝牙状态监听的log<a href="https://developers.weixin.qq.com/community/develop/doc/0000e8551d0f309fadc8b123751000?fromCreate=1" target="_blank" rel="noopener">https://developers.weixin.qq.com/community/develop/doc/0000e8551d0f309fadc8b123751000?fromCreate=1</a></li><li>小程序的triggerEvent在uniapp中不支持；</li><li>uni-app 中在data使用 Object.assgin 一定要加在Data中的最后一行，不然小程序会在iOS 9.3的机器上出现白屏问题。目前不清楚是小程序的问题还是uni-app的问题。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;注意像素尺寸 ,uni-app官方推荐用upx,小程序是rpx,weex是px，不要弄混了。&lt;a href=&quot;https://uniapp.dcloud.io/frame?id=%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D&quot; t
      
    
    </summary>
    
    
      <category term="uni-app 微信小程序" scheme="https://github.com/jianxiongc/tags/uni-app-%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据结构基础-数组</title>
    <link href="https://github.com/jianxiongc/2019/07/21/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80-%E6%95%B0%E7%BB%84/"/>
    <id>https://github.com/jianxiongc/2019/07/21/数据结构基础-数组/</id>
    <published>2019-07-20T23:19:07.000Z</published>
    <updated>2019-10-21T07:08:50.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构基础-数组"><a href="#数据结构基础-数组" class="headerlink" title="数据结构基础 - 数组"></a>数据结构基础 - 数组</h1><p>什么是数组？<br>数组对应的英文是Array ， 是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。数组是最为简单，最为常用的数据结构。<br>已整数数组为例，数组的存储形式如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/21/数据结构基础-数组/media/1.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>数组里每一个元素都有自己的下标，这个下标从0开始，一直到数组长度-1.</p><p>数组的另一个特点，就是在程序中顺序存储，因此可以很好的实现逻辑上的顺序表。<br>数组在内存中的顺序存储，具体是什么样子呢。</p><p>内存是由一个个连续的内存单元组成的，每一个内存单元都有自己的地址。在这些内存单元中，有些被其他数据占用了，有些是空闲的。</p><p>数组的每一个元素，都存储在内存单元中，并且元素之间精密排列，即不能打乱元素的存储顺序，也不能跳过过个存储单元进行存储。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/21/数据结构基础-数组/media/2.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在上图中，橙色的格子代表空闲的存储单元，灰色的格子代表已占用的存储单元，而蓝色的连续格子代表数组在内存中的位置。<br>不同类型的数组，每个元素所占的字节个数也不同，本图只是一个简单的示意图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据结构基础-数组&quot;&gt;&lt;a href=&quot;#数据结构基础-数组&quot; class=&quot;headerlink&quot; title=&quot;数据结构基础 - 数组&quot;&gt;&lt;/a&gt;数据结构基础 - 数组&lt;/h1&gt;&lt;p&gt;什么是数组？&lt;br&gt;数组对应的英文是Array ， 是有限个相同类型的变量所
      
    
    </summary>
    
      <category term="算法学习笔记" scheme="https://github.com/jianxiongc/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Array" scheme="https://github.com/jianxiongc/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>Swift - 变量与常量</title>
    <link href="https://github.com/jianxiongc/2019/07/20/Swift%20-%20%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/"/>
    <id>https://github.com/jianxiongc/2019/07/20/Swift - 变量与常量/</id>
    <published>2019-07-20T15:20:04.000Z</published>
    <updated>2019-07-31T09:15:35.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Swift-变量与常量"><a href="#Swift-变量与常量" class="headerlink" title="Swift - 变量与常量"></a>Swift - 变量与常量</h1><h2 id="变量和常量"><a href="#变量和常量" class="headerlink" title="变量和常量"></a>变量和常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量是编程语言中最常用的语法元素，它们用于在程序中把一个名字（例如：swiftString）和某种特定类型的值（例如：”Swift is fun.”）关联起来。</p><p>在Swift中，我们使用关键字 <strong>var</strong> 来定义各种不同的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var hello = &quot;你好&quot;</span><br></pre></td></tr></table></figure><p>例如，定义一些熟悉的基本类型变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//: #### Fundamental types</span><br><span class="line"></span><br><span class="line">//: Integer</span><br><span class="line">var hours = 24</span><br><span class="line"></span><br><span class="line">//: Double</span><br><span class="line">var PI = 3.14</span><br><span class="line"></span><br><span class="line">//: Bool</span><br><span class="line">var swiftIsFun = true</span><br><span class="line"></span><br><span class="line">//: String</span><br><span class="line">var hello = &quot;你好&quot;</span><br></pre></td></tr></table></figure><p>除了基本类型变量之外，Swift 还有 <strong>Tuple</strong> ,多类型数据混合到一个数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//: Tuple - Pack many types of values together</span><br><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">var me = (&quot;name&quot;,&quot;jianxiong&quot;,[&quot;like&quot; : [&quot;code&quot;,&quot;code2&quot;,&quot;code3&quot;]],18)</span><br><span class="line"></span><br><span class="line">me.0  //&quot;name&quot;</span><br><span class="line"></span><br><span class="line">me.1  //&quot;jianxiong&quot;</span><br><span class="line"></span><br><span class="line">me.2  //[&quot;like&quot; : [&quot;code&quot;,&quot;code2&quot;,&quot;code3&quot;]]</span><br><span class="line"></span><br><span class="line">me.3  //18</span><br></pre></td></tr></table></figure><p>定义好一个Tuple之后，就可以使用代码 me.0 me.1 me.2 这样的方式来访问Tuple中的变量了，同时也可以直接修改变量的值 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// update Tuple value</span><br><span class="line">me.3 = 22</span><br><span class="line"></span><br><span class="line">var hour = 24 </span><br><span class="line">hour = 12</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="如果我们定义的值不希望被修改"><a href="#如果我们定义的值不希望被修改" class="headerlink" title="如果我们定义的值不希望被修改"></a>如果我们定义的值不希望被修改</h3><p>定义常量的方法和变量类似，我们把关键字<strong>var</strong>，变成关键字<strong>let</strong>就可以了。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let minutes = 30</span><br><span class="line">let fireIsHot = true</span><br></pre></td></tr></table></figure><p>一旦我们定义常量之后，就不能再修改常量的值了，否则，编译器会告诉我们发生了错误。例如，我们修改常量fireIsHot：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fireIsHot = false</span><br></pre></td></tr></table></figure><p>这时，我们就可以在Playground中直接看到一个编译错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cannot assign to value: &apos;firelsHot&apos; is a &apos;let&apos; constant</span><br></pre></td></tr></table></figure><p>只要程序中的变量值不会被修改，就总应该使用let来定义它。这不仅可以防止变量被意外修改，编译器还可以针对常量做更多优化。</p><h2 id="Type-inference-annotation"><a href="#Type-inference-annotation" class="headerlink" title="Type inference / annotation"></a>Type inference / annotation</h2><p>在前面的例子里，我们可以发现，无论是整数、浮点数、字符串还有Tuple，我们都没有明确的指定变量的类型， Swift编译器会根据我们为变量的赋值自动推导变量的类型，这个特性，在Swift里叫做Type Inference。</p><p>但有时，我们定义变量的时候，并不能确定变量的初始值，这个时候，我们就必须像下面这样明确告诉编译器我们需要的变量类型：var Name:Type。这种通过:Type指定变量类型的形式，在Swift中叫做Type annotation。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var x: Int</span><br><span class="line">var s: String</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Swift-变量与常量&quot;&gt;&lt;a href=&quot;#Swift-变量与常量&quot; class=&quot;headerlink&quot; title=&quot;Swift - 变量与常量&quot;&gt;&lt;/a&gt;Swift - 变量与常量&lt;/h1&gt;&lt;h2 id=&quot;变量和常量&quot;&gt;&lt;a href=&quot;#变量和常量&quot; c
      
    
    </summary>
    
      <category term="Swift学习笔记" scheme="https://github.com/jianxiongc/categories/Swift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Swift" scheme="https://github.com/jianxiongc/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>协程 阿里开源库 coobjc 初步分析</title>
    <link href="https://github.com/jianxiongc/2019/07/16/%E5%8D%8F%E7%A8%8B-%E9%98%BF%E9%87%8C%E5%BC%80%E6%BA%90%E5%BA%93-coobjc-%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/</id>
    <published>2019-07-16T02:09:24.000Z</published>
    <updated>2019-10-21T13:52:23.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><em>协程是计算机程序的一类组件，推广了非抢先多任务的子程序，允许执行被挂起与被恢复。</em><br><em>相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。</em><br><em>协程源自 Simula 和 Modula-2 语言，但也有其他语言支持。</em><br><em>协程更适合于用来实现彼此熟悉的程序组件，如合作式多任务、异常处理、事件循环、迭代器、无限列表和管道。</em><br><em>根据高德纳的说法, 马尔文·康威于1958年发明了术语 coroutine 并用于构建汇编程序。</em><br><em>—— Wikipedia</em></p><h2 id="coobjc-解决的问题"><a href="#coobjc-解决的问题" class="headerlink" title="coobjc 解决的问题"></a>coobjc 解决的问题</h2><h3 id="iOS-异步编程问题"><a href="#iOS-异步编程问题" class="headerlink" title="iOS 异步编程问题"></a>iOS 异步编程问题</h3><p>官网描述:</p><p>基于 Block 的异步编程回调是目前 iOS 使用最广泛的异步编程方式，iOS 系统提供的 GCD 库让异步开发变得很简单方便，但是基于这种编程方式的缺点也有很多，主要有以下几点：</p><p>容易进入”嵌套地狱”<br>错误处理复杂和冗长<br>容易忘记调用 completion handler<br>条件执行变得很困难<br>从互相独立的调用中组合返回结果变得极其困难<br>在错误的线程中继续执行<br>难以定位原因的多线程崩溃<br>锁和信号量滥用带来的卡顿、卡死<br>上述问题反应到线上应用本身就会出现大量的多线程崩溃</p><h3 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h3><p>官网描述:</p><p><strong>简明</strong><br>概念少：只有很少的几个操作符，相比响应式几十个操作符，简直不能再简单了<br>原理简单: 协程的实现原理很简单，整个协程库只有几千行代码<br><strong>易用</strong><br>使用简单：它的使用方式比 GCD 还要简单，接口很少<br>改造方便：现有代码只需要进行很少的改动就可以协程化，同时我们针对系统库提供了大量协程化接口<br><strong>清晰</strong><br>同步写异步逻辑：同步顺序方式写代码是人类最容易接受的方式，这可以极大的减少出错的概率<br>可读性高: 使用协程方式编写的代码比 block 嵌套写出来的代码可读性要高很多<br><strong>性能</strong><br>调度性能更快：协程本身不需要进行内核级线程的切换，调度性能快，即使创建上万个协程也毫无压力<br>减少卡顿卡死: 协程的使用以帮助开发减少锁、信号量的滥用，通过封装会引起阻塞的 IO 等协程接口，可以从根源上减少卡顿、卡死，提升应用整体的性能</p><h3 id="核心能力"><a href="#核心能力" class="headerlink" title="核心能力"></a>核心能力</h3><p>提供了类似C#和Javascript语言中的Async/Await编程方式支持，在协程中通过调用await方法即可同步得到异步方法的执行结果，非常适合IO、网络等异步耗时调用的同步顺序执行改造。<br>提供了类似Kotlin中的Generator功能，用于懒计算生成序列化数据，非常适合多线程可中断的序列化数据生成和访问。<br>提供了Actor Model的实现，基于Actor Model，开发者可以开发出更加线程安全的模块，避免由于直接函数调用引发的各种多线程崩溃问题。<br>提供了元组的支持，通过元组Objective-C开发者可以享受到类似Python语言中多值返回的好处。</p><h3 id="内置系统扩展库"><a href="#内置系统扩展库" class="headerlink" title="内置系统扩展库"></a>内置系统扩展库</h3><ul><li><p>提供了对NSArray、NSDictionary等容器库的协程化扩展，用于解决序列化和反序列化过程中的异步调用问题。</p></li><li><p>提供了对NSData、NSString、UIImage等数据对象的协程化扩展，用于解决读写IO过程中的异步调用问题。</p></li><li><p>提供了对NSURLConnection和NSURLSession的协程化扩展，用于解决网络异步请求过程中的异步调用问题。</p></li><li><p>提供了对NSKeyedArchieve、NSJSONSerialization等解析库的扩展，用于解决解析过程中的异步调用问题。</p></li></ul><h3 id="coobjc-设计"><a href="#coobjc-设计" class="headerlink" title="coobjc 设计"></a>coobjc 设计</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/1.png" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure><p>最底层是协程内核，包含了栈切换的管理、协程调度器的实现、协程间通信channel的实现等。<br>中间层是基于协程的操作符的包装，目前支持async/await、Generator、Actor等编程模型。<br>最上层是对系统库的协程化扩展，目前基本上覆盖了Foundation和UIKit的所有IO和耗时方法。</p><h3 id="核心实现原理"><a href="#核心实现原理" class="headerlink" title="核心实现原理"></a>核心实现原理</h3><p>协程的核心思想是控制调用栈的主动让出和恢复。一般的协程实现都会提供两个重要的操作：</p><p>Yield：是让出cpu的意思，它会中断当前的执行，回到上一次Resume的地方。<br>Resume：继续协程的运行。执行Resume后，回到上一次协程Yield的地方。</p><p>我们基于线程的代码执行时候，是没法做出暂停操作的，我们现在要做的事情就是要代码执行能够暂停，还能够再恢复。 基本上代码执行都是一种基于调用栈的模型，所以如果我们能把当前调用栈上的状态都保存下来，然后再能从缓存中恢复，那我们就能够实现yield和 resume。<br>实现这样操作有几种方法呢？</p><p>第一种：利用glibc 的 ucontext组件(云风的库)。<br>第二种：使用汇编代码来切换上下文(实现c协程)，原理同ucontext。<br>第三种：利用C语言语法switch-case的奇淫技巧来实现（Protothreads)。<br>第四种：利用了 C 语言的 setjmp 和 longjmp。<br>第五种：利用编译器支持语法糖。</p><p>上述第三种和第四种只是能过做到跳转，但是没法保存调用栈上的状态，看起来基本上不能算是实现了协程，只能算做做demo，第五种除非官方支持，否则自行改写编译器通用性很差。而第一种方案的 ucontext 在iOS上是废弃了的，不能使用。那么我们使用的是第二种方案，自己用汇编模拟一下 ucontext。<br>模拟ucontext的核心是通过getContext和setContext实现保存和恢复调用栈。需要熟悉不同CPU架构下的调用约定(Calling Convention). 汇编实现就是要针对不同cpu实现一套，我们目前实现了 armv7、arm64、i386、x86_64，支持iPhone真机和模拟器。</p><h2 id="官方例子"><a href="#官方例子" class="headerlink" title="官方例子"></a>官方例子</h2><p>整体结构如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/3.jpg" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure><ul><li><strong>cokit</strong>       cokit库为Foundation和UIKit系统库提供了一个协程封装，它依赖于coobjc库，为IO，网络等耗时的方法提供协同处理的封装。</li><li><strong>coobjc</strong>    coobjc的Objective-C版实现的源代码</li><li>*<em>coswift  *</em> coswift的Swift版源代码</li><li><strong>Examples</strong>    coobjcBaseExample是OC版本的Demo    coSwiftExample是OC版本的Demo    <h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3>直接看看coobjcBaseExample的效果<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/4.jpg" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure></li></ul><p>这个界面可以看到一个简单的列表页。<br>对应到代码中的<strong>KMDiscoverListViewController</strong><br>ViewDidLoad中有如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [self setupTableView];</span><br><span class="line">    [self requestMovies];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法名可以得知，<strong>requestMovies</strong>实现了网络拉取电影列表的功能。<br>看 <strong>requestMovies</strong> 中的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)requestMovies</span><br><span class="line">&#123;</span><br><span class="line">    co_launch(^&#123;</span><br><span class="line">        NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;];</span><br><span class="line">        [self.refreshControl endRefreshing];</span><br><span class="line">        </span><br><span class="line">        if (dataArray != nil)</span><br><span class="line">        &#123;</span><br><span class="line">            [self processData:dataArray];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            [self.networkLoadingViewController showErrorView];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先抛开co_launch不管，可以发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;];</span><br></pre></td></tr></table></figure><p>实现了网络请求，获取数据，<strong>getDiscoverList</strong>实现代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray*)getDiscoverList:(NSString *)pageLimit;</span><br><span class="line">&#123;</span><br><span class="line">    NSString *url = [NSString stringWithFormat:@&quot;%@&amp;page=%@&quot;, [self prepareUrl], pageLimit];</span><br><span class="line">    id json = [[DataService sharedInstance] requestJSONWithURL:url];</span><br><span class="line">    NSDictionary* infosDictionary = [self dictionaryFromResponseObject:json jsonPatternFile:@&quot;KMDiscoverSourceJsonPattern.json&quot;];</span><br><span class="line">    return [self processResponseObject:infosDictionary];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码可以发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id json = [[DataService sharedInstance] requestJSONWithURL:url];</span><br></pre></td></tr></table></figure><p>这一段实现了网络请求，然后继续去进入<strong>requestJSONWithURL</strong>去看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (id)requestJSONWithURL:(NSString*)url CO_ASYNC&#123;</span><br><span class="line">    SURE_ASYNC</span><br><span class="line">    return await([self.jsonActor sendMessage:url]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候发现 <strong>SURE_ASYNC</strong> 和 <strong>awiat</strong> 类似于<strong>ES7</strong>中的<strong>async</strong> 和 <strong>await</strong>，<strong>ES7</strong>中<strong>async-await</strong>是<strong>promise</strong>和<strong>generator</strong>的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性，看起来这块起到了类似的作用。<br>再来仔细了解下协程。</p><h3 id="协程入门"><a href="#协程入门" class="headerlink" title="协程入门"></a>协程入门</h3><p>上面的<strong>核心实现原理</strong>中有提到，实现核心的<strong>yield</strong>和<strong>resume</strong>有五种方法，<br>其中说到第三、四种只能做到过跳转，没办法保存调用栈,无法真正的实现协程。第五种除非官方支持。第一种ucontext在iOS是废弃了的。那么第二种方案，自己用汇编模拟ucontext。</p><p>首先，ucontext 是啥？</p><p><strong>ucontext</strong> 机制是<strong>GUN C</strong>库提供的一组用于创建、保存、切换用户态执行context的API。主要包括以下四个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);</span><br><span class="line">int swapcontext(ucontext_t *oucp, ucontext_t *ucp);</span><br><span class="line">int getcontext(ucontext_t *ucp);</span><br><span class="line">int setcontext(const ucontext_t *ucp);</span><br></pre></td></tr></table></figure><p>详细参见<br>[我所理解的ucontext族函数]<a href="https://www.jianshu.com/p/dfd7ac1402f0" target="_blank" rel="noopener">https://www.jianshu.com/p/dfd7ac1402f0</a><br>[构建C协程之ucontext篇]<a href="https://blog.csdn.net/gettogetto/article/details/53306897" target="_blank" rel="noopener">https://blog.csdn.net/gettogetto/article/details/53306897</a></p><p>来看一段简单的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">//由于在Mac OS X 10.6.6 ucontext被弃用的关系 ，需要使用sys/ucontext.h</span><br><span class="line">#include &lt;sys/ucontext.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">// ----&gt; ucontext </span><br><span class="line">ucontext_t context;</span><br><span class="line">getcontext(&amp;context);</span><br><span class="line">puts(&quot;Hello world&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line">setcontext(&amp;context);</span><br><span class="line"></span><br><span class="line">// ----&gt; goto </span><br><span class="line">// loop: puts(&quot;%s\n&quot;,&quot;Hello world&quot;);</span><br><span class="line">//     sleep(1);</span><br><span class="line">//     goto loop;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存上述代码到 example.c，执行编译命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc example.c -o example</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jianxiongc/blog/master/2019/07/16/协程-阿里开源库-coobjc-初步分析/media/5.jpg" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure><p>可以看到这里会不断执行，通过setcontext和getcontext实现切换。<br>更详细参见<br><a href="https://www.jianshu.com/p/dfd7ac1402f0" target="_blank" rel="noopener">我所理解的ucontext族函数</a><br><a href="https://blog.csdn.net/gettogetto/article/details/53306897" target="_blank" rel="noopener">构建C协程之ucontext篇</a><br>上面<strong>核心实现原理</strong>中讲到了第二种：使用汇编代码来切换上下文(实现c协程)，原理同ucontext。<br>我们在coobjc中的库中发现了唯一一个汇编文件<strong>coroutine_context.s</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://uploader.shimo.im/f/O0mWE5ILsUwn44oQ.jpg!thumbnail" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure><p>在汇编文件中发现主要提供了三个方法</p><ul><li>_coroutine_getcontext</li><li>_coroutine_begin</li><li>_coroutine_setcontext</li></ul><p>同样在 <strong>coroutine_context.h</strong>中暴露了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern int coroutine_getcontext (coroutine_ucontext_t *__ucp);</span><br><span class="line"></span><br><span class="line">extern int coroutine_setcontext (coroutine_ucontext_t *__ucp);</span><br><span class="line">extern int coroutine_begin (coroutine_ucontext_t *__ucp);</span><br><span class="line"></span><br><span class="line">extern void coroutine_makecontext (coroutine_ucontext_t *__ucp, IMP func, void *arg, void *stackTop);</span><br></pre></td></tr></table></figure><p>其中<strong>coroutine_makecontext</strong>在<strong>coroutine_context.m</strong>中实现<br>回到例子中<br><strong>co_launch</strong> 来自 <strong>coobjc.h</strong> ,来关注一下<strong>coobjc.h</strong> 里的内联函数</p><ul><li>co_launch 创建一个协程，然后在当前线程中异步恢复它</li><li>co_launch_now 创建一个协程，然后在当前线程立即恢复它</li><li>co_launch_withStackSize 创建一个协程，然后在当前线程中异步恢复它，与co_launch不同 ，他可以设定堆栈大小 默认为65536 最大限制为1M</li><li>co_launch_onqueue 创建一个协程，并在给定的线程中异步恢复它</li><li>co_sequence 创建一个生成器</li><li>co_sequence_onqueue 在指定的线程中创建一个生成器</li><li>co_actor 创建一个容器</li><li>co_actor_onqueue 在指定线程中创建一个容器</li><li>await 用await得到异步执行的结果，等待异步方法的执行</li><li>batch_await 批量的await 目前没找到哪里用</li><li>co_delay 使当前协程sleep 多少秒</li><li>co_isActive 判断一个协程是否有效</li><li>co_isCancelled 检查当前协程是否取消</li></ul><p>其他的一些宏定义</p><ul><li>CO_ASYNC 给方法一个标记，表示方法是可被暂停的，类似于JS中 async</li><li>SURE_ASYNC 断言</li><li>yield 暂停</li></ul><p>在看看用到的<strong>co_launch</strong> 文档描述在当前线程中创建协程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)requestMovies</span><br><span class="line">&#123;</span><br><span class="line">    //创建协程</span><br><span class="line">    co_launch(^&#123;</span><br><span class="line">        //进行网络加载，但并没有在这里进行await</span><br><span class="line">        NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;];</span><br><span class="line">        [self.refreshControl endRefreshing];</span><br><span class="line">        </span><br><span class="line">        if (dataArray != nil)</span><br><span class="line">        &#123;</span><br><span class="line">            [self processData:dataArray];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><pre><code>else</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        &#123;</span><br><span class="line">            [self.networkLoadingViewController showErrorView];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着往下看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在这里写了CO_ASYNC 表示该方法是可以被暂停的 同时在方法内await等待异步的结果</span><br><span class="line">- (id)requestJSONWithURL:(NSString*)url CO_ASYNC&#123;</span><br><span class="line">    SURE_ASYNC</span><br><span class="line">    return await([self.jsonActor sendMessage:url]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看看 <strong>self.jsonActor</strong> 及  <strong>sendMessage</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">jsonActor 是一个COActor 的对象，文档中描述</span><br><span class="line">_ Actor 的概念来自于 Erlang ，在 AKKA 中，可以认为一个 Actor 就是一个容器，用以存储状态、行为、Mailbox 以及子 Actor 与 Supervisor 策略。Actor 之间并不直接通信，而是通过 Mail 来互通有无。_</span><br><span class="line">*/</span><br><span class="line">@property (nonatomic, strong) COActor *jsonActor;</span><br></pre></td></tr></table></figure><p>此时看到 DataService.m中有init 注册了接受消息的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_jsonActor = co_actor_onqueue(_jsonQueue, ^(COActorChan *channel) &#123;</span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    id json = nil;</span><br><span class="line">    COActorCompletable *completable = nil;</span><br><span class="line">    for (COActorMessage *message in channel) &#123;</span><br><span class="line">        NSString *url = [message stringType];</span><br><span class="line">        json = nil;</span><br><span class="line">        if (url.length &gt; 0) &#123;</span><br><span class="line">            //这里接受到消息之后将消息发送到 networkActor</span><br><span class="line">            completable = [self.networkActor sendMessage:url];</span><br><span class="line">            data = await(completable);</span><br><span class="line">            if (data) &#123;</span><br><span class="line">                json = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];</span><br><span class="line">            &#125;</span><br><span class="line">            message.complete(json);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            message.complete(nil);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>收到消息后将json的消息回复到上层。展示数据</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p>[阿里云栖社区对coobjc介绍]<a href="https://www.jianshu.com/p/cd7f6ef5a8fd" target="_blank" rel="noopener">https://www.jianshu.com/p/cd7f6ef5a8fd</a><br>[我所理解的ucontext族函数]<a href="https://www.jianshu.com/p/dfd7ac1402f0" target="_blank" rel="noopener">https://www.jianshu.com/p/dfd7ac1402f0</a><br>[构建C协程之ucontext篇]<a href="https://blog.csdn.net/gettogetto/article/details/53306897" target="_blank" rel="noopener">https://blog.csdn.net/gettogetto/article/details/53306897</a><br>[理解 JavaScript 的 async/await]<a href="https://segmentfault.com/a/1190000007535316?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007535316?utm_source=tag-newest</a><br>[GC 7.1 Mac OS X 10.6.6: ucontext routines are deprecated]<a href="https://www.hpl.hp.com/hosted/linux/mail-archives/gc/2011-February/004354.html" target="_blank" rel="noopener">https://www.hpl.hp.com/hosted/linux/mail-archives/gc/2011-February/004354.html</a><br>[PSA: avoiding the “ucontext routines are deprecated” error on Mac OS X Snow Leopard]<a href="http://duriansoftware.com/joe/PSA%3a-avoiding-the-%22ucontext-routines-are-deprecated%22-error-on-Mac-OS-X-Snow-Leopard.html" target="_blank" rel="noopener">http://duriansoftware.com/joe/PSA%3a-avoiding-the-%22ucontext-routines-are-deprecated%22-error-on-Mac-OS-X-Snow-Leopard.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;em&gt;协程是计算机程序的一类组件，推广了非抢先多任务的子程序，允许执行被挂起与被恢复。&lt;/em&gt;&lt;br&gt;&lt;em&gt;相对子例程而言，协程更为一
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/jianxiongc/tags/iOS/"/>
    
  </entry>
  
</feed>
