<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://github.com/jianxiongc/"/>
  <updated>2019-07-16T02:26:48.297Z</updated>
  <id>https://github.com/jianxiongc/</id>
  
  <author>
    <name>Jianxiong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>协程 阿里开源库 coobjc 初步分析</title>
    <link href="https://github.com/jianxiongc/2019/07/16/%E5%8D%8F%E7%A8%8B-%E9%98%BF%E9%87%8C%E5%BC%80%E6%BA%90%E5%BA%93-coobjc-%E5%88%9D%E6%AD%A5%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/</id>
    <published>2019-07-16T02:09:24.000Z</published>
    <updated>2019-07-16T02:26:48.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><em>协程是计算机程序的一类组件，推广了非抢先多任务的子程序，允许执行被挂起与被恢复。</em><br><em>相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。</em><br><em>协程源自 Simula 和 Modula-2 语言，但也有其他语言支持。</em><br><em>协程更适合于用来实现彼此熟悉的程序组件，如合作式多任务、异常处理、事件循环、迭代器、无限列表和管道。</em><br><em>根据高德纳的说法, 马尔文·康威于1958年发明了术语 coroutine 并用于构建汇编程序。</em><br><em>—— Wikipedia</em></p><h2 id="coobjc-解决的问题"><a href="#coobjc-解决的问题" class="headerlink" title="coobjc 解决的问题"></a>coobjc 解决的问题</h2><h3 id="iOS-异步编程问题"><a href="#iOS-异步编程问题" class="headerlink" title="iOS 异步编程问题"></a>iOS 异步编程问题</h3><p>官网描述:</p><p>基于 Block 的异步编程回调是目前 iOS 使用最广泛的异步编程方式，iOS 系统提供的 GCD 库让异步开发变得很简单方便，但是基于这种编程方式的缺点也有很多，主要有以下几点：</p><p>容易进入”嵌套地狱”<br>错误处理复杂和冗长<br>容易忘记调用 completion handler<br>条件执行变得很困难<br>从互相独立的调用中组合返回结果变得极其困难<br>在错误的线程中继续执行<br>难以定位原因的多线程崩溃<br>锁和信号量滥用带来的卡顿、卡死<br>上述问题反应到线上应用本身就会出现大量的多线程崩溃</p><h3 id="协程的优势"><a href="#协程的优势" class="headerlink" title="协程的优势"></a>协程的优势</h3><p>官网描述:</p><p><strong>简明</strong><br>概念少：只有很少的几个操作符，相比响应式几十个操作符，简直不能再简单了<br>原理简单: 协程的实现原理很简单，整个协程库只有几千行代码<br><strong>易用</strong><br>使用简单：它的使用方式比 GCD 还要简单，接口很少<br>改造方便：现有代码只需要进行很少的改动就可以协程化，同时我们针对系统库提供了大量协程化接口<br><strong>清晰</strong><br>同步写异步逻辑：同步顺序方式写代码是人类最容易接受的方式，这可以极大的减少出错的概率<br>可读性高: 使用协程方式编写的代码比 block 嵌套写出来的代码可读性要高很多<br><strong>性能</strong><br>调度性能更快：协程本身不需要进行内核级线程的切换，调度性能快，即使创建上万个协程也毫无压力<br>减少卡顿卡死: 协程的使用以帮助开发减少锁、信号量的滥用，通过封装会引起阻塞的 IO 等协程接口，可以从根源上减少卡顿、卡死，提升应用整体的性能</p><h3 id="核心能力"><a href="#核心能力" class="headerlink" title="核心能力"></a>核心能力</h3><p>提供了类似C#和Javascript语言中的Async/Await编程方式支持，在协程中通过调用await方法即可同步得到异步方法的执行结果，非常适合IO、网络等异步耗时调用的同步顺序执行改造。<br>提供了类似Kotlin中的Generator功能，用于懒计算生成序列化数据，非常适合多线程可中断的序列化数据生成和访问。<br>提供了Actor Model的实现，基于Actor Model，开发者可以开发出更加线程安全的模块，避免由于直接函数调用引发的各种多线程崩溃问题。<br>提供了元组的支持，通过元组Objective-C开发者可以享受到类似Python语言中多值返回的好处。</p><h3 id="内置系统扩展库"><a href="#内置系统扩展库" class="headerlink" title="内置系统扩展库"></a>内置系统扩展库</h3><ul><li><p>提供了对NSArray、NSDictionary等容器库的协程化扩展，用于解决序列化和反序列化过程中的异步调用问题。</p></li><li><p>提供了对NSData、NSString、UIImage等数据对象的协程化扩展，用于解决读写IO过程中的异步调用问题。</p></li><li><p>提供了对NSURLConnection和NSURLSession的协程化扩展，用于解决网络异步请求过程中的异步调用问题。</p></li><li><p>提供了对NSKeyedArchieve、NSJSONSerialization等解析库的扩展，用于解决解析过程中的异步调用问题。</p></li></ul><h3 id="coobjc-设计"><a href="#coobjc-设计" class="headerlink" title="coobjc 设计"></a>coobjc 设计</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://uploader.shimo.im/f/UODPL5lwYjolZXzm.png!thumbnail" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure><p>最底层是协程内核，包含了栈切换的管理、协程调度器的实现、协程间通信channel的实现等。<br>中间层是基于协程的操作符的包装，目前支持async/await、Generator、Actor等编程模型。<br>最上层是对系统库的协程化扩展，目前基本上覆盖了Foundation和UIKit的所有IO和耗时方法。</p><h3 id="核心实现原理"><a href="#核心实现原理" class="headerlink" title="核心实现原理"></a>核心实现原理</h3><p>协程的核心思想是控制调用栈的主动让出和恢复。一般的协程实现都会提供两个重要的操作：</p><p>Yield：是让出cpu的意思，它会中断当前的执行，回到上一次Resume的地方。<br>Resume：继续协程的运行。执行Resume后，回到上一次协程Yield的地方。</p><p>我们基于线程的代码执行时候，是没法做出暂停操作的，我们现在要做的事情就是要代码执行能够暂停，还能够再恢复。 基本上代码执行都是一种基于调用栈的模型，所以如果我们能把当前调用栈上的状态都保存下来，然后再能从缓存中恢复，那我们就能够实现yield和 resume。<br>实现这样操作有几种方法呢？</p><p>第一种：利用glibc 的 ucontext组件(云风的库)。<br>第二种：使用汇编代码来切换上下文(实现c协程)，原理同ucontext。<br>第三种：利用C语言语法switch-case的奇淫技巧来实现（Protothreads)。<br>第四种：利用了 C 语言的 setjmp 和 longjmp。<br>第五种：利用编译器支持语法糖。</p><p>上述第三种和第四种只是能过做到跳转，但是没法保存调用栈上的状态，看起来基本上不能算是实现了协程，只能算做做demo，第五种除非官方支持，否则自行改写编译器通用性很差。而第一种方案的 ucontext 在iOS上是废弃了的，不能使用。那么我们使用的是第二种方案，自己用汇编模拟一下 ucontext。<br>模拟ucontext的核心是通过getContext和setContext实现保存和恢复调用栈。需要熟悉不同CPU架构下的调用约定(Calling Convention). 汇编实现就是要针对不同cpu实现一套，我们目前实现了 armv7、arm64、i386、x86_64，支持iPhone真机和模拟器。</p><h2 id="官方例子"><a href="#官方例子" class="headerlink" title="官方例子"></a>官方例子</h2><p>整体结构如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://uploader.shimo.im/f/6l8O3mRWxlYa9A0q.jpg!thumbnail" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure><ul><li><strong>cokit</strong>       cokit库为Foundation和UIKit系统库提供了一个协程封装，它依赖于coobjc库，为IO，网络等耗时的方法提供协同处理的封装。</li><li><strong>coobjc</strong>    coobjc的Objective-C版实现的源代码</li><li>*<em>coswift  *</em> coswift的Swift版源代码</li><li><strong>Examples</strong>    coobjcBaseExample是OC版本的Demo    coSwiftExample是OC版本的Demo    <h3 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h3>直接看看coobjcBaseExample的效果<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://uploader.shimo.im/f/QUeRFwAMshcsOqem.png!thumbnail" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure></li></ul><p>这个界面可以看到一个简单的列表页。<br>对应到代码中的<strong>KMDiscoverListViewController</strong><br>ViewDidLoad中有如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line"></span><br><span class="line">    [self setupTableView];</span><br><span class="line">    [self requestMovies];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从方法名可以得知，<strong>requestMovies</strong>实现了网络拉取电影列表的功能。<br>看 <strong>requestMovies</strong> 中的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)requestMovies</span><br><span class="line">&#123;</span><br><span class="line">    co_launch(^&#123;</span><br><span class="line">        NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;];</span><br><span class="line">        [self.refreshControl endRefreshing];</span><br><span class="line">        </span><br><span class="line">        if (dataArray != nil)</span><br><span class="line">        &#123;</span><br><span class="line">            [self processData:dataArray];</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            [self.networkLoadingViewController showErrorView];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先抛开co_launch不管，可以发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;];</span><br></pre></td></tr></table></figure><p>实现了网络请求，获取数据，<strong>getDiscoverList</strong>实现代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray*)getDiscoverList:(NSString *)pageLimit;</span><br><span class="line">&#123;</span><br><span class="line">    NSString *url = [NSString stringWithFormat:@&quot;%@&amp;page=%@&quot;, [self prepareUrl], pageLimit];</span><br><span class="line">    id json = [[DataService sharedInstance] requestJSONWithURL:url];</span><br><span class="line">    NSDictionary* infosDictionary = [self dictionaryFromResponseObject:json jsonPatternFile:@&quot;KMDiscoverSourceJsonPattern.json&quot;];</span><br><span class="line">    return [self processResponseObject:infosDictionary];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据代码可以发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id json = [[DataService sharedInstance] requestJSONWithURL:url];</span><br></pre></td></tr></table></figure><p>这一段实现了网络请求，然后继续去进入<strong>requestJSONWithURL</strong>去看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (id)requestJSONWithURL:(NSString*)url CO_ASYNC&#123;</span><br><span class="line">    SURE_ASYNC</span><br><span class="line">    return await([self.jsonActor sendMessage:url]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候发现 <strong>SURE_ASYNC</strong> 和 <strong>awiat</strong> 类似于<strong>ES7</strong>中的<strong>async</strong> 和 <strong>await</strong>，<strong>ES7</strong>中<strong>async-await</strong>是<strong>promise</strong>和<strong>generator</strong>的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性，看起来这块起到了类似的作用。<br>再来仔细了解下协程。</p><h3 id="协程入门"><a href="#协程入门" class="headerlink" title="协程入门"></a>协程入门</h3><p>上面的<strong>核心实现原理</strong>中有提到，实现核心的<strong>yield</strong>和<strong>resume</strong>有五种方法，<br>其中说到第三、四种只能做到过跳转，没办法保存调用栈,无法真正的实现协程。第五种除非官方支持。第一种ucontext在iOS是废弃了的。那么第二种方案，自己用汇编模拟ucontext。</p><p>首先，ucontext 是啥？</p><p><strong>ucontext</strong> 机制是<strong>GUN C</strong>库提供的一组用于创建、保存、切换用户态执行context的API。主要包括以下四个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);</span><br><span class="line">int swapcontext(ucontext_t *oucp, ucontext_t *ucp);</span><br><span class="line">int getcontext(ucontext_t *ucp);</span><br><span class="line">int setcontext(const ucontext_t *ucp);</span><br></pre></td></tr></table></figure><p>详细参见<br>[我所理解的ucontext族函数]<a href="https://www.jianshu.com/p/dfd7ac1402f0" target="_blank" rel="noopener">https://www.jianshu.com/p/dfd7ac1402f0</a><br>[构建C协程之ucontext篇]<a href="https://blog.csdn.net/gettogetto/article/details/53306897" target="_blank" rel="noopener">https://blog.csdn.net/gettogetto/article/details/53306897</a></p><p>来看一段简单的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">//由于在Mac OS X 10.6.6 ucontext被弃用的关系 ，需要使用sys/ucontext.h</span><br><span class="line">#include &lt;sys/ucontext.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">// ----&gt; ucontext </span><br><span class="line">ucontext_t context;</span><br><span class="line">getcontext(&amp;context);</span><br><span class="line">puts(&quot;Hello world&quot;);</span><br><span class="line">sleep(1);</span><br><span class="line">setcontext(&amp;context);</span><br><span class="line"></span><br><span class="line">// ----&gt; goto </span><br><span class="line">// loop: puts(&quot;%s\n&quot;,&quot;Hello world&quot;);</span><br><span class="line">//     sleep(1);</span><br><span class="line">//     goto loop;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存上述代码到 example.c，执行编译命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc example.c -o example</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://uploader.shimo.im/f/sTnAWOBWZ3IpupoP.jpg!thumbnail" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure><p>可以看到这里会不断执行，通过setcontext和getcontext实现切换。<br>更详细参见<br><a href="https://www.jianshu.com/p/dfd7ac1402f0" target="_blank" rel="noopener">我所理解的ucontext族函数</a><br><a href="https://blog.csdn.net/gettogetto/article/details/53306897" target="_blank" rel="noopener">构建C协程之ucontext篇</a><br>上面<strong>核心实现原理</strong>中讲到了第二种：使用汇编代码来切换上下文(实现c协程)，原理同ucontext。<br>我们在coobjc中的库中发现了唯一一个汇编文件<strong>coroutine_context.s</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://uploader.shimo.im/f/O0mWE5ILsUwn44oQ.jpg!thumbnail" alt="图片" title>                </div>                <div class="image-caption">图片</div>            </figure><p>在汇编文件中发现主要提供了三个方法</p><ul><li>_coroutine_getcontext</li><li>_coroutine_begin</li><li>_coroutine_setcontext</li></ul><p>同样在 <strong>coroutine_context.h</strong>中暴露了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern int coroutine_getcontext (coroutine_ucontext_t *__ucp);</span><br><span class="line"></span><br><span class="line">extern int coroutine_setcontext (coroutine_ucontext_t *__ucp);</span><br><span class="line">extern int coroutine_begin (coroutine_ucontext_t *__ucp);</span><br><span class="line"></span><br><span class="line">extern void coroutine_makecontext (coroutine_ucontext_t *__ucp, IMP func, void *arg, void *stackTop);</span><br></pre></td></tr></table></figure><p>其中<strong>coroutine_makecontext</strong>在<strong>coroutine_context.m</strong>中实现<br>回到例子中<br><strong>co_launch</strong> 来自 <strong>coobjc.h</strong> ,来关注一下<strong>coobjc.h</strong> 里的内联函数</p><ul><li>co_launch 创建一个协程，然后在当前线程中异步恢复它</li><li>co_launch_now 创建一个协程，然后在当前线程立即恢复它</li><li>co_launch_withStackSize 创建一个协程，然后在当前线程中异步恢复它，与co_launch不同 ，他可以设定堆栈大小 默认为65536 最大限制为1M</li><li>co_launch_onqueue 创建一个协程，并在给定的线程中异步恢复它</li><li>co_sequence 创建一个生成器</li><li>co_sequence_onqueue 在指定的线程中创建一个生成器</li><li>co_actor 创建一个容器</li><li>co_actor_onqueue 在指定线程中创建一个容器</li><li>await 用await得到异步执行的结果，等待异步方法的执行</li><li>batch_await 批量的await 目前没找到哪里用</li><li>co_delay 使当前协程sleep 多少秒</li><li>co_isActive 判断一个协程是否有效</li><li>co_isCancelled 检查当前协程是否取消</li></ul><p>其他的一些宏定义</p><ul><li>CO_ASYNC 给方法一个标记，表示方法是可被暂停的，类似于JS中 async</li><li>SURE_ASYNC 断言</li><li>yield 暂停</li></ul><p>在看看用到的<strong>co_launch</strong> 文档描述在当前线程中创建协程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)requestMovies</span><br><span class="line">&#123;</span><br><span class="line">    //创建协程</span><br><span class="line">    co_launch(^&#123;</span><br><span class="line">        //进行网络加载，但并没有在这里进行await</span><br><span class="line">        NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;];</span><br><span class="line">        [self.refreshControl endRefreshing];</span><br><span class="line">        </span><br><span class="line">        if (dataArray != nil)</span><br><span class="line">        &#123;</span><br><span class="line">            [self processData:dataArray];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><pre><code>else</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        &#123;</span><br><span class="line">            [self.networkLoadingViewController showErrorView];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着往下看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//在这里写了CO_ASYNC 表示该方法是可以被暂停的 同时在方法内await等待异步的结果</span><br><span class="line">- (id)requestJSONWithURL:(NSString*)url CO_ASYNC&#123;</span><br><span class="line">    SURE_ASYNC</span><br><span class="line">    return await([self.jsonActor sendMessage:url]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看看 <strong>self.jsonActor</strong> 及  <strong>sendMessage</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">jsonActor 是一个COActor 的对象，文档中描述</span><br><span class="line">_ Actor 的概念来自于 Erlang ，在 AKKA 中，可以认为一个 Actor 就是一个容器，用以存储状态、行为、Mailbox 以及子 Actor 与 Supervisor 策略。Actor 之间并不直接通信，而是通过 Mail 来互通有无。_</span><br><span class="line">*/</span><br><span class="line">@property (nonatomic, strong) COActor *jsonActor;</span><br></pre></td></tr></table></figure><p>此时看到 DataService.m中有init 注册了接受消息的实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_jsonActor = co_actor_onqueue(_jsonQueue, ^(COActorChan *channel) &#123;</span><br><span class="line">    NSData *data = nil;</span><br><span class="line">    id json = nil;</span><br><span class="line">    COActorCompletable *completable = nil;</span><br><span class="line">    for (COActorMessage *message in channel) &#123;</span><br><span class="line">        NSString *url = [message stringType];</span><br><span class="line">        json = nil;</span><br><span class="line">        if (url.length &gt; 0) &#123;</span><br><span class="line">            //这里接受到消息之后将消息发送到 networkActor</span><br><span class="line">            completable = [self.networkActor sendMessage:url];</span><br><span class="line">            data = await(completable);</span><br><span class="line">            if (data) &#123;</span><br><span class="line">                json = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil];</span><br><span class="line">            &#125;</span><br><span class="line">            message.complete(json);</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            message.complete(nil);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>收到消息后将json的消息回复到上层。展示数据</p><h2 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h2><p>[阿里云栖社区对coobjc介绍]<a href="https://www.jianshu.com/p/cd7f6ef5a8fd" target="_blank" rel="noopener">https://www.jianshu.com/p/cd7f6ef5a8fd</a><br>[我所理解的ucontext族函数]<a href="https://www.jianshu.com/p/dfd7ac1402f0" target="_blank" rel="noopener">https://www.jianshu.com/p/dfd7ac1402f0</a><br>[构建C协程之ucontext篇]<a href="https://blog.csdn.net/gettogetto/article/details/53306897" target="_blank" rel="noopener">https://blog.csdn.net/gettogetto/article/details/53306897</a><br>[理解 JavaScript 的 async/await]<a href="https://segmentfault.com/a/1190000007535316?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007535316?utm_source=tag-newest</a><br>[GC 7.1 Mac OS X 10.6.6: ucontext routines are deprecated]<a href="https://www.hpl.hp.com/hosted/linux/mail-archives/gc/2011-February/004354.html" target="_blank" rel="noopener">https://www.hpl.hp.com/hosted/linux/mail-archives/gc/2011-February/004354.html</a><br>[PSA: avoiding the “ucontext routines are deprecated” error on Mac OS X Snow Leopard]<a href="http://duriansoftware.com/joe/PSA%3a-avoiding-the-%22ucontext-routines-are-deprecated%22-error-on-Mac-OS-X-Snow-Leopard.html" target="_blank" rel="noopener">http://duriansoftware.com/joe/PSA%3a-avoiding-the-%22ucontext-routines-are-deprecated%22-error-on-Mac-OS-X-Snow-Leopard.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;em&gt;协程是计算机程序的一类组件，推广了非抢先多任务的子程序，允许执行被挂起与被恢复。&lt;/em&gt;&lt;br&gt;&lt;em&gt;相对子例程而言，协程更为一
      
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/jianxiongc/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://github.com/jianxiongc/2019/07/13/hello-world/"/>
    <id>https://github.com/jianxiongc/2019/07/13/hello-world/</id>
    <published>2019-07-13T10:00:34.370Z</published>
    <updated>2019-07-13T10:00:34.370Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
