{"meta":{"title":"Jianxiong","subtitle":null,"description":null,"author":"Jianxiong","url":"https://github.com/jianxiongc","root":"/blog/"},"pages":[{"title":"tags","date":"2019-07-14T03:52:39.000Z","updated":"2019-07-15T03:59:56.745Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/jianxiongc/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-07-14T03:54:33.000Z","updated":"2019-07-15T04:00:36.142Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/jianxiongc/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"蓝牙后台分析","slug":"蓝牙后台分析","date":"2019-07-23T23:12:12.000Z","updated":"2019-07-24T02:33:17.687Z","comments":true,"path":"2019/07/24/蓝牙后台分析/","link":"","permalink":"https://github.com/jianxiongc/2019/07/24/蓝牙后台分析/","excerpt":"","text":"蓝牙 iOS 后台分析 操作现象: 每次后台连接上蓝牙之后可以进行操作 摇一摇。 连接上会接收到通知提醒 断开会接收到通知提醒 断连重连都是OK的 只有在蓝牙连接时才计算后台时间 其他产品申请的权限 通知 位置 无线数据 麦克风 其他产品的后台数据: 7:41 开启 App 手机 100% 电量 8:54 查看 App 手机 75% 电量 App占比9% 3分钟前台 24分钟后台 第二天9:00 查看 App 手机 45电量 App占比11% 3分钟前台 29分钟后台 根据操作分析: 开启相机 音乐 等打断无声音乐的操作 并没有受到干扰 不是无声音乐保活 关闭通知和麦克风的权限 后台尝试连接蓝牙操作 可以正常操作 所以不可能是通知或者麦克风保活 不是通知或者麦克风保活 关闭地理位置权限 后台尝试连接蓝牙操作 可以正常操作 所以不可能是地理位置后台保活 不是地理位置保活 其他产品的现象为: 连接蓝牙 -&gt; 开启保活断开蓝牙 -&gt; 关闭保活 这种保活方式 能最大程度的节省电量 即不连接不计后台时间。 这种保活方式 是主要是依靠 iOS 系统的蓝牙连接来调用App的代码来实现。 依靠系统蓝牙调起App的方式实现降低功耗的行为。优势:功耗极大的降低了。缺陷:当系统内存不足时 会被回收且无法接收到系统通知。导致PKE无法正常使用。 和其他产品对比存在的不同 蓝牙配对能否保证App在后台的存活。及当内存不足时能否保活 参考 iOS支持的后台方式:Audio, AirPlay and Picture in Picture此个选项包含四种场景，分别是：音频的播放，录音，AirPlay 及画中画的视频播放。音频的播放：在播放音频时，即使应用退到后台，只要一直有音频在播放，那应用就可以一直在后台运行。 代码实现可参考：http://www.linuxidc.com/Linux/2012-08/68364.htm 录音：应用可以请求使用麦克风，而当开启了此后台选项，应用在使用麦克风的时候，即使退到后台，也可以一直后台运行，通过查看微信安装包中的 plist 文件，微信的语音聊天，就是通过这种方式实现的。而当该类应用退到后台后，iOS 系统的状态栏会变成红色，并在状态栏中显示正在使用麦克风的应用的名称。 AirPlay：AirPlay 是指将 iOS 设备，或者 Mac 设备上的音视频，同步到另一个设备中播放。举两个例子，第一个是把 iPhone 上的音乐通过蓝牙的方式在汽车的蓝牙音响播放，第二个是把 iPhone 上的视频，同步到智能电视屏幕上播放。此功能一般用于多端及多屏的交互。关于 AirPlay 的开发文档：http://nto.github.io/AirPlay.html 画中画的视频播放：画中画是 iPad 版本的 iOS 9 新增加的功能，可以在 iOS 的桌面，或者其他应用的界面的上面播放视频，从而该视频区域所属的应用就可以后台运行了。此功能现在只在 iPad 应用中提供。代码实现可参考：http://www.cocoachina.com/ios/20150714/12558.html Location updates一般用于导航应用中，开启此选项后，应用退到后台，还可以得到系统的定位更新，从而使得应用可以根据定位的变化做出不同的反应。代码实现可参考：https://github.com/voyage11/Location Voice over IPVOIP 类的应用允许用户使用网络而不是手机打电话，因此这一类的应用需要保持同它相关的服务的网络连接，用以收到来电事件和其他数据。iOS 不是通过一直让该应用处于激活状态来达到这个目的，而是同样也会将这类的应用挂起，但同时会在应用被挂起期间由系统接管它的 VOIP 的 Socket，当这个 Socket 有数据通信时，系统会再次唤醒处于挂起状态的应用，同时将 Socket 的控制权交还给该应用，以让其正常的处理来电事件和其他数据。 Newsstand downloads在 iOS 开发中，有一类叫报刊杂志类应用比较特别，在 iOS 9 之前的系统中，此类应用会统一收在系统内置的「报刊杂志」应用中，在 iOS 9 中则去掉了内置的「报刊杂志」应用，此类应用得以以单独的图标入口出现在桌面中。此后台运行的选项就是提供给报刊杂志类应用可以在后台下载及处理报刊杂志内容，而下载的过程需要使用 NewsstandKit 中的 NKAssetDownload 进行下载。需要注意的是，下载的过程中，应用可能还是会被挂起，甚至应用被退出，而 iOS 会在 Wi-Fi 环境下继续下载，直到下载完成。而一旦下载完成，如果应用只是被挂起，则 iOS 会唤醒对应的应用，回调对应的事件；如果应用已经退出，则会启动应用，在启动参数中会带上对应的标识表示这次启动是因为下载报刊杂志内容完成。代码实现可参考：http://www.viggiosoft.com/blog/blog/2011/10/17/ios-newsstand-tutorial/ External Accessory communication此选项提供给一些 MFi 外设通过蓝牙，或者 Lightning 接头等方式与 iOS 设备连接，从而可在外设发送消息时，唤醒已经被挂起的应用。而一旦被唤醒，一般情况下， 应用只有最多 10 秒钟的执行时间。MFi 外设：是指通过苹果 MFi 认证的设备，而 MFi 认证是对其授权配件厂商生产的外置配件的一种标识使用许可，是 Made for iOS 的英文缩写。 Uses Bluetooth LE accessories此选项与 External Accessory communication 类似，只是此选项无需限制 MFi 外设，而需要的是 Bluetooth LE 设备。 Acts as a Bluetooth LE accessory此选项是指 iOS 设备作为一个蓝牙外设连接时，对应的应用可以后台运行，但是使用此模式需要用户进行授权认证。 Background fetchiOS 7 新增加的一个选项，用于即使在后台，也需要频繁更新数据的应用。例如一个 PM2.5 的应用，需要几个小时更新一次数据，那么可以开启此选项，设置一个时间间隔，从而让 iOS 在间隔时间内在后台启动该应用，执行指定数据的获取工作，而此过程最多只能执行 30 秒钟。代码实现可参考：http://objccn.io/issue-5-5/ Remote notificationsiOS 7 新增加的一个选项，是一种静默推送，它有别于一般的推送，应用收到此类推送后，不会有任何的界面提示，而当应用退出或者挂起时收到此类推送，iOS 也会启动或者唤醒对应的应用。例如一个阅读应用，用户订阅的博客更新了，那么可以先发一个静默推送，应用收到此种推送后，可以先把用户订阅的博客内容都下载好，再通知用户，这样用户一打开应用就可以马上开始阅读。收到静默推送，会回调对应的回调方法，而此回调方法最多只能执行 30 秒钟。代码实现可参考：http://objccn.io/issue-5-5/ 基于 NSURLSession 的后台传输此为 iOS 7 新增加的特性，用于在后台下载或者上传大文件，步骤如下：创建后台传输用的 NSURLSession 对象；向这个对象中加入对应的传输的 NSURLSessionTask，并开始传输；在实现 AppDelegate 里实现 -application:handleEventsForBackgroundURLSession:completionHandler: 方法，以刷新 UI 及通知系统传输结束。一旦后台传输的状态发生变化（包括正常结束和失败）的时候，应用将被唤醒并运行 AppDelegate 中的回调。但是也有一些限制，后台传输只会通过 Wi-Fi 来进行。后台下载的时间与以前的关闭应用后X分钟的模式不一样，而是为了节省电力变为离散式的下载。代码实现可以参考：http://onevcat.com/2013/08/ios7-background-multitask/ 其他后台运行操作一直循环播放一段没声音的音频可以在后台选项中选择「Audio, AirPlay and Picture in Picture」，而开始循环播放一段是没声音的音频，即在 Audio Unit 回调函数中使用 kAudioUnitRenderAction_OutputIsSilence 标志位，但是这种方式两个大的缺点： 苹果的审核人员如果发现，会被拒； 应用程序的 Audio Session 不能被打断。当应用执行在后台时，只要另一个应用使用 kAudioSessionCategory_RecordAndPlay （比如 Skype）或者 kAudioSessionCategory_SoloAmbientSound，那么该应用就会被立即打断。代码实现可参考：https://github.com/marcop/MMPDeepSleepPreventer 越狱下开发 System 级别的应用一般的应用都是 Mobile 级别的，在越狱的情况下，可以开发一个 System 级别的应用，从而使得应用不受 iOS 一般应用的限制，实现真正的后台运行，但是缺点就是应用只能运行在越狱设备上，也不能上 App Store。代码实现可参考：http://www.cnblogs.com/doudouyoutang/p/4712331.html iOS BackgroundMode Documents参考链接:https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/BackgroundExecution/BackgroundExecution.html iOS 能耗参考:238_writing_energy_efficient_apps","categories":[],"tags":[{"name":"蓝牙 后台","slug":"蓝牙-后台","permalink":"https://github.com/jianxiongc/tags/蓝牙-后台/"}]},{"title":"uni-app踩坑记录","slug":"uni-app踩坑记录","date":"2019-07-22T13:34:22.000Z","updated":"2019-07-22T13:35:36.127Z","comments":true,"path":"2019/07/22/uni-app踩坑记录/","link":"","permalink":"https://github.com/jianxiongc/2019/07/22/uni-app踩坑记录/","excerpt":"","text":"注意像素尺寸 ,uni-app官方推荐用upx,小程序是rpx,weex是px，不要弄混了。https://uniapp.dcloud.io/frame?id=%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D 注意HBudiler 保存代码机制，默认代码不会保存，记得随手写完command/ctrl + s,编译时检查代码是否都保存了 image 标签一定要设置高度和宽度，100% 或者 绝对定位都是无效的。地图也一样。 image标签里边不要套text等标签了，不生效； uni-app同小程序一样 display 默认不是flex,所以在使用到flex的特性是 需要加上display:flex。 有些情况下需要获取全屏高度，但是不能使用flex:1 或者 abosulte的方式。这个时候可以采用 获取 系统屏幕宽度 / 750 * 系统屏幕高度。代码如下 12345const systemInfo = uni.getSystemInfoSync();if (systemInfo.windowWidth &amp;&amp; systemInfo.windowHeight) &#123; let multiple = 750/systemInfo.windowWidth; that.screenHeight = systemInfo.windowHeight * multiple;&#125; uniapp 给Data赋值时和微信小程序的区别。 1234567891011data() &#123; return &#123; value: 0 &#125;&#125;//小程序采用this.setData(&#123; value: 1&#125;)//uni-appthis.value = 1; uni-app map的 controls 中 position 使用的是px，而外部css使用的upx,这里要注意不要写成upx的值了。 并且position 只支持了 top 和 left定位。 如果要bottom 的话 需要先计算屏幕高度，然后再更改一次正确的位置。默认可以给 iPhone 7标准尺寸的 绝对定位。 cover-view 或者 cover-image 支持position 但同样 只支持top 和 left 。需要写 bottom 同 7。 iconfont 的使用方式与小程序不同 ，跟weex方式差不多，需要注意copy下来的地址加协议头。https://uniapp.dcloud.io/frame?id=%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87， text支持 ,cover-view 在模拟器显示 真机不显示 标签中的@regionchange 不触发 官方说明：事件映射表中没有的原生事件也可以使用，例如map组件的regionchange 事件直接在组件上写成 @regionchange,同时这个事件也非常特殊，它的 event type 有 begin 和 end 两个，导致我们无法在handleProxy 中区分到底是什么事件，所以你在监听此类事件的时候同时监听事件名和事件类型既 &lt;map @regionchange=”functionName” @end=”functionName” @begin=”functionName”&gt;。 uni-app 官方文档中 map并没有支持多边形，但仍然可以按照微信小程序的方式实现。 支付宝小程序 如果不是在首页 ，左上角会始终出现返回按钮或者回到主页按钮，不建议在小程序中添加启动页面， 原有启动逻辑可以放在App生命周期中。 支付宝小程序想设置navigationBar自定义，文档中并未说明，但在示例Demo中发现 通过页面json文件，”transparentTitle”: “auto”可以实现navigationBar的自定义 ，但是要注意支付宝左上角会有按钮。 注意：以:style=””这样的方式设置px像素值，其值为实际像素，不会被编译器转换。 非H5端不支持 Vue官方文档：Class 与 Style 绑定 中的 classObject 和 styleObject 语法。 123456789101112131415161718192021222324//不支持示例&lt;template&gt; &lt;view :class=&quot;[activeClass]&quot; :style=&quot;[baseStyles,overridingStyles]&quot;&gt;&lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; activeClass: &#123; &apos;active&apos;: true, &apos;text-danger&apos;: false &#125;, baseStyles: &#123; color: &apos;green&apos;, fontSize: &apos;30px&apos; &#125;, overridingStyles: &#123; &apos;font-weight&apos;: &apos;bold&apos; &#125; &#125; &#125; &#125;&lt;/script&gt; ### iconfont 不显示 看看css文件中是否导入 font-face text 的class中是否有font-family iconfont文件中是否这个图标 css是否存在同名的 iconfont class. css 标签选择器设置的属性可能权重过大，导致后面的类选择器无法覆盖它所设置的属性 uni-app button标签 自带了border属性 ，如果要去掉 参考http://ask.dcloud.net.cn/question/62262 v-for 中 @click 带参数，必须设置key ，不然click的参数会为空 map 中绘制线，一定要注意polyline 类型是Array, 虽然它里面是一个Object,但是最外层一定要变成Array，不然会无法显示 data中声明 mpType的变量，会导致所有的Data设置失效。官方文档并没有将其保留为关键字，但是他的存在确实是所有的Data赋值失效了。主要是与App.mpType冲突，注意下这个坑。 mac和windows 下 uni-requset 的Promise支持可能不一致代码如下12345uni.request().then(data =&gt; &#123;&#125;).catch(error =&gt; &#123;&#125;) 这段代码在Windows下编译并能正常执行到iOS ，Andorid的微信小程序端。在Mac 下编译会报 ui-request…then not functoin 。已提交issuse https://github.com/dcloudio/uni-app/issues/351 uni-bluetooth ， 注意外围设备的services 和characteristic 在iOS 都是大写，在android 都是小写。 注意 createConnection 后还需要discoverServices 和 discovcerCharacteristics 。 map marker . label = {} 时Android 会出现小蓝点，iOS不会。设置marker的label 为null可以解决。 微信小程序下，怀疑relaunch页面跳转没有清除， 具体表现为在B页面设置蓝牙状态监听，relaunch 到 C页面，B页面依然能打印蓝牙状态监听的loghttps://developers.weixin.qq.com/community/develop/doc/0000e8551d0f309fadc8b123751000?fromCreate=1 小程序的triggerEvent在uniapp中不支持； uni-app 中在data使用 Object.assgin 一定要加在Data中的最后一行，不然小程序会在iOS 9.3的机器上出现白屏问题。目前不清楚是小程序的问题还是uni-app的问题。","categories":[],"tags":[{"name":"uni-app 微信小程序","slug":"uni-app-微信小程序","permalink":"https://github.com/jianxiongc/tags/uni-app-微信小程序/"}]},{"title":"数据结构基础-数组","slug":"数据结构基础-数组","date":"2019-07-20T23:19:07.000Z","updated":"2019-07-21T08:07:21.693Z","comments":true,"path":"2019/07/21/数据结构基础-数组/","link":"","permalink":"https://github.com/jianxiongc/2019/07/21/数据结构基础-数组/","excerpt":"","text":"数据结构基础 - 数组什么是数组？数组对应的英文是Array ， 是有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。数组是最为简单，最为常用的数据结构。已整数数组为例，数组的存储形式如下 -w526 数组里每一个元素都有自己的下标，这个下标从0开始，一直到数组长度-1. 数组的另一个特点，就是在程序中顺序存储，因此可以很好的实现逻辑上的顺序表。数组在内存中的顺序存储，具体是什么样子呢。 内存是由一个个连续的内存单元组成的，每一个内存单元都有自己的地址。在这些内存单元中，有些被其他数据占用了，有些是空闲的。 数组的每一个元素，都存储在内存单元中，并且元素之间精密排列，即不能打乱元素的存储顺序，也不能跳过过个存储单元进行存储。 在上图中，橙色的格子代表空闲的存储单元，灰色的格子代表已占用的存储单元，而蓝色的连续格子代表数组在内存中的位置。不同类型的数组，每个元素所占的字节个数也不同，本图只是一个简单的示意图。","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/jianxiongc/categories/数据结构/"}],"tags":[{"name":"Array","slug":"Array","permalink":"https://github.com/jianxiongc/tags/Array/"}]},{"title":"Swift - 变量与常量","slug":"Swift - 变量与常量","date":"2019-07-20T15:20:04.000Z","updated":"2019-07-20T23:18:40.529Z","comments":true,"path":"2019/07/20/Swift - 变量与常量/","link":"","permalink":"https://github.com/jianxiongc/2019/07/20/Swift - 变量与常量/","excerpt":"","text":"Swift - 变量与常量变量和常量变量变量是编程语言中最常用的语法元素，它们用于在程序中把一个名字（例如：swiftString）和某种特定类型的值（例如：”Swift is fun.”）关联起来。 在Swift中，我们使用关键字 var 来定义各种不同的类型 1var hello = &quot;你好&quot; 例如，定义一些熟悉的基本类型变量 12345678910111213//: #### Fundamental types//: Integervar hours = 24//: Doublevar PI = 3.14//: Boolvar swiftIsFun = true//: Stringvar hello = &quot;你好&quot; 除了基本类型变量之外，Swift 还有 Tuple ,多类型数据混合到一个数组 123456789101112//: Tuple - Pack many types of values togetherimport UIKitvar me = (&quot;name&quot;,&quot;jianxiong&quot;,[&quot;like&quot; : [&quot;code&quot;,&quot;code2&quot;,&quot;code3&quot;]],18)me.0 //&quot;name&quot;me.1 //&quot;jianxiong&quot;me.2 //[&quot;like&quot; : [&quot;code&quot;,&quot;code2&quot;,&quot;code3&quot;]]me.3 //18 定义好一个Tuple之后，就可以使用代码 me.0 me.1 me.2 这样的方式来访问Tuple中的变量了，同时也可以直接修改变量的值 12345// update Tuple valueme.3 = 22var hour = 24 hour = 12 常量如果我们定义的值不希望被修改定义常量的方法和变量类似，我们把关键字var，变成关键字let就可以了。例如： 12let minutes = 30let fireIsHot = true 一旦我们定义常量之后，就不能再修改常量的值了，否则，编译器会告诉我们发生了错误。例如，我们修改常量fireIsHot： 1fireIsHot = false 这时，我们就可以在Playground中直接看到一个编译错误。 1Cannot assign to value: &apos;firelsHot&apos; is a &apos;let&apos; constant 只要程序中的变量值不会被修改，就总应该使用let来定义它。这不仅可以防止变量被意外修改，编译器还可以针对常量做更多优化。 Type inference / annotation在前面的例子里，我们可以发现，无论是整数、浮点数、字符串还有Tuple，我们都没有明确的指定变量的类型， Swift编译器会根据我们为变量的赋值自动推导变量的类型，这个特性，在Swift里叫做Type Inference。 但有时，我们定义变量的时候，并不能确定变量的初始值，这个时候，我们就必须像下面这样明确告诉编译器我们需要的变量类型：var Name:Type。这种通过:Type指定变量类型的形式，在Swift中叫做Type annotation。例如： 12var x: Intvar s: String","categories":[],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://github.com/jianxiongc/tags/Swift/"}]},{"title":"协程 阿里开源库 coobjc 初步分析","slug":"协程-阿里开源库-coobjc-初步分析","date":"2019-07-16T02:09:24.000Z","updated":"2019-07-16T02:26:48.297Z","comments":true,"path":"2019/07/16/协程-阿里开源库-coobjc-初步分析/","link":"","permalink":"https://github.com/jianxiongc/2019/07/16/协程-阿里开源库-coobjc-初步分析/","excerpt":"","text":"简介协程是计算机程序的一类组件，推广了非抢先多任务的子程序，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程源自 Simula 和 Modula-2 语言，但也有其他语言支持。协程更适合于用来实现彼此熟悉的程序组件，如合作式多任务、异常处理、事件循环、迭代器、无限列表和管道。根据高德纳的说法, 马尔文·康威于1958年发明了术语 coroutine 并用于构建汇编程序。—— Wikipedia coobjc 解决的问题iOS 异步编程问题官网描述: 基于 Block 的异步编程回调是目前 iOS 使用最广泛的异步编程方式，iOS 系统提供的 GCD 库让异步开发变得很简单方便，但是基于这种编程方式的缺点也有很多，主要有以下几点： 容易进入”嵌套地狱”错误处理复杂和冗长容易忘记调用 completion handler条件执行变得很困难从互相独立的调用中组合返回结果变得极其困难在错误的线程中继续执行难以定位原因的多线程崩溃锁和信号量滥用带来的卡顿、卡死上述问题反应到线上应用本身就会出现大量的多线程崩溃 协程的优势官网描述: 简明概念少：只有很少的几个操作符，相比响应式几十个操作符，简直不能再简单了原理简单: 协程的实现原理很简单，整个协程库只有几千行代码易用使用简单：它的使用方式比 GCD 还要简单，接口很少改造方便：现有代码只需要进行很少的改动就可以协程化，同时我们针对系统库提供了大量协程化接口清晰同步写异步逻辑：同步顺序方式写代码是人类最容易接受的方式，这可以极大的减少出错的概率可读性高: 使用协程方式编写的代码比 block 嵌套写出来的代码可读性要高很多性能调度性能更快：协程本身不需要进行内核级线程的切换，调度性能快，即使创建上万个协程也毫无压力减少卡顿卡死: 协程的使用以帮助开发减少锁、信号量的滥用，通过封装会引起阻塞的 IO 等协程接口，可以从根源上减少卡顿、卡死，提升应用整体的性能 核心能力提供了类似C#和Javascript语言中的Async/Await编程方式支持，在协程中通过调用await方法即可同步得到异步方法的执行结果，非常适合IO、网络等异步耗时调用的同步顺序执行改造。提供了类似Kotlin中的Generator功能，用于懒计算生成序列化数据，非常适合多线程可中断的序列化数据生成和访问。提供了Actor Model的实现，基于Actor Model，开发者可以开发出更加线程安全的模块，避免由于直接函数调用引发的各种多线程崩溃问题。提供了元组的支持，通过元组Objective-C开发者可以享受到类似Python语言中多值返回的好处。 内置系统扩展库 提供了对NSArray、NSDictionary等容器库的协程化扩展，用于解决序列化和反序列化过程中的异步调用问题。 提供了对NSData、NSString、UIImage等数据对象的协程化扩展，用于解决读写IO过程中的异步调用问题。 提供了对NSURLConnection和NSURLSession的协程化扩展，用于解决网络异步请求过程中的异步调用问题。 提供了对NSKeyedArchieve、NSJSONSerialization等解析库的扩展，用于解决解析过程中的异步调用问题。 coobjc 设计 图片 最底层是协程内核，包含了栈切换的管理、协程调度器的实现、协程间通信channel的实现等。中间层是基于协程的操作符的包装，目前支持async/await、Generator、Actor等编程模型。最上层是对系统库的协程化扩展，目前基本上覆盖了Foundation和UIKit的所有IO和耗时方法。 核心实现原理协程的核心思想是控制调用栈的主动让出和恢复。一般的协程实现都会提供两个重要的操作： Yield：是让出cpu的意思，它会中断当前的执行，回到上一次Resume的地方。Resume：继续协程的运行。执行Resume后，回到上一次协程Yield的地方。 我们基于线程的代码执行时候，是没法做出暂停操作的，我们现在要做的事情就是要代码执行能够暂停，还能够再恢复。 基本上代码执行都是一种基于调用栈的模型，所以如果我们能把当前调用栈上的状态都保存下来，然后再能从缓存中恢复，那我们就能够实现yield和 resume。实现这样操作有几种方法呢？ 第一种：利用glibc 的 ucontext组件(云风的库)。第二种：使用汇编代码来切换上下文(实现c协程)，原理同ucontext。第三种：利用C语言语法switch-case的奇淫技巧来实现（Protothreads)。第四种：利用了 C 语言的 setjmp 和 longjmp。第五种：利用编译器支持语法糖。 上述第三种和第四种只是能过做到跳转，但是没法保存调用栈上的状态，看起来基本上不能算是实现了协程，只能算做做demo，第五种除非官方支持，否则自行改写编译器通用性很差。而第一种方案的 ucontext 在iOS上是废弃了的，不能使用。那么我们使用的是第二种方案，自己用汇编模拟一下 ucontext。模拟ucontext的核心是通过getContext和setContext实现保存和恢复调用栈。需要熟悉不同CPU架构下的调用约定(Calling Convention). 汇编实现就是要针对不同cpu实现一套，我们目前实现了 armv7、arm64、i386、x86_64，支持iPhone真机和模拟器。 官方例子整体结构如下 图片 cokit cokit库为Foundation和UIKit系统库提供了一个协程封装，它依赖于coobjc库，为IO，网络等耗时的方法提供协同处理的封装。 coobjc coobjc的Objective-C版实现的源代码 *coswift * coswift的Swift版源代码 Examples coobjcBaseExample是OC版本的Demo coSwiftExample是OC版本的Demo 项目运行直接看看coobjcBaseExample的效果 图片 这个界面可以看到一个简单的列表页。对应到代码中的KMDiscoverListViewControllerViewDidLoad中有如下代码 1234567- (void)viewDidLoad&#123; [super viewDidLoad]; [self setupTableView]; [self requestMovies];&#125; 从方法名可以得知，requestMovies实现了网络拉取电影列表的功能。看 requestMovies 中的实现 12345678910111213141516- (void)requestMovies&#123; co_launch(^&#123; NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;]; [self.refreshControl endRefreshing]; if (dataArray != nil) &#123; [self processData:dataArray]; &#125; else &#123; [self.networkLoadingViewController showErrorView]; &#125; &#125;);&#125; 先抛开co_launch不管，可以发现 1NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;]; 实现了网络请求，获取数据，getDiscoverList实现代码如下 1234567- (NSArray*)getDiscoverList:(NSString *)pageLimit;&#123; NSString *url = [NSString stringWithFormat:@&quot;%@&amp;page=%@&quot;, [self prepareUrl], pageLimit]; id json = [[DataService sharedInstance] requestJSONWithURL:url]; NSDictionary* infosDictionary = [self dictionaryFromResponseObject:json jsonPatternFile:@&quot;KMDiscoverSourceJsonPattern.json&quot;]; return [self processResponseObject:infosDictionary];&#125; 根据代码可以发现 1id json = [[DataService sharedInstance] requestJSONWithURL:url]; 这一段实现了网络请求，然后继续去进入requestJSONWithURL去看 1234- (id)requestJSONWithURL:(NSString*)url CO_ASYNC&#123; SURE_ASYNC return await([self.jsonActor sendMessage:url]);&#125; 这个时候发现 SURE_ASYNC 和 awiat 类似于ES7中的async 和 await，ES7中async-await是promise和generator的语法糖。只是为了让我们书写代码时更加流畅，当然也增强了代码的可读性，看起来这块起到了类似的作用。再来仔细了解下协程。 协程入门上面的核心实现原理中有提到，实现核心的yield和resume有五种方法，其中说到第三、四种只能做到过跳转，没办法保存调用栈,无法真正的实现协程。第五种除非官方支持。第一种ucontext在iOS是废弃了的。那么第二种方案，自己用汇编模拟ucontext。 首先，ucontext 是啥？ ucontext 机制是GUN C库提供的一组用于创建、保存、切换用户态执行context的API。主要包括以下四个函数 1234void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);int swapcontext(ucontext_t *oucp, ucontext_t *ucp);int getcontext(ucontext_t *ucp);int setcontext(const ucontext_t *ucp); 详细参见[我所理解的ucontext族函数]https://www.jianshu.com/p/dfd7ac1402f0[构建C协程之ucontext篇]https://blog.csdn.net/gettogetto/article/details/53306897 来看一段简单的代码 123456789101112131415161718192021#include &lt;stdio.h&gt;//由于在Mac OS X 10.6.6 ucontext被弃用的关系 ，需要使用sys/ucontext.h#include &lt;sys/ucontext.h&gt;#include &lt;unistd.h&gt;int main(int argc, char const *argv[])&#123; // ----&gt; ucontext ucontext_t context; getcontext(&amp;context); puts(&quot;Hello world&quot;); sleep(1); setcontext(&amp;context);// ----&gt; goto // loop: puts(&quot;%s\\n&quot;,&quot;Hello world&quot;);// sleep(1);// goto loop; return 0;&#125; 保存上述代码到 example.c，执行编译命令： 1gcc example.c -o example 图片 可以看到这里会不断执行，通过setcontext和getcontext实现切换。更详细参见我所理解的ucontext族函数构建C协程之ucontext篇上面核心实现原理中讲到了第二种：使用汇编代码来切换上下文(实现c协程)，原理同ucontext。我们在coobjc中的库中发现了唯一一个汇编文件coroutine_context.s 图片 在汇编文件中发现主要提供了三个方法 _coroutine_getcontext _coroutine_begin _coroutine_setcontext 同样在 coroutine_context.h中暴露了 123456extern int coroutine_getcontext (coroutine_ucontext_t *__ucp);extern int coroutine_setcontext (coroutine_ucontext_t *__ucp);extern int coroutine_begin (coroutine_ucontext_t *__ucp);extern void coroutine_makecontext (coroutine_ucontext_t *__ucp, IMP func, void *arg, void *stackTop); 其中coroutine_makecontext在coroutine_context.m中实现回到例子中co_launch 来自 coobjc.h ,来关注一下coobjc.h 里的内联函数 co_launch 创建一个协程，然后在当前线程中异步恢复它 co_launch_now 创建一个协程，然后在当前线程立即恢复它 co_launch_withStackSize 创建一个协程，然后在当前线程中异步恢复它，与co_launch不同 ，他可以设定堆栈大小 默认为65536 最大限制为1M co_launch_onqueue 创建一个协程，并在给定的线程中异步恢复它 co_sequence 创建一个生成器 co_sequence_onqueue 在指定的线程中创建一个生成器 co_actor 创建一个容器 co_actor_onqueue 在指定线程中创建一个容器 await 用await得到异步执行的结果，等待异步方法的执行 batch_await 批量的await 目前没找到哪里用 co_delay 使当前协程sleep 多少秒 co_isActive 判断一个协程是否有效 co_isCancelled 检查当前协程是否取消 其他的一些宏定义 CO_ASYNC 给方法一个标记，表示方法是可被暂停的，类似于JS中 async SURE_ASYNC 断言 yield 暂停 在看看用到的co_launch 文档描述在当前线程中创建协程 123456789101112- (void)requestMovies&#123; //创建协程 co_launch(^&#123; //进行网络加载，但并没有在这里进行await NSArray *dataArray = [[KMDiscoverSource discoverSource] getDiscoverList:@&quot;1&quot;]; [self.refreshControl endRefreshing]; if (dataArray != nil) &#123; [self processData:dataArray]; &#125; else12345 &#123; [self.networkLoadingViewController showErrorView]; &#125; &#125;);&#125; 接着往下看 12345//在这里写了CO_ASYNC 表示该方法是可以被暂停的 同时在方法内await等待异步的结果- (id)requestJSONWithURL:(NSString*)url CO_ASYNC&#123; SURE_ASYNC return await([self.jsonActor sendMessage:url]);&#125; 下面看看 self.jsonActor 及 sendMessage 12345/*jsonActor 是一个COActor 的对象，文档中描述_ Actor 的概念来自于 Erlang ，在 AKKA 中，可以认为一个 Actor 就是一个容器，用以存储状态、行为、Mailbox 以及子 Actor 与 Supervisor 策略。Actor 之间并不直接通信，而是通过 Mail 来互通有无。_*/@property (nonatomic, strong) COActor *jsonActor; 此时看到 DataService.m中有init 注册了接受消息的实现 123456789101112131415161718192021_jsonActor = co_actor_onqueue(_jsonQueue, ^(COActorChan *channel) &#123; NSData *data = nil; id json = nil; COActorCompletable *completable = nil; for (COActorMessage *message in channel) &#123; NSString *url = [message stringType]; json = nil; if (url.length &gt; 0) &#123; //这里接受到消息之后将消息发送到 networkActor completable = [self.networkActor sendMessage:url]; data = await(completable); if (data) &#123; json = [NSJSONSerialization JSONObjectWithData:data options:0 error:nil]; &#125; message.complete(json); &#125; else&#123; message.complete(nil); &#125; &#125;&#125;); 收到消息后将json的消息回复到上层。展示数据 参考阅读[阿里云栖社区对coobjc介绍]https://www.jianshu.com/p/cd7f6ef5a8fd[我所理解的ucontext族函数]https://www.jianshu.com/p/dfd7ac1402f0[构建C协程之ucontext篇]https://blog.csdn.net/gettogetto/article/details/53306897[理解 JavaScript 的 async/await]https://segmentfault.com/a/1190000007535316?utm_source=tag-newest[GC 7.1 Mac OS X 10.6.6: ucontext routines are deprecated]https://www.hpl.hp.com/hosted/linux/mail-archives/gc/2011-February/004354.html[PSA: avoiding the “ucontext routines are deprecated” error on Mac OS X Snow Leopard]http://duriansoftware.com/joe/PSA%3a-avoiding-the-%22ucontext-routines-are-deprecated%22-error-on-Mac-OS-X-Snow-Leopard.html","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://github.com/jianxiongc/tags/iOS/"}]}]}